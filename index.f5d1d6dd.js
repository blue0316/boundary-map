var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {}
  , e = {}
  , i = {}
  , r = t.parcelRequire1717;
null == r && ((r = function(t) {
    if (t in e)
        return e[t].exports;
    if (t in i) {
        var r = i[t];
        delete i[t];
        var n = {
            id: t,
            exports: {}
        };
        return e[t] = n,
        r.call(n.exports, n, n.exports),
        n.exports
    }
    var o = new Error("Cannot find module '" + t + "'");
    throw o.code = "MODULE_NOT_FOUND",
    o
}
).register = function(t, e) {
    i[t] = e
}
,
t.parcelRequire1717 = r);
var n = {};
!function(t, e) {
    "object" == typeof n ? n = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).mapboxgl = e()
}(n, (function() {
    var t, e, i;
    function r(r, n) {
        if (t)
            if (e) {
                var o = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + t + ")(sharedChunk); (" + e + ")(sharedChunk); self.onerror = null;"
                  , s = {};
                t(s),
                i = n(s),
                "undefined" != typeof window && window && window.URL && window.URL.createObjectURL && (i.workerUrl = window.URL.createObjectURL(new Blob([o],{
                    type: "text/javascript"
                })))
            } else
                e = n;
        else
            t = n
    }
    return r(0, (function(t) {
        var e = "undefined" != typeof self ? self : {}
          , i = "2.12.0";
        let r;
        const n = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX() {
                if (null == r) {
                    const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                        r = t
                    } catch (e) {
                        r = t
                    }
                }
                return r
            },
            get API_TILEJSON_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
            },
            get API_SPRITE_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
            },
            get API_FONTS_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
            },
            get API_STYLE_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
            },
            get API_CDN_URL_REGEX() {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
            },
            get EVENTS_URL() {
                return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            MAX_PARALLEL_IMAGE_REQUESTS: 16
        }
          , o = {
            supported: !1,
            testSupport: function(t) {
                !l && a && (c ? u(t) : s = t)
            }
        };
        let s, a, l = !1, c = !1;
        function u(t) {
            const e = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, e);
            try {
                if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, a),
                t.isContextLost())
                    return;
                o.supported = !0
            } catch (t) {}
            t.deleteTexture(e),
            l = !0
        }
        e.document && (a = e.document.createElement("img"),
        a.onload = function() {
            s && u(s),
            s = null,
            c = !0
        }
        ,
        a.onerror = function() {
            l = !0,
            s = null
        }
        ,
        a.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h = "01";
        var d = p;
        function p(t, e, i, r) {
            this.cx = 3 * t,
            this.bx = 3 * (i - t) - this.cx,
            this.ax = 1 - this.cx - this.bx,
            this.cy = 3 * e,
            this.by = 3 * (r - e) - this.cy,
            this.ay = 1 - this.cy - this.by,
            this.p1x = t,
            this.p1y = e,
            this.p2x = i,
            this.p2y = r
        }
        p.prototype = {
            sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
            },
            sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
            },
            sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
            },
            solveCurveX: function(t, e) {
                if (void 0 === e && (e = 1e-6),
                t < 0)
                    return 0;
                if (t > 1)
                    return 1;
                for (var i = t, r = 0; r < 8; r++) {
                    var n = this.sampleCurveX(i) - t;
                    if (Math.abs(n) < e)
                        return i;
                    var o = this.sampleCurveDerivativeX(i);
                    if (Math.abs(o) < 1e-6)
                        break;
                    i -= n / o
                }
                var s = 0
                  , a = 1;
                for (i = t,
                r = 0; r < 20 && (n = this.sampleCurveX(i),
                !(Math.abs(n - t) < e)); r++)
                    t > n ? s = i : a = i,
                    i = .5 * (a - s) + s;
                return i
            },
            solve: function(t, e) {
                return this.sampleCurveY(this.solveCurveX(t, e))
            }
        };
        var m = f;
        function f(t, e) {
            this.x = t,
            this.y = e
        }
        f.prototype = {
            clone: function() {
                return new f(this.x,this.y)
            },
            add: function(t) {
                return this.clone()._add(t)
            },
            sub: function(t) {
                return this.clone()._sub(t)
            },
            multByPoint: function(t) {
                return this.clone()._multByPoint(t)
            },
            divByPoint: function(t) {
                return this.clone()._divByPoint(t)
            },
            mult: function(t) {
                return this.clone()._mult(t)
            },
            div: function(t) {
                return this.clone()._div(t)
            },
            rotate: function(t) {
                return this.clone()._rotate(t)
            },
            rotateAround: function(t, e) {
                return this.clone()._rotateAround(t, e)
            },
            matMult: function(t) {
                return this.clone()._matMult(t)
            },
            unit: function() {
                return this.clone()._unit()
            },
            perp: function() {
                return this.clone()._perp()
            },
            round: function() {
                return this.clone()._round()
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            equals: function(t) {
                return this.x === t.x && this.y === t.y
            },
            dist: function(t) {
                return Math.sqrt(this.distSqr(t))
            },
            distSqr: function(t) {
                var e = t.x - this.x
                  , i = t.y - this.y;
                return e * e + i * i
            },
            angle: function() {
                return Math.atan2(this.y, this.x)
            },
            angleTo: function(t) {
                return Math.atan2(this.y - t.y, this.x - t.x)
            },
            angleWith: function(t) {
                return this.angleWithSep(t.x, t.y)
            },
            angleWithSep: function(t, e) {
                return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e)
            },
            _matMult: function(t) {
                var e = t[2] * this.x + t[3] * this.y;
                return this.x = t[0] * this.x + t[1] * this.y,
                this.y = e,
                this
            },
            _add: function(t) {
                return this.x += t.x,
                this.y += t.y,
                this
            },
            _sub: function(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this
            },
            _mult: function(t) {
                return this.x *= t,
                this.y *= t,
                this
            },
            _div: function(t) {
                return this.x /= t,
                this.y /= t,
                this
            },
            _multByPoint: function(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            },
            _divByPoint: function(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            },
            _unit: function() {
                return this._div(this.mag()),
                this
            },
            _perp: function() {
                var t = this.y;
                return this.y = this.x,
                this.x = -t,
                this
            },
            _rotate: function(t) {
                var e = Math.cos(t)
                  , i = Math.sin(t)
                  , r = i * this.x + e * this.y;
                return this.x = e * this.x - i * this.y,
                this.y = r,
                this
            },
            _rotateAround: function(t, e) {
                var i = Math.cos(t)
                  , r = Math.sin(t)
                  , n = e.y + r * (this.x - e.x) + i * (this.y - e.y);
                return this.x = e.x + i * (this.x - e.x) - r * (this.y - e.y),
                this.y = n,
                this
            },
            _round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
        },
        f.convert = function(t) {
            return t instanceof f ? t : Array.isArray(t) ? new f(t[0],t[1]) : t
        }
        ;
        const _ = Math.PI / 180
          , g = 180 / Math.PI;
        function y(t) {
            return t * _
        }
        function x(t) {
            return t * g
        }
        const v = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function b(t) {
            if (t <= 0)
                return 0;
            if (t >= 1)
                return 1;
            const e = t * t
              , i = e * t;
            return 4 * (t < .5 ? i : 3 * (t - e) + i - .75)
        }
        function w(t, e, i, r) {
            const n = new d(t,e,i,r);
            return function(t) {
                return n.solve(t)
            }
        }
        const z = w(.25, .1, .25, 1);
        function T(t, e, i) {
            return Math.min(i, Math.max(e, t))
        }
        function E(t, e, i) {
            return (i = T((i - t) / (e - t), 0, 1)) * i * (3 - 2 * i)
        }
        function S(t, e, i) {
            const r = i - e
              , n = ((t - e) % r + r) % r + e;
            return n === e ? i : n
        }
        function M(t, e, i) {
            if (!t.length)
                return i(null, []);
            let r = t.length;
            const n = new Array(t.length);
            let o = null;
            t.forEach(((t,s)=>{
                e(t, ((t,e)=>{
                    t && (o = t),
                    n[s] = e,
                    0 == --r && i(o, n)
                }
                ))
            }
            ))
        }
        function A(t) {
            const e = [];
            for (const i in t)
                e.push(t[i]);
            return e
        }
        function I(t, ...e) {
            for (const i of e)
                for (const e in i)
                    t[e] = i[e];
            return t
        }
        let C = 1;
        function D() {
            return C++
        }
        function k() {
            return function t(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t)
            }()
        }
        function P(t) {
            return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function L(t) {
            return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)
        }
        function O(t, e) {
            t.forEach((t=>{
                e[t] && (e[t] = e[t].bind(e))
            }
            ))
        }
        function R(t, e) {
            return -1 !== t.indexOf(e, t.length - e.length)
        }
        function B(t, e, i) {
            const r = {};
            for (const n in t)
                r[n] = e.call(i || this, t[n], n, t);
            return r
        }
        function F(t, e, i) {
            const r = {};
            for (const n in t)
                e.call(i || this, t[n], n, t) && (r[n] = t[n]);
            return r
        }
        function U(t) {
            return Array.isArray(t) ? t.map(U) : "object" == typeof t && t ? B(t, U) : t
        }
        const N = {};
        function G(t) {
            N[t] || ("undefined" != typeof console && console.warn(t),
            N[t] = !0)
        }
        function j(t, e, i) {
            return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x)
        }
        function V(t) {
            let e = 0;
            for (let i, r, n = 0, o = t.length, s = o - 1; n < o; s = n++)
                i = t[n],
                r = t[s],
                e += (r.x - i.x) * (i.y + r.y);
            return e
        }
        function Z() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope
        }
        function J(t) {
            const e = {};
            if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t,i,r,n)=>{
                const o = r || n;
                return e[i] = !o || o.toLowerCase(),
                ""
            }
            )),
            e["max-age"]) {
                const t = parseInt(e["max-age"], 10);
                isNaN(t) ? delete e["max-age"] : e["max-age"] = t
            }
            return e
        }
        let X = null;
        function q(t) {
            if (null == X) {
                const e = t.navigator ? t.navigator.userAgent : null;
                X = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")))
            }
            return X
        }
        function $(t) {
            try {
                const i = e[t];
                return i.setItem("_mapbox_test_", 1),
                i.removeItem("_mapbox_test_"),
                !0
            } catch (t) {
                return !1
            }
        }
        function Y(t, e) {
            return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]]
        }
        const W = "mapbox-tiles";
        let H, K, Q = 500, tt = 50;
        function et() {
            try {
                return e.caches
            } catch (t) {}
        }
        function it() {
            et() && !H && (H = e.caches.open(W))
        }
        function rt(t) {
            const e = t.indexOf("?");
            if (e < 0)
                return t;
            const i = function(t) {
                const e = t.indexOf("?");
                return e > 0 ? t.slice(e + 1).split("&") : []
            }(t).filter((t=>{
                const e = t.split("=");
                return "language" === e[0] || "worldview" === e[0]
            }
            ));
            return i.length ? `${t.slice(0, e)}?${i.join("&")}` : t.slice(0, e)
        }
        let nt = 1 / 0;
        const ot = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(ot);
        class st extends Error {
            constructor(t, e, i) {
                401 === e && gt(i) && (t += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                super(t),
                this.status = e,
                this.url = i
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`
            }
        }
        const at = Z() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === e.location.protocol ? e.parent : e).location.href
          , lt = function(t, i) {
            if (!(/^file:/.test(r = t.url) || /^file:/.test(at()) && !/^\w+:/.test(r))) {
                if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
                    return function(t, i) {
                        const r = new e.AbortController
                          , n = new e.Request(t.url,{
                            method: t.method || "GET",
                            body: t.body,
                            credentials: t.credentials,
                            headers: t.headers,
                            referrer: at(),
                            signal: r.signal
                        });
                        let o = !1
                          , s = !1;
                        const a = (l = n.url).indexOf("sku=") > 0 && gt(l);
                        var l;
                        "json" === t.type && n.headers.set("Accept", "application/json");
                        const c = (r,o,l)=>{
                            if (s)
                                return;
                            if (r && "SecurityError" !== r.message && G(r),
                            o && l)
                                return u(o);
                            const c = Date.now();
                            e.fetch(n).then((e=>{
                                if (e.ok) {
                                    const t = a ? e.clone() : null;
                                    return u(e, t, c)
                                }
                                return i(new st(e.statusText,e.status,t.url))
                            }
                            )).catch((t=>{
                                20 !== t.code && i(new Error(t.message))
                            }
                            ))
                        }
                          , u = (r,a,l)=>{
                            ("arrayBuffer" === t.type ? r.arrayBuffer() : "json" === t.type ? r.json() : r.text()).then((t=>{
                                s || (a && l && function(t, i, r) {
                                    if (it(),
                                    !H)
                                        return;
                                    const n = {
                                        status: i.status,
                                        statusText: i.statusText,
                                        headers: new e.Headers
                                    };
                                    i.headers.forEach(((t,e)=>n.headers.set(e, t)));
                                    const o = J(i.headers.get("Cache-Control") || "");
                                    if (o["no-store"])
                                        return;
                                    o["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * o["max-age"]).toUTCString());
                                    const s = n.headers.get("Expires");
                                    s && (new Date(s).getTime() - r < 42e4 || function(t, e) {
                                        if (void 0 === K)
                                            try {
                                                new Response(new ReadableStream),
                                                K = !0
                                            } catch (t) {
                                                K = !1
                                            }
                                        K ? e(t.body) : t.blob().then(e)
                                    }(i, (i=>{
                                        const r = new e.Response(i,n);
                                        it(),
                                        H && H.then((e=>e.put(rt(t.url), r))).catch((t=>G(t.message)))
                                    }
                                    )))
                                }(n, a, l),
                                o = !0,
                                i(null, t, r.headers.get("Cache-Control"), r.headers.get("Expires")))
                            }
                            )).catch((t=>{
                                s || i(new Error(t.message))
                            }
                            ))
                        }
                        ;
                        return a ? function(t, e) {
                            if (it(),
                            !H)
                                return e(null);
                            const i = rt(t.url);
                            H.then((t=>{
                                t.match(i).then((r=>{
                                    const n = function(t) {
                                        if (!t)
                                            return !1;
                                        const e = new Date(t.headers.get("Expires") || 0)
                                          , i = J(t.headers.get("Cache-Control") || "");
                                        return e > Date.now() && !i["no-cache"]
                                    }(r);
                                    t.delete(i),
                                    n && t.put(i, r.clone()),
                                    e(null, r, n)
                                }
                                )).catch(e)
                            }
                            )).catch(e)
                        }(n, c) : c(null, null),
                        {
                            cancel: ()=>{
                                s = !0,
                                o || r.abort()
                            }
                        }
                    }(t, i);
                if (Z() && self.worker && self.worker.actor)
                    return self.worker.actor.send("getResource", t, i, void 0, !0)
            }
            var r;
            return function(t, i) {
                const r = new e.XMLHttpRequest;
                r.open(t.method || "GET", t.url, !0),
                "arrayBuffer" === t.type && (r.responseType = "arraybuffer");
                for (const e in t.headers)
                    r.setRequestHeader(e, t.headers[e]);
                return "json" === t.type && (r.responseType = "text",
                r.setRequestHeader("Accept", "application/json")),
                r.withCredentials = "include" === t.credentials,
                r.onerror = ()=>{
                    i(new Error(r.statusText))
                }
                ,
                r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let e = r.response;
                        if ("json" === t.type)
                            try {
                                e = JSON.parse(r.response)
                            } catch (t) {
                                return i(t)
                            }
                        i(null, e, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"))
                    } else
                        i(new st(r.statusText,r.status,t.url))
                }
                ,
                r.send(t.body),
                {
                    cancel: ()=>r.abort()
                }
            }(t, i)
        }
          , ct = function(t, e) {
            return lt(I(t, {
                type: "arrayBuffer"
            }), e)
        };
        function ut(t) {
            const i = e.document.createElement("a");
            return i.href = t,
            i.protocol === e.document.location.protocol && i.host === e.document.location.host
        }
        const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let dt, pt;
        dt = [],
        pt = 0;
        const mt = function(t, i) {
            if (o.supported && (t.headers || (t.headers = {}),
            t.headers.accept = "image/webp,*/*"),
            pt >= n.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e = {
                    requestParameters: t,
                    callback: i,
                    cancelled: !1,
                    cancel() {
                        this.cancelled = !0
                    }
                };
                return dt.push(e),
                e
            }
            pt++;
            let r = !1;
            const s = ()=>{
                if (!r)
                    for (r = !0,
                    pt--; dt.length && pt < n.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                        const t = dt.shift()
                          , {requestParameters: e, callback: i, cancelled: r} = t;
                        r || (t.cancel = mt(e, i).cancel)
                    }
            }
              , a = ct(t, ((t,r,n,o)=>{
                s(),
                t ? i(t) : r && (e.createImageBitmap ? function(t, i) {
                    const r = new e.Blob([new Uint8Array(t)],{
                        type: "image/png"
                    });
                    e.createImageBitmap(r).then((t=>{
                        i(null, t)
                    }
                    )).catch((t=>{
                        i(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`))
                    }
                    ))
                }(r, ((t,e)=>i(t, e, n, o))) : function(t, i) {
                    const r = new e.Image
                      , n = e.URL;
                    r.onload = ()=>{
                        i(null, r),
                        n.revokeObjectURL(r.src),
                        r.onload = null,
                        e.requestAnimationFrame((()=>{
                            r.src = ht
                        }
                        ))
                    }
                    ,
                    r.onerror = ()=>i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const o = new e.Blob([new Uint8Array(t)],{
                        type: "image/png"
                    });
                    r.src = t.byteLength ? n.createObjectURL(o) : ht
                }(r, ((t,e)=>i(t, e, n, o))))
            }
            ));
            return {
                cancel: ()=>{
                    a.cancel(),
                    s()
                }
            }
        }
          , ft = "NO_ACCESS_TOKEN";
        function _t(t) {
            return 0 === t.indexOf("mapbox:")
        }
        function gt(t) {
            return n.API_URL_REGEX.test(t)
        }
        function yt(t) {
            return n.API_CDN_URL_REGEX.test(t)
        }
        function xt(t) {
            return n.API_STYLE_REGEX.test(t) && !vt(t)
        }
        function vt(t) {
            return n.API_SPRITE_REGEX.test(t)
        }
        const bt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function wt(t) {
            const e = t.match(bt);
            if (!e)
                throw new Error("Unable to parse URL object");
            return {
                protocol: e[1],
                authority: e[2],
                path: e[3] || "/",
                params: e[4] ? e[4].split("&") : []
            }
        }
        function zt(t) {
            const e = t.params.length ? `?${t.params.join("&")}` : "";
            return `${t.protocol}://${t.authority}${t.path}${e}`
        }
        function Tt(t) {
            if (!t)
                return null;
            const i = t.split(".");
            if (!i || 3 !== i.length)
                return null;
            try {
                return JSON.parse(decodeURIComponent(e.atob(i[1]).split("").map((t=>"%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2))).join("")))
            } catch (t) {
                return null
            }
        }
        class Et {
            constructor(t) {
                this.type = t,
                this.anonId = null,
                this.eventData = {},
                this.queue = [],
                this.pendingRequest = null
            }
            getStorageKey(t) {
                const i = Tt(n.ACCESS_TOKEN);
                let r = "";
                return r = i && i.u ? e.btoa(encodeURIComponent(i.u).replace(/%([0-9A-F]{2})/g, ((t,e)=>String.fromCharCode(Number("0x" + e))))) : n.ACCESS_TOKEN || "",
                t ? `mapbox.eventData.${t}:${r}` : `mapbox.eventData:${r}`
            }
            fetchEventData() {
                const t = $("localStorage")
                  , i = this.getStorageKey()
                  , r = this.getStorageKey("uuid");
                if (t)
                    try {
                        const t = e.localStorage.getItem(i);
                        t && (this.eventData = JSON.parse(t));
                        const n = e.localStorage.getItem(r);
                        n && (this.anonId = n)
                    } catch (t) {
                        G("Unable to read from LocalStorage")
                    }
            }
            saveEventData() {
                const t = $("localStorage")
                  , i = this.getStorageKey()
                  , r = this.getStorageKey("uuid");
                if (t)
                    try {
                        e.localStorage.setItem(r, this.anonId),
                        Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(i, JSON.stringify(this.eventData))
                    } catch (t) {
                        G("Unable to write to LocalStorage")
                    }
            }
            processRequests(t) {}
            postEvent(t, e, i, r) {
                if (!n.EVENTS_URL)
                    return;
                const o = wt(n.EVENTS_URL);
                o.params.push(`access_token=${r || n.ACCESS_TOKEN || ""}`);
                const s = {
                    event: this.type,
                    created: new Date(t).toISOString()
                }
                  , a = e ? I(s, e) : s
                  , l = {
                    url: zt(o),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([a])
                };
                var c;
                this.pendingRequest = (c = t=>{
                    this.pendingRequest = null,
                    i(t),
                    this.saveEventData(),
                    this.processRequests(r)
                }
                ,
                lt(I(l, {
                    method: "POST"
                }), c))
            }
            queueRequest(t, e) {
                this.queue.push(t),
                this.processRequests(e)
            }
        }
        const St = new class extends Et {
            constructor(t) {
                super("appUserTurnstile"),
                this._customAccessToken = t
            }
            postTurnstileEvent(t, e) {
                n.EVENTS_URL && n.ACCESS_TOKEN && Array.isArray(t) && t.some((t=>_t(t) || gt(t))) && this.queueRequest(Date.now(), e)
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length)
                    return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const e = Tt(n.ACCESS_TOKEN)
                  , r = e ? e.u : n.ACCESS_TOKEN;
                let o = r !== this.eventData.tokenU;
                L(this.anonId) || (this.anonId = k(),
                o = !0);
                const s = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const t = new Date(this.eventData.lastSuccess)
                      , e = new Date(s)
                      , i = (s - this.eventData.lastSuccess) / 864e5;
                    o = o || i >= 1 || i < -1 || t.getDate() !== e.getDate()
                } else
                    o = !0;
                o ? this.postEvent(s, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: i,
                    skuId: h,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (t=>{
                    t || (this.eventData.lastSuccess = s,
                    this.eventData.tokenU = r)
                }
                ), t) : this.processRequests()
            }
        }
          , Mt = St.postTurnstileEvent.bind(St)
          , At = new class extends Et {
            constructor() {
                super("map.load"),
                this.success = {},
                this.skuToken = ""
            }
            postMapLoadEvent(t, e, i, r) {
                this.skuToken = e,
                this.errorCb = r,
                n.EVENTS_URL && (i || n.ACCESS_TOKEN ? this.queueRequest({
                    id: t,
                    timestamp: Date.now()
                }, i) : this.errorCb(new Error(ft)))
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length)
                    return;
                const {id: e, timestamp: r} = this.queue.shift();
                e && this.success[e] || (this.anonId || this.fetchEventData(),
                L(this.anonId) || (this.anonId = k()),
                this.postEvent(r, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: i,
                    skuId: h,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (t=>{
                    t ? this.errorCb(t) : e && (this.success[e] = !0)
                }
                ), t))
            }
        }
          , It = At.postMapLoadEvent.bind(At)
          , Ct = new class extends Et {
            constructor() {
                super("gljs.performance")
            }
            postPerformanceEvent(t, e) {
                n.EVENTS_URL && (t || n.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: e
                }, t)
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length)
                    return;
                const {timestamp: r, performanceData: n} = this.queue.shift()
                  , o = function(t) {
                    const r = e.performance.getEntriesByType("resource")
                      , n = e.performance.getEntriesByType("mark")
                      , o = function(t) {
                        const e = {};
                        if (t)
                            for (const i in t)
                                if ("other" !== i)
                                    for (const r of t[i]) {
                                        const t = `${i}ResolveRangeMin`
                                          , n = `${i}ResolveRangeMax`
                                          , o = `${i}RequestCount`
                                          , s = `${i}RequestCachedCount`;
                                        e[t] = Math.min(e[t] || 1 / 0, r.startTime),
                                        e[n] = Math.max(e[n] || -1 / 0, r.responseEnd);
                                        const a = t=>{
                                            void 0 === e[t] && (e[t] = 0),
                                            ++e[t]
                                        }
                                        ;
                                        void 0 !== r.transferSize && 0 === r.transferSize && a(s),
                                        a(o)
                                    }
                        return e
                    }(function(t, e) {
                        const i = {};
                        if (t)
                            for (const r of t) {
                                const t = e(r);
                                void 0 === i[t] && (i[t] = []),
                                i[t].push(r)
                            }
                        return i
                    }(r, Bt))
                      , s = e.devicePixelRatio
                      , a = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection
                      , l = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }
                      , c = (t,e,i)=>{
                        null != i && t.push({
                            name: e,
                            value: i.toString()
                        })
                    }
                    ;
                    for (const t in o)
                        c(l.counters, t, o[t]);
                    if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (c(l.counters, "interactionRangeMin", t.interactionRange[0]),
                    c(l.counters, "interactionRangeMax", t.interactionRange[1])),
                    n)
                        for (const t of Object.keys(Ot)) {
                            const e = Ot[t]
                              , i = n.find((t=>t.name === e));
                            i && c(l.counters, e, i.startTime)
                        }
                    return c(l.counters, "visibilityHidden", t.visibilityHidden),
                    c(l.attributes, "style", function(t) {
                        if (t)
                            for (const e of t) {
                                const t = e.name.split("?")[0];
                                if (xt(t)) {
                                    const e = t.split("/").slice(-2);
                                    if (2 === e.length)
                                        return `mapbox://styles/${e[0]}/${e[1]}`
                                }
                            }
                    }(r)),
                    c(l.attributes, "terrainEnabled", t.terrainEnabled ? "true" : "false"),
                    c(l.attributes, "fogEnabled", t.fogEnabled ? "true" : "false"),
                    c(l.attributes, "projection", t.projection),
                    c(l.attributes, "zoom", t.zoom),
                    c(l.metadata, "devicePixelRatio", s),
                    c(l.metadata, "connectionEffectiveType", a ? a.effectiveType : void 0),
                    c(l.metadata, "navigatorUserAgent", e.navigator.userAgent),
                    c(l.metadata, "screenWidth", e.screen.width),
                    c(l.metadata, "screenHeight", e.screen.height),
                    c(l.metadata, "windowWidth", e.innerWidth),
                    c(l.metadata, "windowHeight", e.innerHeight),
                    c(l.metadata, "mapWidth", t.width / s),
                    c(l.metadata, "mapHeight", t.height / s),
                    c(l.metadata, "webglRenderer", t.renderer),
                    c(l.metadata, "webglVendor", t.vendor),
                    c(l.metadata, "sdkVersion", i),
                    c(l.metadata, "sdkIdentifier", "mapbox-gl-js"),
                    l
                }(n);
                for (const t of o.metadata)
                    ;
                for (const t of o.counters)
                    ;
                for (const t of o.attributes)
                    ;
                this.postEvent(r, o, (()=>{}
                ), t)
            }
        }
          , Dt = Ct.postPerformanceEvent.bind(Ct)
          , kt = new class extends Et {
            constructor() {
                super("map.auth"),
                this.success = {},
                this.skuToken = ""
            }
            getSession(t, e, i, r) {
                if (!n.API_URL || !n.SESSION_PATH)
                    return;
                const o = wt(n.API_URL + n.SESSION_PATH);
                o.params.push(`sku=${e || ""}`),
                o.params.push(`access_token=${r || n.ACCESS_TOKEN || ""}`);
                const s = {
                    url: zt(o),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                var a;
                this.pendingRequest = (a = t=>{
                    this.pendingRequest = null,
                    i(t),
                    this.saveEventData(),
                    this.processRequests(r)
                }
                ,
                lt(I(s, {
                    method: "GET"
                }), a))
            }
            getSessionAPI(t, e, i, r) {
                this.skuToken = e,
                this.errorCb = r,
                n.SESSION_PATH && n.API_URL && (i || n.ACCESS_TOKEN ? this.queueRequest({
                    id: t,
                    timestamp: Date.now()
                }, i) : this.errorCb(new Error(ft)))
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length)
                    return;
                const {id: e, timestamp: i} = this.queue.shift();
                e && this.success[e] || this.getSession(i, this.skuToken, (t=>{
                    t ? this.errorCb(t) : e && (this.success[e] = !0)
                }
                ), t)
            }
        }
          , Pt = kt.getSessionAPI.bind(kt)
          , Lt = new Set
          , Ot = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }
          , Rt = {
            mark(t) {
                e.performance.mark(t)
            },
            measure(t, i, r) {
                e.performance.measure(t, i, r)
            }
        };
        function Bt(t) {
            const e = t.name.split("?")[0];
            return yt(e) && e.includes("mapbox-gl.js") ? "javascript" : yt(e) && e.includes("mapbox-gl.css") ? "css" : (i = e,
            n.API_FONTS_REGEX.test(i) ? "fontRange" : vt(e) ? "sprite" : xt(e) ? "style" : function(t) {
                return n.API_TILEJSON_REGEX.test(t)
            }(e) ? "tilejson" : "other");
            var i
        }
        const Ft = e.performance;
        function Ut(t) {
            const e = t ? t.url.toString() : void 0;
            return Ft.getEntriesByName(e)
        }
        let Nt, Gt, jt, Vt;
        const Zt = {
            now: ()=>void 0 !== jt ? jt : e.performance.now(),
            setNow(t) {
                jt = t
            },
            restoreNow() {
                jt = void 0
            },
            frame(t) {
                const i = e.requestAnimationFrame(t);
                return {
                    cancel: ()=>e.cancelAnimationFrame(i)
                }
            },
            getImageData(t, i=0) {
                const {width: r, height: n} = t;
                Vt || (Vt = e.document.createElement("canvas"));
                const o = Vt.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!o)
                    throw new Error("failed to create canvas 2d context");
                return (r > Vt.width || n > Vt.height) && (Vt.width = r,
                Vt.height = n),
                o.clearRect(-i, -i, r + 2 * i, n + 2 * i),
                o.drawImage(t, 0, 0, r, n),
                o.getImageData(-i, -i, r + 2 * i, n + 2 * i)
            },
            resolveURL: t=>(Nt || (Nt = e.document.createElement("a")),
            Nt.href = t,
            Nt.href),
            get devicePixelRatio() {
                return e.devicePixelRatio
            },
            get prefersReducedMotion() {
                return !!e.matchMedia && (null == Gt && (Gt = e.matchMedia("(prefers-reduced-motion: reduce)")),
                Gt.matches)
            }
        };
        function Jt(t, e, i) {
            i[t] && -1 !== i[t].indexOf(e) || (i[t] = i[t] || [],
            i[t].push(e))
        }
        function Xt(t, e, i) {
            if (i && i[t]) {
                const r = i[t].indexOf(e);
                -1 !== r && i[t].splice(r, 1)
            }
        }
        class qt {
            constructor(t, e={}) {
                I(this, e),
                this.type = t
            }
        }
        class $t extends qt {
            constructor(t, e={}) {
                super("error", I({
                    error: t
                }, e))
            }
        }
        class Yt {
            on(t, e) {
                return this._listeners = this._listeners || {},
                Jt(t, e, this._listeners),
                this
            }
            off(t, e) {
                return Xt(t, e, this._listeners),
                Xt(t, e, this._oneTimeListeners),
                this
            }
            once(t, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {},
                Jt(t, e, this._oneTimeListeners),
                this) : new Promise((e=>this.once(t, e)))
            }
            fire(t, e) {
                "string" == typeof t && (t = new qt(t,e || {}));
                const i = t.type;
                if (this.listens(i)) {
                    t.target = this;
                    const e = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
                    for (const i of e)
                        i.call(this, t);
                    const r = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : [];
                    for (const e of r)
                        Xt(i, e, this._oneTimeListeners),
                        e.call(this, t);
                    const n = this._eventedParent;
                    n && (I(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData),
                    n.fire(t))
                } else
                    t instanceof $t && console.error(t.error);
                return this
            }
            listens(t) {
                return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t))
            }
            setEventedParent(t, e) {
                return this._eventedParent = t,
                this._eventedParentData = e,
                this
            }
        }
        var Wt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Ht(t, ...e) {
            for (const i of e)
                for (const e in i)
                    t[e] = i[e];
            return t
        }
        function Kt(t) {
            return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t
        }
        function Qt(t) {
            if (Array.isArray(t))
                return t.map(Qt);
            if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
                const e = {};
                for (const i in t)
                    e[i] = Qt(t[i]);
                return e
            }
            return Kt(t)
        }
        class te extends Error {
            constructor(t, e) {
                super(e),
                this.message = e,
                this.key = t
            }
        }
        var ee = te;
        class ie {
            constructor(t, e=[]) {
                this.parent = t,
                this.bindings = {};
                for (const [t,i] of e)
                    this.bindings[t] = i
            }
            concat(t) {
                return new ie(this,t)
            }
            get(t) {
                if (this.bindings[t])
                    return this.bindings[t];
                if (this.parent)
                    return this.parent.get(t);
                throw new Error(`${t} not found in scope.`)
            }
            has(t) {
                return !!this.bindings[t] || !!this.parent && this.parent.has(t)
            }
        }
        var re = ie;
        const ne = {
            kind: "null"
        }
          , oe = {
            kind: "number"
        }
          , se = {
            kind: "string"
        }
          , ae = {
            kind: "boolean"
        }
          , le = {
            kind: "color"
        }
          , ce = {
            kind: "object"
        }
          , ue = {
            kind: "value"
        }
          , he = {
            kind: "collator"
        }
          , de = {
            kind: "formatted"
        }
          , pe = {
            kind: "resolvedImage"
        };
        function me(t, e) {
            return {
                kind: "array",
                itemType: t,
                N: e
            }
        }
        function fe(t) {
            if ("array" === t.kind) {
                const e = fe(t.itemType);
                return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`
            }
            return t.kind
        }
        const _e = [ne, oe, se, ae, le, de, ce, me(ue), pe];
        function ge(t, e) {
            if ("error" === e.kind)
                return null;
            if ("array" === t.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !ge(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N))
                    return null
            } else {
                if (t.kind === e.kind)
                    return null;
                if ("value" === t.kind)
                    for (const t of _e)
                        if (!ge(t, e))
                            return null
            }
            return `Expected ${fe(t)} but found ${fe(e)} instead.`
        }
        function ye(t, e) {
            return e.some((e=>e.kind === t.kind))
        }
        function xe(t, e) {
            return e.some((e=>"null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t))
        }
        var ve, be = {
            transparent: [0, 0, 0, 0],
            aliceblue: [240, 248, 255, 1],
            antiquewhite: [250, 235, 215, 1],
            aqua: [0, 255, 255, 1],
            aquamarine: [127, 255, 212, 1],
            azure: [240, 255, 255, 1],
            beige: [245, 245, 220, 1],
            bisque: [255, 228, 196, 1],
            black: [0, 0, 0, 1],
            blanchedalmond: [255, 235, 205, 1],
            blue: [0, 0, 255, 1],
            blueviolet: [138, 43, 226, 1],
            brown: [165, 42, 42, 1],
            burlywood: [222, 184, 135, 1],
            cadetblue: [95, 158, 160, 1],
            chartreuse: [127, 255, 0, 1],
            chocolate: [210, 105, 30, 1],
            coral: [255, 127, 80, 1],
            cornflowerblue: [100, 149, 237, 1],
            cornsilk: [255, 248, 220, 1],
            crimson: [220, 20, 60, 1],
            cyan: [0, 255, 255, 1],
            darkblue: [0, 0, 139, 1],
            darkcyan: [0, 139, 139, 1],
            darkgoldenrod: [184, 134, 11, 1],
            darkgray: [169, 169, 169, 1],
            darkgreen: [0, 100, 0, 1],
            darkgrey: [169, 169, 169, 1],
            darkkhaki: [189, 183, 107, 1],
            darkmagenta: [139, 0, 139, 1],
            darkolivegreen: [85, 107, 47, 1],
            darkorange: [255, 140, 0, 1],
            darkorchid: [153, 50, 204, 1],
            darkred: [139, 0, 0, 1],
            darksalmon: [233, 150, 122, 1],
            darkseagreen: [143, 188, 143, 1],
            darkslateblue: [72, 61, 139, 1],
            darkslategray: [47, 79, 79, 1],
            darkslategrey: [47, 79, 79, 1],
            darkturquoise: [0, 206, 209, 1],
            darkviolet: [148, 0, 211, 1],
            deeppink: [255, 20, 147, 1],
            deepskyblue: [0, 191, 255, 1],
            dimgray: [105, 105, 105, 1],
            dimgrey: [105, 105, 105, 1],
            dodgerblue: [30, 144, 255, 1],
            firebrick: [178, 34, 34, 1],
            floralwhite: [255, 250, 240, 1],
            forestgreen: [34, 139, 34, 1],
            fuchsia: [255, 0, 255, 1],
            gainsboro: [220, 220, 220, 1],
            ghostwhite: [248, 248, 255, 1],
            gold: [255, 215, 0, 1],
            goldenrod: [218, 165, 32, 1],
            gray: [128, 128, 128, 1],
            green: [0, 128, 0, 1],
            greenyellow: [173, 255, 47, 1],
            grey: [128, 128, 128, 1],
            honeydew: [240, 255, 240, 1],
            hotpink: [255, 105, 180, 1],
            indianred: [205, 92, 92, 1],
            indigo: [75, 0, 130, 1],
            ivory: [255, 255, 240, 1],
            khaki: [240, 230, 140, 1],
            lavender: [230, 230, 250, 1],
            lavenderblush: [255, 240, 245, 1],
            lawngreen: [124, 252, 0, 1],
            lemonchiffon: [255, 250, 205, 1],
            lightblue: [173, 216, 230, 1],
            lightcoral: [240, 128, 128, 1],
            lightcyan: [224, 255, 255, 1],
            lightgoldenrodyellow: [250, 250, 210, 1],
            lightgray: [211, 211, 211, 1],
            lightgreen: [144, 238, 144, 1],
            lightgrey: [211, 211, 211, 1],
            lightpink: [255, 182, 193, 1],
            lightsalmon: [255, 160, 122, 1],
            lightseagreen: [32, 178, 170, 1],
            lightskyblue: [135, 206, 250, 1],
            lightslategray: [119, 136, 153, 1],
            lightslategrey: [119, 136, 153, 1],
            lightsteelblue: [176, 196, 222, 1],
            lightyellow: [255, 255, 224, 1],
            lime: [0, 255, 0, 1],
            limegreen: [50, 205, 50, 1],
            linen: [250, 240, 230, 1],
            magenta: [255, 0, 255, 1],
            maroon: [128, 0, 0, 1],
            mediumaquamarine: [102, 205, 170, 1],
            mediumblue: [0, 0, 205, 1],
            mediumorchid: [186, 85, 211, 1],
            mediumpurple: [147, 112, 219, 1],
            mediumseagreen: [60, 179, 113, 1],
            mediumslateblue: [123, 104, 238, 1],
            mediumspringgreen: [0, 250, 154, 1],
            mediumturquoise: [72, 209, 204, 1],
            mediumvioletred: [199, 21, 133, 1],
            midnightblue: [25, 25, 112, 1],
            mintcream: [245, 255, 250, 1],
            mistyrose: [255, 228, 225, 1],
            moccasin: [255, 228, 181, 1],
            navajowhite: [255, 222, 173, 1],
            navy: [0, 0, 128, 1],
            oldlace: [253, 245, 230, 1],
            olive: [128, 128, 0, 1],
            olivedrab: [107, 142, 35, 1],
            orange: [255, 165, 0, 1],
            orangered: [255, 69, 0, 1],
            orchid: [218, 112, 214, 1],
            palegoldenrod: [238, 232, 170, 1],
            palegreen: [152, 251, 152, 1],
            paleturquoise: [175, 238, 238, 1],
            palevioletred: [219, 112, 147, 1],
            papayawhip: [255, 239, 213, 1],
            peachpuff: [255, 218, 185, 1],
            peru: [205, 133, 63, 1],
            pink: [255, 192, 203, 1],
            plum: [221, 160, 221, 1],
            powderblue: [176, 224, 230, 1],
            purple: [128, 0, 128, 1],
            rebeccapurple: [102, 51, 153, 1],
            red: [255, 0, 0, 1],
            rosybrown: [188, 143, 143, 1],
            royalblue: [65, 105, 225, 1],
            saddlebrown: [139, 69, 19, 1],
            salmon: [250, 128, 114, 1],
            sandybrown: [244, 164, 96, 1],
            seagreen: [46, 139, 87, 1],
            seashell: [255, 245, 238, 1],
            sienna: [160, 82, 45, 1],
            silver: [192, 192, 192, 1],
            skyblue: [135, 206, 235, 1],
            slateblue: [106, 90, 205, 1],
            slategray: [112, 128, 144, 1],
            slategrey: [112, 128, 144, 1],
            snow: [255, 250, 250, 1],
            springgreen: [0, 255, 127, 1],
            steelblue: [70, 130, 180, 1],
            tan: [210, 180, 140, 1],
            teal: [0, 128, 128, 1],
            thistle: [216, 191, 216, 1],
            tomato: [255, 99, 71, 1],
            turquoise: [64, 224, 208, 1],
            violet: [238, 130, 238, 1],
            wheat: [245, 222, 179, 1],
            white: [255, 255, 255, 1],
            whitesmoke: [245, 245, 245, 1],
            yellow: [255, 255, 0, 1],
            yellowgreen: [154, 205, 50, 1]
        };
        function we(t) {
            return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t
        }
        function ze(t) {
            return we("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t))
        }
        function Te(t) {
            var e;
            return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e
        }
        function Ee(t, e, i) {
            return i < 0 ? i += 1 : i > 1 && (i -= 1),
            6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
        }
        try {
            ve = {}.parseCSSColor = function(t) {
                var e, i = t.replace(/ /g, "").toLowerCase();
                if (i in be)
                    return be[i].slice();
                if ("#" === i[0])
                    return 4 === i.length ? (e = parseInt(i.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === i.length && (e = parseInt(i.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
                var r = i.indexOf("(")
                  , n = i.indexOf(")");
                if (-1 !== r && n + 1 === i.length) {
                    var o = i.substr(0, r)
                      , s = i.substr(r + 1, n - (r + 1)).split(",")
                      , a = 1;
                    switch (o) {
                    case "rgba":
                        if (4 !== s.length)
                            return null;
                        a = Te(s.pop());
                    case "rgb":
                        return 3 !== s.length ? null : [ze(s[0]), ze(s[1]), ze(s[2]), a];
                    case "hsla":
                        if (4 !== s.length)
                            return null;
                        a = Te(s.pop());
                    case "hsl":
                        if (3 !== s.length)
                            return null;
                        var l = (parseFloat(s[0]) % 360 + 360) % 360 / 360
                          , c = Te(s[1])
                          , u = Te(s[2])
                          , h = u <= .5 ? u * (c + 1) : u + c - u * c
                          , d = 2 * u - h;
                        return [we(255 * Ee(d, h, l + 1 / 3)), we(255 * Ee(d, h, l)), we(255 * Ee(d, h, l - 1 / 3)), a];
                    default:
                        return null
                    }
                }
                return null
            }
        } catch (t) {}
        class Se {
            constructor(t, e, i, r=1) {
                this.r = t,
                this.g = e,
                this.b = i,
                this.a = r
            }
            static parse(t) {
                if (!t)
                    return;
                if (t instanceof Se)
                    return t;
                if ("string" != typeof t)
                    return;
                const e = ve(t);
                return e ? new Se(e[0] / 255 * e[3],e[1] / 255 * e[3],e[2] / 255 * e[3],e[3]) : void 0
            }
            toString() {
                const [t,e,i,r] = this.toArray();
                return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(i)},${r})`
            }
            toArray() {
                const {r: t, g: e, b: i, a: r} = this;
                return 0 === r ? [0, 0, 0, 0] : [255 * t / r, 255 * e / r, 255 * i / r, r]
            }
            toArray01() {
                const {r: t, g: e, b: i, a: r} = this;
                return 0 === r ? [0, 0, 0, 0] : [t / r, e / r, i / r, r]
            }
            toArray01PremultipliedAlpha() {
                const {r: t, g: e, b: i, a: r} = this;
                return [t, e, i, r]
            }
        }
        Se.black = new Se(0,0,0,1),
        Se.white = new Se(1,1,1,1),
        Se.transparent = new Se(0,0,0,0),
        Se.red = new Se(1,0,0,1),
        Se.blue = new Se(0,0,1,1);
        var Me = Se;
        class Ae {
            constructor(t, e, i) {
                this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base",
                this.locale = i,
                this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                    sensitivity: this.sensitivity,
                    usage: "search"
                })
            }
            compare(t, e) {
                return this.collator.compare(t, e)
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
            }
        }
        class Ie {
            constructor(t, e, i, r, n) {
                this.text = t.normalize ? t.normalize() : t,
                this.image = e,
                this.scale = i,
                this.fontStack = r,
                this.textColor = n
            }
        }
        class Ce {
            constructor(t) {
                this.sections = t
            }
            static fromString(t) {
                return new Ce([new Ie(t,null,null,null,null)])
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t=>0 !== t.text.length || t.image && 0 !== t.image.name.length))
            }
            static factory(t) {
                return t instanceof Ce ? t : Ce.fromString(t)
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t=>t.text)).join("")
            }
            serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                    if (e.image) {
                        t.push(["image", e.image.name]);
                        continue
                    }
                    t.push(e.text);
                    const i = {};
                    e.fontStack && (i["text-font"] = ["literal", e.fontStack.split(",")]),
                    e.scale && (i["font-scale"] = e.scale),
                    e.textColor && (i["text-color"] = ["rgba"].concat(e.textColor.toArray())),
                    t.push(i)
                }
                return t
            }
        }
        class De {
            constructor(t) {
                this.name = t.name,
                this.available = t.available
            }
            toString() {
                return this.name
            }
            static fromString(t) {
                return t ? new De({
                    name: t,
                    available: !1
                }) : null
            }
            serialize() {
                return ["image", this.name]
            }
        }
        function ke(t, e, i, r) {
            return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof i && i >= 0 && i <= 255 ? void 0 === r || "number" == typeof r && r >= 0 && r <= 1 ? null : `Invalid rgba value [${[t, e, i, r].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof r ? [t, e, i, r] : [t, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }
        function Pe(t) {
            if (null === t)
                return !0;
            if ("string" == typeof t)
                return !0;
            if ("boolean" == typeof t)
                return !0;
            if ("number" == typeof t)
                return !0;
            if (t instanceof Me)
                return !0;
            if (t instanceof Ae)
                return !0;
            if (t instanceof Ce)
                return !0;
            if (t instanceof De)
                return !0;
            if (Array.isArray(t)) {
                for (const e of t)
                    if (!Pe(e))
                        return !1;
                return !0
            }
            if ("object" == typeof t) {
                for (const e in t)
                    if (!Pe(t[e]))
                        return !1;
                return !0
            }
            return !1
        }
        function Le(t) {
            if (null === t)
                return ne;
            if ("string" == typeof t)
                return se;
            if ("boolean" == typeof t)
                return ae;
            if ("number" == typeof t)
                return oe;
            if (t instanceof Me)
                return le;
            if (t instanceof Ae)
                return he;
            if (t instanceof Ce)
                return de;
            if (t instanceof De)
                return pe;
            if (Array.isArray(t)) {
                const e = t.length;
                let i;
                for (const e of t) {
                    const t = Le(e);
                    if (i) {
                        if (i === t)
                            continue;
                        i = ue;
                        break
                    }
                    i = t
                }
                return me(i || ue, e)
            }
            return ce
        }
        function Oe(t) {
            const e = typeof t;
            return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof Me || t instanceof Ce || t instanceof De ? t.toString() : JSON.stringify(t)
        }
        class Re {
            constructor(t, e) {
                this.type = t,
                this.value = e
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (!Pe(t[1]))
                    return e.error("invalid value");
                const i = t[1];
                let r = Le(i);
                const n = e.expectedType;
                return "array" !== r.kind || 0 !== r.N || !n || "array" !== n.kind || "number" == typeof n.N && 0 !== n.N || (r = n),
                new Re(r,i)
            }
            evaluate() {
                return this.value
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Ce ? this.value.serialize() : this.value
            }
        }
        var Be = Re
          , Fe = class {
            constructor(t) {
                this.name = "ExpressionEvaluationError",
                this.message = t
            }
            toJSON() {
                return this.message
            }
        }
        ;
        const Ue = {
            string: se,
            number: oe,
            boolean: ae,
            object: ce
        };
        class Ne {
            constructor(t, e) {
                this.type = t,
                this.args = e
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                let i, r = 1;
                const n = t[0];
                if ("array" === n) {
                    let n, o;
                    if (t.length > 2) {
                        const i = t[1];
                        if ("string" != typeof i || !(i in Ue) || "object" === i)
                            return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        n = Ue[i],
                        r++
                    } else
                        n = ue;
                    if (t.length > 3) {
                        if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2])))
                            return e.error('The length argument to "array" must be a positive integer literal', 2);
                        o = t[2],
                        r++
                    }
                    i = me(n, o)
                } else
                    i = Ue[n];
                const o = [];
                for (; r < t.length; r++) {
                    const i = e.parse(t[r], r, ue);
                    if (!i)
                        return null;
                    o.push(i)
                }
                return new Ne(i,o)
            }
            evaluate(t) {
                for (let e = 0; e < this.args.length; e++) {
                    const i = this.args[e].evaluate(t);
                    if (!ge(this.type, Le(i)))
                        return i;
                    if (e === this.args.length - 1)
                        throw new Fe(`Expected value to be of type ${fe(this.type)}, but found ${fe(Le(i))} instead.`)
                }
                return null
            }
            eachChild(t) {
                this.args.forEach(t)
            }
            outputDefined() {
                return this.args.every((t=>t.outputDefined()))
            }
            serialize() {
                const t = this.type
                  , e = [t.kind];
                if ("array" === t.kind) {
                    const i = t.itemType;
                    if ("string" === i.kind || "number" === i.kind || "boolean" === i.kind) {
                        e.push(i.kind);
                        const r = t.N;
                        ("number" == typeof r || this.args.length > 1) && e.push(r)
                    }
                }
                return e.concat(this.args.map((t=>t.serialize())))
            }
        }
        var Ge = Ne;
        class je {
            constructor(t) {
                this.type = de,
                this.sections = t
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                const i = t[1];
                if (!Array.isArray(i) && "object" == typeof i)
                    return e.error("First argument must be an image or text section.");
                const r = [];
                let n = !1;
                for (let i = 1; i <= t.length - 1; ++i) {
                    const o = t[i];
                    if (n && "object" == typeof o && !Array.isArray(o)) {
                        n = !1;
                        let t = null;
                        if (o["font-scale"] && (t = e.parse(o["font-scale"], 1, oe),
                        !t))
                            return null;
                        let i = null;
                        if (o["text-font"] && (i = e.parse(o["text-font"], 1, me(se)),
                        !i))
                            return null;
                        let s = null;
                        if (o["text-color"] && (s = e.parse(o["text-color"], 1, le),
                        !s))
                            return null;
                        const a = r[r.length - 1];
                        a.scale = t,
                        a.font = i,
                        a.textColor = s
                    } else {
                        const o = e.parse(t[i], 1, ue);
                        if (!o)
                            return null;
                        const s = o.type.kind;
                        if ("string" !== s && "value" !== s && "null" !== s && "resolvedImage" !== s)
                            return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        n = !0,
                        r.push({
                            content: o,
                            scale: null,
                            font: null,
                            textColor: null
                        })
                    }
                }
                return new je(r)
            }
            evaluate(t) {
                return new Ce(this.sections.map((e=>{
                    const i = e.content.evaluate(t);
                    return Le(i) === pe ? new Ie("",i,null,null,null) : new Ie(Oe(i),null,e.scale ? e.scale.evaluate(t) : null,e.font ? e.font.evaluate(t).join(",") : null,e.textColor ? e.textColor.evaluate(t) : null)
                }
                )))
            }
            eachChild(t) {
                for (const e of this.sections)
                    t(e.content),
                    e.scale && t(e.scale),
                    e.font && t(e.font),
                    e.textColor && t(e.textColor)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                    t.push(e.content.serialize());
                    const i = {};
                    e.scale && (i["font-scale"] = e.scale.serialize()),
                    e.font && (i["text-font"] = e.font.serialize()),
                    e.textColor && (i["text-color"] = e.textColor.serialize()),
                    t.push(i)
                }
                return t
            }
        }
        class Ve {
            constructor(t) {
                this.type = pe,
                this.input = t
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error("Expected two arguments.");
                const i = e.parse(t[1], 1, se);
                return i ? new Ve(i) : e.error("No image name provided.")
            }
            evaluate(t) {
                const e = this.input.evaluate(t)
                  , i = De.fromString(e);
                return i && t.availableImages && (i.available = t.availableImages.indexOf(e) > -1),
                i
            }
            eachChild(t) {
                t(this.input)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return ["image", this.input.serialize()]
            }
        }
        const Ze = {
            "to-boolean": ae,
            "to-color": le,
            "to-number": oe,
            "to-string": se
        };
        class Je {
            constructor(t, e) {
                this.type = t,
                this.args = e
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                const i = t[0];
                if (("to-boolean" === i || "to-string" === i) && 2 !== t.length)
                    return e.error("Expected one argument.");
                const r = Ze[i]
                  , n = [];
                for (let i = 1; i < t.length; i++) {
                    const r = e.parse(t[i], i, ue);
                    if (!r)
                        return null;
                    n.push(r)
                }
                return new Je(r,n)
            }
            evaluate(t) {
                if ("boolean" === this.type.kind)
                    return Boolean(this.args[0].evaluate(t));
                if ("color" === this.type.kind) {
                    let e, i;
                    for (const r of this.args) {
                        if (e = r.evaluate(t),
                        i = null,
                        e instanceof Me)
                            return e;
                        if ("string" == typeof e) {
                            const i = t.parseColor(e);
                            if (i)
                                return i
                        } else if (Array.isArray(e) && (i = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : ke(e[0], e[1], e[2], e[3]),
                        !i))
                            return new Me(e[0] / 255,e[1] / 255,e[2] / 255,e[3])
                    }
                    throw new Fe(i || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`)
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const i of this.args) {
                        if (e = i.evaluate(t),
                        null === e)
                            return 0;
                        const r = Number(e);
                        if (!isNaN(r))
                            return r
                    }
                    throw new Fe(`Could not convert ${JSON.stringify(e)} to number.`)
                }
                return "formatted" === this.type.kind ? Ce.fromString(Oe(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? De.fromString(Oe(this.args[0].evaluate(t))) : Oe(this.args[0].evaluate(t))
            }
            eachChild(t) {
                this.args.forEach(t)
            }
            outputDefined() {
                return this.args.every((t=>t.outputDefined()))
            }
            serialize() {
                if ("formatted" === this.type.kind)
                    return new je([{
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }]).serialize();
                if ("resolvedImage" === this.type.kind)
                    return new Ve(this.args[0]).serialize();
                const t = [`to-${this.type.kind}`];
                return this.eachChild((e=>{
                    t.push(e.serialize())
                }
                )),
                t
            }
        }
        var Xe = Je;
        const qe = ["Unknown", "Point", "LineString", "Polygon"];
        var $e = class {
            constructor() {
                this.globals = null,
                this.feature = null,
                this.featureState = null,
                this.formattedSection = null,
                this._parseColorCache = {},
                this.availableImages = null,
                this.canonical = null,
                this.featureTileCoord = null,
                this.featureDistanceData = null
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? qe[this.feature.type] : this.feature.type : null
            }
            geometry() {
                return this.feature && "geometry"in this.feature ? this.feature.geometry : null
            }
            canonicalID() {
                return this.canonical
            }
            properties() {
                return this.feature && this.feature.properties || {}
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t = this.featureDistanceData.center
                      , e = this.featureDistanceData.scale
                      , {x: i, y: r} = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (i * e - t[0]) + this.featureDistanceData.bearing[1] * (r * e - t[1])
                }
                return 0
            }
            parseColor(t) {
                let e = this._parseColorCache[t];
                return e || (e = this._parseColorCache[t] = Me.parse(t)),
                e
            }
        }
        ;
        class Ye {
            constructor(t, e, i, r) {
                this.name = t,
                this.type = e,
                this._evaluate = i,
                this.args = r
            }
            evaluate(t) {
                return this._evaluate(t, this.args)
            }
            eachChild(t) {
                this.args.forEach(t)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return [this.name].concat(this.args.map((t=>t.serialize())))
            }
            static parse(t, e) {
                const i = t[0]
                  , r = Ye.definitions[i];
                if (!r)
                    return e.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const n = Array.isArray(r) ? r[0] : r.type
                  , o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads
                  , s = o.filter((([e])=>!Array.isArray(e) || e.length === t.length - 1));
                let a = null;
                for (const [r,o] of s) {
                    a = new wi(e.registry,e.path,null,e.scope);
                    const s = [];
                    let l = !1;
                    for (let e = 1; e < t.length; e++) {
                        const i = t[e]
                          , n = Array.isArray(r) ? r[e - 1] : r.type
                          , o = a.parse(i, 1 + s.length, n);
                        if (!o) {
                            l = !0;
                            break
                        }
                        s.push(o)
                    }
                    if (!l)
                        if (Array.isArray(r) && r.length !== s.length)
                            a.error(`Expected ${r.length} arguments, but found ${s.length} instead.`);
                        else {
                            for (let t = 0; t < s.length; t++) {
                                const e = Array.isArray(r) ? r[t] : r.type
                                  , i = s[t];
                                a.concat(t + 1).checkSubtype(e, i.type)
                            }
                            if (0 === a.errors.length)
                                return new Ye(i,n,o,s)
                        }
                }
                if (1 === s.length)
                    e.errors.push(...a.errors);
                else {
                    const i = (s.length ? s : o).map((([t])=>{
                        var e;
                        return e = t,
                        Array.isArray(e) ? `(${e.map(fe).join(", ")})` : `(${fe(e.type)}...)`
                    }
                    )).join(" | ")
                      , r = [];
                    for (let i = 1; i < t.length; i++) {
                        const n = e.parse(t[i], 1 + r.length);
                        if (!n)
                            return null;
                        r.push(fe(n.type))
                    }
                    e.error(`Expected arguments of type ${i}, but found (${r.join(", ")}) instead.`)
                }
                return null
            }
            static register(t, e) {
                Ye.definitions = e;
                for (const i in e)
                    t[i] = Ye
            }
        }
        var We = Ye;
        class He {
            constructor(t, e, i) {
                this.type = he,
                this.locale = i,
                this.caseSensitive = t,
                this.diacriticSensitive = e
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error("Expected one argument.");
                const i = t[1];
                if ("object" != typeof i || Array.isArray(i))
                    return e.error("Collator options argument must be an object.");
                const r = e.parse(void 0 !== i["case-sensitive"] && i["case-sensitive"], 1, ae);
                if (!r)
                    return null;
                const n = e.parse(void 0 !== i["diacritic-sensitive"] && i["diacritic-sensitive"], 1, ae);
                if (!n)
                    return null;
                let o = null;
                return i.locale && (o = e.parse(i.locale, 1, se),
                !o) ? null : new He(r,n,o)
            }
            evaluate(t) {
                return new Ae(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
            }
            eachChild(t) {
                t(this.caseSensitive),
                t(this.diacriticSensitive),
                this.locale && t(this.locale)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = {};
                return t["case-sensitive"] = this.caseSensitive.serialize(),
                t["diacritic-sensitive"] = this.diacriticSensitive.serialize(),
                this.locale && (t.locale = this.locale.serialize()),
                ["collator", t]
            }
        }
        const Ke = 8192;
        function Qe(t, e) {
            t[0] = Math.min(t[0], e[0]),
            t[1] = Math.min(t[1], e[1]),
            t[2] = Math.max(t[2], e[0]),
            t[3] = Math.max(t[3], e[1])
        }
        function ti(t, e) {
            return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3])
        }
        function ei(t, e) {
            const i = (180 + t[0]) / 360
              , r = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360
              , n = Math.pow(2, e.z);
            return [Math.round(i * n * Ke), Math.round(r * n * Ke)]
        }
        function ii(t, e, i) {
            const r = t[0] - e[0]
              , n = t[1] - e[1]
              , o = t[0] - i[0]
              , s = t[1] - i[1];
            return r * s - o * n == 0 && r * o <= 0 && n * s <= 0
        }
        function ri(t, e) {
            let i = !1;
            for (let s = 0, a = e.length; s < a; s++) {
                const a = e[s];
                for (let e = 0, s = a.length; e < s - 1; e++) {
                    if (ii(t, a[e], a[e + 1]))
                        return !1;
                    (n = a[e])[1] > (r = t)[1] != (o = a[e + 1])[1] > r[1] && r[0] < (o[0] - n[0]) * (r[1] - n[1]) / (o[1] - n[1]) + n[0] && (i = !i)
                }
            }
            var r, n, o;
            return i
        }
        function ni(t, e) {
            for (let i = 0; i < e.length; i++)
                if (ri(t, e[i]))
                    return !0;
            return !1
        }
        function oi(t, e, i, r) {
            const n = r[0] - i[0]
              , o = r[1] - i[1]
              , s = (t[0] - i[0]) * o - n * (t[1] - i[1])
              , a = (e[0] - i[0]) * o - n * (e[1] - i[1]);
            return s > 0 && a < 0 || s < 0 && a > 0
        }
        function si(t, e, i) {
            for (const c of i)
                for (let i = 0; i < c.length - 1; ++i)
                    if (0 != (a = [(s = c[i + 1])[0] - (o = c[i])[0], s[1] - o[1]])[0] * (l = [(n = e)[0] - (r = t)[0], n[1] - r[1]])[1] - a[1] * l[0] && oi(r, n, o, s) && oi(o, s, r, n))
                        return !0;
            var r, n, o, s, a, l;
            return !1
        }
        function ai(t, e) {
            for (let i = 0; i < t.length; ++i)
                if (!ri(t[i], e))
                    return !1;
            for (let i = 0; i < t.length - 1; ++i)
                if (si(t[i], t[i + 1], e))
                    return !1;
            return !0
        }
        function li(t, e) {
            for (let i = 0; i < e.length; i++)
                if (ai(t, e[i]))
                    return !0;
            return !1
        }
        function ci(t, e, i) {
            const r = [];
            for (let n = 0; n < t.length; n++) {
                const o = [];
                for (let r = 0; r < t[n].length; r++) {
                    const s = ei(t[n][r], i);
                    Qe(e, s),
                    o.push(s)
                }
                r.push(o)
            }
            return r
        }
        function ui(t, e, i) {
            const r = [];
            for (let n = 0; n < t.length; n++) {
                const o = ci(t[n], e, i);
                r.push(o)
            }
            return r
        }
        function hi(t, e, i, r) {
            if (t[0] < i[0] || t[0] > i[2]) {
                const e = .5 * r;
                let n = t[0] - i[0] > e ? -r : i[0] - t[0] > e ? r : 0;
                0 === n && (n = t[0] - i[2] > e ? -r : i[2] - t[0] > e ? r : 0),
                t[0] += n
            }
            Qe(e, t)
        }
        function di(t, e, i, r) {
            const n = Math.pow(2, r.z) * Ke
              , o = [r.x * Ke, r.y * Ke]
              , s = [];
            if (!t)
                return s;
            for (const r of t)
                for (const t of r) {
                    const r = [t.x + o[0], t.y + o[1]];
                    hi(r, e, i, n),
                    s.push(r)
                }
            return s
        }
        function pi(t, e, i, r) {
            const n = Math.pow(2, r.z) * Ke
              , o = [r.x * Ke, r.y * Ke]
              , s = [];
            if (!t)
                return s;
            for (const i of t) {
                const t = [];
                for (const r of i) {
                    const i = [r.x + o[0], r.y + o[1]];
                    Qe(e, i),
                    t.push(i)
                }
                s.push(t)
            }
            if (e[2] - e[0] <= n / 2) {
                (a = e)[0] = a[1] = 1 / 0,
                a[2] = a[3] = -1 / 0;
                for (const t of s)
                    for (const r of t)
                        hi(r, e, i, n)
            }
            var a;
            return s
        }
        class mi {
            constructor(t, e) {
                this.type = ae,
                this.geojson = t,
                this.geometries = e
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (Pe(t[1])) {
                    const e = t[1];
                    if ("FeatureCollection" === e.type)
                        for (let t = 0; t < e.features.length; ++t) {
                            const i = e.features[t].geometry.type;
                            if ("Polygon" === i || "MultiPolygon" === i)
                                return new mi(e,e.features[t].geometry)
                        }
                    else if ("Feature" === e.type) {
                        const t = e.geometry.type;
                        if ("Polygon" === t || "MultiPolygon" === t)
                            return new mi(e,e.geometry)
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type)
                        return new mi(e,e)
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")
            }
            evaluate(t) {
                if (null != t.geometry() && null != t.canonicalID()) {
                    if ("Point" === t.geometryType())
                        return function(t, e) {
                            const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = t.canonicalID();
                            if (!n)
                                return !1;
                            if ("Polygon" === e.type) {
                                const o = ci(e.coordinates, r, n)
                                  , s = di(t.geometry(), i, r, n);
                                if (!ti(i, r))
                                    return !1;
                                for (const t of s)
                                    if (!ri(t, o))
                                        return !1
                            }
                            if ("MultiPolygon" === e.type) {
                                const o = ui(e.coordinates, r, n)
                                  , s = di(t.geometry(), i, r, n);
                                if (!ti(i, r))
                                    return !1;
                                for (const t of s)
                                    if (!ni(t, o))
                                        return !1
                            }
                            return !0
                        }(t, this.geometries);
                    if ("LineString" === t.geometryType())
                        return function(t, e) {
                            const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = t.canonicalID();
                            if (!n)
                                return !1;
                            if ("Polygon" === e.type) {
                                const o = ci(e.coordinates, r, n)
                                  , s = pi(t.geometry(), i, r, n);
                                if (!ti(i, r))
                                    return !1;
                                for (const t of s)
                                    if (!ai(t, o))
                                        return !1
                            }
                            if ("MultiPolygon" === e.type) {
                                const o = ui(e.coordinates, r, n)
                                  , s = pi(t.geometry(), i, r, n);
                                if (!ti(i, r))
                                    return !1;
                                for (const t of s)
                                    if (!li(t, o))
                                        return !1
                            }
                            return !0
                        }(t, this.geometries)
                }
                return !1
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
            serialize() {
                return ["within", this.geojson]
            }
        }
        var fi = mi;
        function _i(t) {
            if (t instanceof We) {
                if ("get" === t.name && 1 === t.args.length)
                    return !1;
                if ("feature-state" === t.name)
                    return !1;
                if ("has" === t.name && 1 === t.args.length)
                    return !1;
                if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name)
                    return !1;
                if (/^filter-/.test(t.name))
                    return !1
            }
            if (t instanceof fi)
                return !1;
            let e = !0;
            return t.eachChild((t=>{
                e && !_i(t) && (e = !1)
            }
            )),
            e
        }
        function gi(t) {
            if (t instanceof We && "feature-state" === t.name)
                return !1;
            let e = !0;
            return t.eachChild((t=>{
                e && !gi(t) && (e = !1)
            }
            )),
            e
        }
        function yi(t, e) {
            if (t instanceof We && e.indexOf(t.name) >= 0)
                return !1;
            let i = !0;
            return t.eachChild((t=>{
                i && !yi(t, e) && (i = !1)
            }
            )),
            i
        }
        class xi {
            constructor(t, e) {
                this.type = e.type,
                this.name = t,
                this.boundExpression = e
            }
            static parse(t, e) {
                if (2 !== t.length || "string" != typeof t[1])
                    return e.error("'var' expression requires exactly one string literal argument.");
                const i = t[1];
                return e.scope.has(i) ? new xi(i,e.scope.get(i)) : e.error(`Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`, 1)
            }
            evaluate(t) {
                return this.boundExpression.evaluate(t)
            }
            eachChild() {}
            outputDefined() {
                return !1
            }
            serialize() {
                return ["var", this.name]
            }
        }
        var vi = xi;
        class bi {
            constructor(t, e=[], i, r=new re, n=[]) {
                this.registry = t,
                this.path = e,
                this.key = e.map((t=>`[${t}]`)).join(""),
                this.scope = r,
                this.errors = n,
                this.expectedType = i
            }
            parse(t, e, i, r, n={}) {
                return e ? this.concat(e, i, r)._parse(t, n) : this._parse(t, n)
            }
            _parse(t, e) {
                function i(t, e, i) {
                    return "assert" === i ? new Ge(e,[t]) : "coerce" === i ? new Xe(e,[t]) : t
                }
                if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]),
                Array.isArray(t)) {
                    if (0 === t.length)
                        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const r = t[0];
                    if ("string" != typeof r)
                        return this.error(`Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                        null;
                    const n = this.registry[r];
                    if (n) {
                        let r = n.parse(t, this);
                        if (!r)
                            return null;
                        if (this.expectedType) {
                            const t = this.expectedType
                              , n = r.type;
                            if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== n.kind)
                                if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== n.kind && "string" !== n.kind) {
                                    if (this.checkSubtype(t, n))
                                        return null
                                } else
                                    r = i(r, t, e.typeAnnotation || "coerce");
                            else
                                r = i(r, t, e.typeAnnotation || "assert")
                        }
                        if (!(r instanceof Be) && "resolvedImage" !== r.type.kind && zi(r)) {
                            const t = new $e;
                            try {
                                r = new Be(r.type,r.evaluate(t))
                            } catch (t) {
                                return this.error(t.message),
                                null
                            }
                        }
                        return r
                    }
                    return this.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0)
                }
                return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
            }
            concat(t, e, i) {
                const r = "number" == typeof t ? this.path.concat(t) : this.path
                  , n = i ? this.scope.concat(i) : this.scope;
                return new bi(this.registry,r,e || null,n,this.errors)
            }
            error(t, ...e) {
                const i = `${this.key}${e.map((t=>`[${t}]`)).join("")}`;
                this.errors.push(new ee(i,t))
            }
            checkSubtype(t, e) {
                const i = ge(t, e);
                return i && this.error(i),
                i
            }
        }
        var wi = bi;
        function zi(t) {
            if (t instanceof vi)
                return zi(t.boundExpression);
            if (t instanceof We && "error" === t.name)
                return !1;
            if (t instanceof He)
                return !1;
            if (t instanceof fi)
                return !1;
            const e = t instanceof Xe || t instanceof Ge;
            let i = !0;
            return t.eachChild((t=>{
                i = e ? i && zi(t) : i && t instanceof Be
            }
            )),
            !!i && _i(t) && yi(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"])
        }
        function Ti(t, e) {
            const i = t.length - 1;
            let r, n, o = 0, s = i, a = 0;
            for (; o <= s; )
                if (a = Math.floor((o + s) / 2),
                r = t[a],
                n = t[a + 1],
                r <= e) {
                    if (a === i || e < n)
                        return a;
                    o = a + 1
                } else {
                    if (!(r > e))
                        throw new Fe("Input is not a number.");
                    s = a - 1
                }
            return 0
        }
        class Ei {
            constructor(t, e, i) {
                this.type = t,
                this.input = e,
                this.labels = [],
                this.outputs = [];
                for (const [t,e] of i)
                    this.labels.push(t),
                    this.outputs.push(e)
            }
            static parse(t, e) {
                if (t.length - 1 < 4)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0)
                    return e.error("Expected an even number of arguments.");
                const i = e.parse(t[1], 1, oe);
                if (!i)
                    return null;
                const r = [];
                let n = null;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                for (let i = 1; i < t.length; i += 2) {
                    const o = 1 === i ? -1 / 0 : t[i]
                      , s = t[i + 1]
                      , a = i
                      , l = i + 1;
                    if ("number" != typeof o)
                        return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a);
                    if (r.length && r[r.length - 1][0] >= o)
                        return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a);
                    const c = e.parse(s, l, n);
                    if (!c)
                        return null;
                    n = n || c.type,
                    r.push([o, c])
                }
                return new Ei(n,i,r)
            }
            evaluate(t) {
                const e = this.labels
                  , i = this.outputs;
                if (1 === e.length)
                    return i[0].evaluate(t);
                const r = this.input.evaluate(t);
                if (r <= e[0])
                    return i[0].evaluate(t);
                const n = e.length;
                return r >= e[n - 1] ? i[n - 1].evaluate(t) : i[Ti(e, r)].evaluate(t)
            }
            eachChild(t) {
                t(this.input);
                for (const e of this.outputs)
                    t(e)
            }
            outputDefined() {
                return this.outputs.every((t=>t.outputDefined()))
            }
            serialize() {
                const t = ["step", this.input.serialize()];
                for (let e = 0; e < this.labels.length; e++)
                    e > 0 && t.push(this.labels[e]),
                    t.push(this.outputs[e].serialize());
                return t
            }
        }
        var Si = Ei;
        function Mi(t, e, i) {
            return t * (1 - i) + e * i
        }
        var Ai = Object.freeze({
            __proto__: null,
            number: Mi,
            color: function(t, e, i) {
                return new Me(Mi(t.r, e.r, i),Mi(t.g, e.g, i),Mi(t.b, e.b, i),Mi(t.a, e.a, i))
            },
            array: function(t, e, i) {
                return t.map(((t,r)=>Mi(t, e[r], i)))
            }
        });
        const Ii = .95047
          , Ci = 1.08883
          , Di = 4 / 29
          , ki = 6 / 29
          , Pi = 3 * ki * ki
          , Li = Math.PI / 180
          , Oi = 180 / Math.PI;
        function Ri(t) {
            return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Pi + Di
        }
        function Bi(t) {
            return t > ki ? t * t * t : Pi * (t - Di)
        }
        function Fi(t) {
            return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055)
        }
        function Ui(t) {
            return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
        }
        function Ni(t) {
            const e = Ui(t.r)
              , i = Ui(t.g)
              , r = Ui(t.b)
              , n = Ri((.4124564 * e + .3575761 * i + .1804375 * r) / Ii)
              , o = Ri((.2126729 * e + .7151522 * i + .072175 * r) / 1);
            return {
                l: 116 * o - 16,
                a: 500 * (n - o),
                b: 200 * (o - Ri((.0193339 * e + .119192 * i + .9503041 * r) / Ci)),
                alpha: t.a
            }
        }
        function Gi(t) {
            let e = (t.l + 16) / 116
              , i = isNaN(t.a) ? e : e + t.a / 500
              , r = isNaN(t.b) ? e : e - t.b / 200;
            return e = 1 * Bi(e),
            i = Ii * Bi(i),
            r = Ci * Bi(r),
            new Me(Fi(3.2404542 * i - 1.5371385 * e - .4985314 * r),Fi(-.969266 * i + 1.8760108 * e + .041556 * r),Fi(.0556434 * i - .2040259 * e + 1.0572252 * r),t.alpha)
        }
        function ji(t, e, i) {
            const r = e - t;
            return t + i * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r)
        }
        const Vi = {
            forward: Ni,
            reverse: Gi,
            interpolate: function(t, e, i) {
                return {
                    l: Mi(t.l, e.l, i),
                    a: Mi(t.a, e.a, i),
                    b: Mi(t.b, e.b, i),
                    alpha: Mi(t.alpha, e.alpha, i)
                }
            }
        }
          , Zi = {
            forward: function(t) {
                const {l: e, a: i, b: r} = Ni(t)
                  , n = Math.atan2(r, i) * Oi;
                return {
                    h: n < 0 ? n + 360 : n,
                    c: Math.sqrt(i * i + r * r),
                    l: e,
                    alpha: t.a
                }
            },
            reverse: function(t) {
                const e = t.h * Li
                  , i = t.c;
                return Gi({
                    l: t.l,
                    a: Math.cos(e) * i,
                    b: Math.sin(e) * i,
                    alpha: t.alpha
                })
            },
            interpolate: function(t, e, i) {
                return {
                    h: ji(t.h, e.h, i),
                    c: Mi(t.c, e.c, i),
                    l: Mi(t.l, e.l, i),
                    alpha: Mi(t.alpha, e.alpha, i)
                }
            }
        };
        var Ji = Object.freeze({
            __proto__: null,
            lab: Vi,
            hcl: Zi
        });
        class Xi {
            constructor(t, e, i, r, n) {
                this.type = t,
                this.operator = e,
                this.interpolation = i,
                this.input = r,
                this.labels = [],
                this.outputs = [];
                for (const [t,e] of n)
                    this.labels.push(t),
                    this.outputs.push(e)
            }
            static interpolationFactor(t, e, i, r) {
                let n = 0;
                if ("exponential" === t.name)
                    n = qi(e, t.base, i, r);
                else if ("linear" === t.name)
                    n = qi(e, 1, i, r);
                else if ("cubic-bezier" === t.name) {
                    const o = t.controlPoints;
                    n = new d(o[0],o[1],o[2],o[3]).solve(qi(e, 1, i, r))
                }
                return n
            }
            static parse(t, e) {
                let[i,r,n,...o] = t;
                if (!Array.isArray(r) || 0 === r.length)
                    return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === r[0])
                    r = {
                        name: "linear"
                    };
                else if ("exponential" === r[0]) {
                    const t = r[1];
                    if ("number" != typeof t)
                        return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    r = {
                        name: "exponential",
                        base: t
                    }
                } else {
                    if ("cubic-bezier" !== r[0])
                        return e.error(`Unknown interpolation type ${String(r[0])}`, 1, 0);
                    {
                        const t = r.slice(1);
                        if (4 !== t.length || t.some((t=>"number" != typeof t || t < 0 || t > 1)))
                            return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        r = {
                            name: "cubic-bezier",
                            controlPoints: t
                        }
                    }
                }
                if (t.length - 1 < 4)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0)
                    return e.error("Expected an even number of arguments.");
                if (n = e.parse(n, 2, oe),
                !n)
                    return null;
                const s = [];
                let a = null;
                "interpolate-hcl" === i || "interpolate-lab" === i ? a = le : e.expectedType && "value" !== e.expectedType.kind && (a = e.expectedType);
                for (let t = 0; t < o.length; t += 2) {
                    const i = o[t]
                      , r = o[t + 1]
                      , n = t + 3
                      , l = t + 4;
                    if ("number" != typeof i)
                        return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', n);
                    if (s.length && s[s.length - 1][0] >= i)
                        return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', n);
                    const c = e.parse(r, l, a);
                    if (!c)
                        return null;
                    a = a || c.type,
                    s.push([i, c])
                }
                return "number" === a.kind || "color" === a.kind || "array" === a.kind && "number" === a.itemType.kind && "number" == typeof a.N ? new Xi(a,i,r,n,s) : e.error(`Type ${fe(a)} is not interpolatable.`)
            }
            evaluate(t) {
                const e = this.labels
                  , i = this.outputs;
                if (1 === e.length)
                    return i[0].evaluate(t);
                const r = this.input.evaluate(t);
                if (r <= e[0])
                    return i[0].evaluate(t);
                const n = e.length;
                if (r >= e[n - 1])
                    return i[n - 1].evaluate(t);
                const o = Ti(e, r)
                  , s = Xi.interpolationFactor(this.interpolation, r, e[o], e[o + 1])
                  , a = i[o].evaluate(t)
                  , l = i[o + 1].evaluate(t);
                return "interpolate" === this.operator ? Ai[this.type.kind.toLowerCase()](a, l, s) : "interpolate-hcl" === this.operator ? Zi.reverse(Zi.interpolate(Zi.forward(a), Zi.forward(l), s)) : Vi.reverse(Vi.interpolate(Vi.forward(a), Vi.forward(l), s))
            }
            eachChild(t) {
                t(this.input);
                for (const e of this.outputs)
                    t(e)
            }
            outputDefined() {
                return this.outputs.every((t=>t.outputDefined()))
            }
            serialize() {
                let t;
                t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const e = [this.operator, t, this.input.serialize()];
                for (let t = 0; t < this.labels.length; t++)
                    e.push(this.labels[t], this.outputs[t].serialize());
                return e
            }
        }
        function qi(t, e, i, r) {
            const n = r - i
              , o = t - i;
            return 0 === n ? 0 : 1 === e ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1)
        }
        var $i = Xi;
        class Yi {
            constructor(t, e) {
                this.type = t,
                this.args = e
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expectected at least one argument.");
                let i = null;
                const r = e.expectedType;
                r && "value" !== r.kind && (i = r);
                const n = [];
                for (const r of t.slice(1)) {
                    const t = e.parse(r, 1 + n.length, i, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t)
                        return null;
                    i = i || t.type,
                    n.push(t)
                }
                const o = r && n.some((t=>ge(r, t.type)));
                return new Yi(o ? ue : i,n)
            }
            evaluate(t) {
                let e, i = null, r = 0;
                for (const n of this.args) {
                    if (r++,
                    i = n.evaluate(t),
                    i && i instanceof De && !i.available && (e || (e = i),
                    i = null,
                    r === this.args.length))
                        return e;
                    if (null !== i)
                        break
                }
                return i
            }
            eachChild(t) {
                this.args.forEach(t)
            }
            outputDefined() {
                return this.args.every((t=>t.outputDefined()))
            }
            serialize() {
                const t = ["coalesce"];
                return this.eachChild((e=>{
                    t.push(e.serialize())
                }
                )),
                t
            }
        }
        var Wi = Yi;
        class Hi {
            constructor(t, e) {
                this.type = e.type,
                this.bindings = [].concat(t),
                this.result = e
            }
            evaluate(t) {
                return this.result.evaluate(t)
            }
            eachChild(t) {
                for (const e of this.bindings)
                    t(e[1]);
                t(this.result)
            }
            static parse(t, e) {
                if (t.length < 4)
                    return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                const i = [];
                for (let r = 1; r < t.length - 1; r += 2) {
                    const n = t[r];
                    if ("string" != typeof n)
                        return e.error(`Expected string, but found ${typeof n} instead.`, r);
                    if (/[^a-zA-Z0-9_]/.test(n))
                        return e.error("Variable names must contain only alphanumeric characters or '_'.", r);
                    const o = e.parse(t[r + 1], r + 1);
                    if (!o)
                        return null;
                    i.push([n, o])
                }
                const r = e.parse(t[t.length - 1], t.length - 1, e.expectedType, i);
                return r ? new Hi(i,r) : null
            }
            outputDefined() {
                return this.result.outputDefined()
            }
            serialize() {
                const t = ["let"];
                for (const [e,i] of this.bindings)
                    t.push(e, i.serialize());
                return t.push(this.result.serialize()),
                t
            }
        }
        var Ki = Hi;
        class Qi {
            constructor(t, e, i) {
                this.type = t,
                this.index = e,
                this.input = i
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const i = e.parse(t[1], 1, oe)
                  , r = e.parse(t[2], 2, me(e.expectedType || ue));
                return i && r ? new Qi(r.type.itemType,i,r) : null
            }
            evaluate(t) {
                const e = this.index.evaluate(t)
                  , i = this.input.evaluate(t);
                if (e < 0)
                    throw new Fe(`Array index out of bounds: ${e} < 0.`);
                if (e >= i.length)
                    throw new Fe(`Array index out of bounds: ${e} > ${i.length - 1}.`);
                if (e !== Math.floor(e))
                    throw new Fe(`Array index must be an integer, but found ${e} instead.`);
                return i[e]
            }
            eachChild(t) {
                t(this.index),
                t(this.input)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return ["at", this.index.serialize(), this.input.serialize()]
            }
        }
        var tr = Qi;
        class er {
            constructor(t, e) {
                this.type = ae,
                this.needle = t,
                this.haystack = e
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const i = e.parse(t[1], 1, ue)
                  , r = e.parse(t[2], 2, ue);
                return i && r ? ye(i.type, [ae, se, oe, ne, ue]) ? new er(i,r) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${fe(i.type)} instead`) : null
            }
            evaluate(t) {
                const e = this.needle.evaluate(t)
                  , i = this.haystack.evaluate(t);
                if (null == i)
                    return !1;
                if (!xe(e, ["boolean", "string", "number", "null"]))
                    throw new Fe(`Expected first argument to be of type boolean, string, number or null, but found ${fe(Le(e))} instead.`);
                if (!xe(i, ["string", "array"]))
                    throw new Fe(`Expected second argument to be of type array or string, but found ${fe(Le(i))} instead.`);
                return i.indexOf(e) >= 0
            }
            eachChild(t) {
                t(this.needle),
                t(this.haystack)
            }
            outputDefined() {
                return !0
            }
            serialize() {
                return ["in", this.needle.serialize(), this.haystack.serialize()]
            }
        }
        var ir = er;
        class rr {
            constructor(t, e, i) {
                this.type = oe,
                this.needle = t,
                this.haystack = e,
                this.fromIndex = i
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                    return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const i = e.parse(t[1], 1, ue)
                  , r = e.parse(t[2], 2, ue);
                if (!i || !r)
                    return null;
                if (!ye(i.type, [ae, se, oe, ne, ue]))
                    return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${fe(i.type)} instead`);
                if (4 === t.length) {
                    const n = e.parse(t[3], 3, oe);
                    return n ? new rr(i,r,n) : null
                }
                return new rr(i,r)
            }
            evaluate(t) {
                const e = this.needle.evaluate(t)
                  , i = this.haystack.evaluate(t);
                if (!xe(e, ["boolean", "string", "number", "null"]))
                    throw new Fe(`Expected first argument to be of type boolean, string, number or null, but found ${fe(Le(e))} instead.`);
                if (!xe(i, ["string", "array"]))
                    throw new Fe(`Expected second argument to be of type array or string, but found ${fe(Le(i))} instead.`);
                if (this.fromIndex) {
                    const r = this.fromIndex.evaluate(t);
                    return i.indexOf(e, r)
                }
                return i.indexOf(e)
            }
            eachChild(t) {
                t(this.needle),
                t(this.haystack),
                this.fromIndex && t(this.fromIndex)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t = this.fromIndex.serialize();
                    return ["index-of", this.needle.serialize(), this.haystack.serialize(), t]
                }
                return ["index-of", this.needle.serialize(), this.haystack.serialize()]
            }
        }
        var nr = rr;
        class or {
            constructor(t, e, i, r, n, o) {
                this.inputType = t,
                this.type = e,
                this.input = i,
                this.cases = r,
                this.outputs = n,
                this.otherwise = o
            }
            static parse(t, e) {
                if (t.length < 5)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 1)
                    return e.error("Expected an even number of arguments.");
                let i, r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = {}
                  , o = [];
                for (let s = 2; s < t.length - 1; s += 2) {
                    let a = t[s];
                    const l = t[s + 1];
                    Array.isArray(a) || (a = [a]);
                    const c = e.concat(s);
                    if (0 === a.length)
                        return c.error("Expected at least one branch label.");
                    for (const t of a) {
                        if ("number" != typeof t && "string" != typeof t)
                            return c.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER)
                            return c.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t && Math.floor(t) !== t)
                            return c.error("Numeric branch labels must be integer values.");
                        if (i) {
                            if (c.checkSubtype(i, Le(t)))
                                return null
                        } else
                            i = Le(t);
                        if (void 0 !== n[String(t)])
                            return c.error("Branch labels must be unique.");
                        n[String(t)] = o.length
                    }
                    const u = e.parse(l, s, r);
                    if (!u)
                        return null;
                    r = r || u.type,
                    o.push(u)
                }
                const s = e.parse(t[1], 1, ue);
                if (!s)
                    return null;
                const a = e.parse(t[t.length - 1], t.length - 1, r);
                return a ? "value" !== s.type.kind && e.concat(1).checkSubtype(i, s.type) ? null : new or(i,r,s,n,o,a) : null
            }
            evaluate(t) {
                const e = this.input.evaluate(t);
                return (Le(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t)
            }
            eachChild(t) {
                t(this.input),
                this.outputs.forEach(t),
                t(this.otherwise)
            }
            outputDefined() {
                return this.outputs.every((t=>t.outputDefined())) && this.otherwise.outputDefined()
            }
            serialize() {
                const t = ["match", this.input.serialize()]
                  , e = Object.keys(this.cases).sort()
                  , i = []
                  , r = {};
                for (const t of e) {
                    const e = r[this.cases[t]];
                    void 0 === e ? (r[this.cases[t]] = i.length,
                    i.push([this.cases[t], [t]])) : i[e][1].push(t)
                }
                const n = t=>"number" === this.inputType.kind ? Number(t) : t;
                for (const [e,r] of i)
                    t.push(1 === r.length ? n(r[0]) : r.map(n)),
                    t.push(this.outputs[e].serialize());
                return t.push(this.otherwise.serialize()),
                t
            }
        }
        var sr = or;
        class ar {
            constructor(t, e, i) {
                this.type = t,
                this.branches = e,
                this.otherwise = i
            }
            static parse(t, e) {
                if (t.length < 4)
                    return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 0)
                    return e.error("Expected an odd number of arguments.");
                let i;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                const r = [];
                for (let n = 1; n < t.length - 1; n += 2) {
                    const o = e.parse(t[n], n, ae);
                    if (!o)
                        return null;
                    const s = e.parse(t[n + 1], n + 1, i);
                    if (!s)
                        return null;
                    r.push([o, s]),
                    i = i || s.type
                }
                const n = e.parse(t[t.length - 1], t.length - 1, i);
                return n ? new ar(i,r,n) : null
            }
            evaluate(t) {
                for (const [e,i] of this.branches)
                    if (e.evaluate(t))
                        return i.evaluate(t);
                return this.otherwise.evaluate(t)
            }
            eachChild(t) {
                for (const [e,i] of this.branches)
                    t(e),
                    t(i);
                t(this.otherwise)
            }
            outputDefined() {
                return this.branches.every((([t,e])=>e.outputDefined())) && this.otherwise.outputDefined()
            }
            serialize() {
                const t = ["case"];
                return this.eachChild((e=>{
                    t.push(e.serialize())
                }
                )),
                t
            }
        }
        var lr = ar;
        class cr {
            constructor(t, e, i, r) {
                this.type = t,
                this.input = e,
                this.beginIndex = i,
                this.endIndex = r
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                    return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const i = e.parse(t[1], 1, ue)
                  , r = e.parse(t[2], 2, oe);
                if (!i || !r)
                    return null;
                if (!ye(i.type, [me(ue), se, ue]))
                    return e.error(`Expected first argument to be of type array or string, but found ${fe(i.type)} instead`);
                if (4 === t.length) {
                    const n = e.parse(t[3], 3, oe);
                    return n ? new cr(i.type,i,r,n) : null
                }
                return new cr(i.type,i,r)
            }
            evaluate(t) {
                const e = this.input.evaluate(t)
                  , i = this.beginIndex.evaluate(t);
                if (!xe(e, ["string", "array"]))
                    throw new Fe(`Expected first argument to be of type array or string, but found ${fe(Le(e))} instead.`);
                if (this.endIndex) {
                    const r = this.endIndex.evaluate(t);
                    return e.slice(i, r)
                }
                return e.slice(i)
            }
            eachChild(t) {
                t(this.input),
                t(this.beginIndex),
                this.endIndex && t(this.endIndex)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t = this.endIndex.serialize();
                    return ["slice", this.input.serialize(), this.beginIndex.serialize(), t]
                }
                return ["slice", this.input.serialize(), this.beginIndex.serialize()]
            }
        }
        var ur = cr;
        function hr(t, e) {
            return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind
        }
        function dr(t, e, i, r) {
            return 0 === r.compare(e, i)
        }
        function pr(t, e, i) {
            const r = "==" !== t && "!=" !== t;
            return class n {
                constructor(t, e, i) {
                    this.type = ae,
                    this.lhs = t,
                    this.rhs = e,
                    this.collator = i,
                    this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind
                }
                static parse(t, e) {
                    if (3 !== t.length && 4 !== t.length)
                        return e.error("Expected two or three arguments.");
                    const i = t[0];
                    let o = e.parse(t[1], 1, ue);
                    if (!o)
                        return null;
                    if (!hr(i, o.type))
                        return e.concat(1).error(`"${i}" comparisons are not supported for type '${fe(o.type)}'.`);
                    let s = e.parse(t[2], 2, ue);
                    if (!s)
                        return null;
                    if (!hr(i, s.type))
                        return e.concat(2).error(`"${i}" comparisons are not supported for type '${fe(s.type)}'.`);
                    if (o.type.kind !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind)
                        return e.error(`Cannot compare types '${fe(o.type)}' and '${fe(s.type)}'.`);
                    r && ("value" === o.type.kind && "value" !== s.type.kind ? o = new Ge(s.type,[o]) : "value" !== o.type.kind && "value" === s.type.kind && (s = new Ge(o.type,[s])));
                    let a = null;
                    if (4 === t.length) {
                        if ("string" !== o.type.kind && "string" !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind)
                            return e.error("Cannot use collator to compare non-string types.");
                        if (a = e.parse(t[3], 3, he),
                        !a)
                            return null
                    }
                    return new n(o,s,a)
                }
                evaluate(n) {
                    const o = this.lhs.evaluate(n)
                      , s = this.rhs.evaluate(n);
                    if (r && this.hasUntypedArgument) {
                        const e = Le(o)
                          , i = Le(s);
                        if (e.kind !== i.kind || "string" !== e.kind && "number" !== e.kind)
                            throw new Fe(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${i.kind}) instead.`)
                    }
                    if (this.collator && !r && this.hasUntypedArgument) {
                        const t = Le(o)
                          , i = Le(s);
                        if ("string" !== t.kind || "string" !== i.kind)
                            return e(n, o, s)
                    }
                    return this.collator ? i(n, o, s, this.collator.evaluate(n)) : e(n, o, s)
                }
                eachChild(t) {
                    t(this.lhs),
                    t(this.rhs),
                    this.collator && t(this.collator)
                }
                outputDefined() {
                    return !0
                }
                serialize() {
                    const e = [t];
                    return this.eachChild((t=>{
                        e.push(t.serialize())
                    }
                    )),
                    e
                }
            }
        }
        const mr = pr("==", (function(t, e, i) {
            return e === i
        }
        ), dr)
          , fr = pr("!=", (function(t, e, i) {
            return e !== i
        }
        ), (function(t, e, i, r) {
            return !dr(0, e, i, r)
        }
        ))
          , _r = pr("<", (function(t, e, i) {
            return e < i
        }
        ), (function(t, e, i, r) {
            return r.compare(e, i) < 0
        }
        ))
          , gr = pr(">", (function(t, e, i) {
            return e > i
        }
        ), (function(t, e, i, r) {
            return r.compare(e, i) > 0
        }
        ))
          , yr = pr("<=", (function(t, e, i) {
            return e <= i
        }
        ), (function(t, e, i, r) {
            return r.compare(e, i) <= 0
        }
        ))
          , xr = pr(">=", (function(t, e, i) {
            return e >= i
        }
        ), (function(t, e, i, r) {
            return r.compare(e, i) >= 0
        }
        ));
        class vr {
            constructor(t, e, i, r, n, o) {
                this.type = se,
                this.number = t,
                this.locale = e,
                this.currency = i,
                this.unit = r,
                this.minFractionDigits = n,
                this.maxFractionDigits = o
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error("Expected two arguments.");
                const i = e.parse(t[1], 1, oe);
                if (!i)
                    return null;
                const r = t[2];
                if ("object" != typeof r || Array.isArray(r))
                    return e.error("NumberFormat options argument must be an object.");
                let n = null;
                if (r.locale && (n = e.parse(r.locale, 1, se),
                !n))
                    return null;
                let o = null;
                if (r.currency && (o = e.parse(r.currency, 1, se),
                !o))
                    return null;
                let s = null;
                if (r.unit && (s = e.parse(r.unit, 1, se),
                !s))
                    return null;
                let a = null;
                if (r["min-fraction-digits"] && (a = e.parse(r["min-fraction-digits"], 1, oe),
                !a))
                    return null;
                let l = null;
                return r["max-fraction-digits"] && (l = e.parse(r["max-fraction-digits"], 1, oe),
                !l) ? null : new vr(i,n,o,s,a,l)
            }
            evaluate(t) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t) : void 0,
                    unit: this.unit ? this.unit.evaluate(t) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                }).format(this.number.evaluate(t))
            }
            eachChild(t) {
                t(this.number),
                this.locale && t(this.locale),
                this.currency && t(this.currency),
                this.unit && t(this.unit),
                this.minFractionDigits && t(this.minFractionDigits),
                this.maxFractionDigits && t(this.maxFractionDigits)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = {};
                return this.locale && (t.locale = this.locale.serialize()),
                this.currency && (t.currency = this.currency.serialize()),
                this.unit && (t.unit = this.unit.serialize()),
                this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()),
                this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()),
                ["number-format", this.number.serialize(), t]
            }
        }
        class br {
            constructor(t) {
                this.type = oe,
                this.input = t
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                const i = e.parse(t[1], 1);
                return i ? "array" !== i.type.kind && "string" !== i.type.kind && "value" !== i.type.kind ? e.error(`Expected argument of type string or array, but found ${fe(i.type)} instead.`) : new br(i) : null
            }
            evaluate(t) {
                const e = this.input.evaluate(t);
                if ("string" == typeof e)
                    return e.length;
                if (Array.isArray(e))
                    return e.length;
                throw new Fe(`Expected value to be of type string or array, but found ${fe(Le(e))} instead.`)
            }
            eachChild(t) {
                t(this.input)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = ["length"];
                return this.eachChild((e=>{
                    t.push(e.serialize())
                }
                )),
                t
            }
        }
        const wr = {
            "==": mr,
            "!=": fr,
            ">": gr,
            "<": _r,
            ">=": xr,
            "<=": yr,
            array: Ge,
            at: tr,
            boolean: Ge,
            case: lr,
            coalesce: Wi,
            collator: He,
            format: je,
            image: Ve,
            in: ir,
            "index-of": nr,
            interpolate: $i,
            "interpolate-hcl": $i,
            "interpolate-lab": $i,
            length: br,
            let: Ki,
            literal: Be,
            match: sr,
            number: Ge,
            "number-format": vr,
            object: Ge,
            slice: ur,
            step: Si,
            string: Ge,
            "to-boolean": Xe,
            "to-color": Xe,
            "to-number": Xe,
            "to-string": Xe,
            var: vi,
            within: fi
        };
        function zr(t, [e,i,r,n]) {
            e = e.evaluate(t),
            i = i.evaluate(t),
            r = r.evaluate(t);
            const o = n ? n.evaluate(t) : 1
              , s = ke(e, i, r, o);
            if (s)
                throw new Fe(s);
            return new Me(e / 255 * o,i / 255 * o,r / 255 * o,o)
        }
        function Tr(t, e) {
            return t in e
        }
        function Er(t, e) {
            const i = e[t];
            return void 0 === i ? null : i
        }
        function Sr(t) {
            return {
                type: t
            }
        }
        We.register(wr, {
            error: [{
                kind: "error"
            }, [se], (t,[e])=>{
                throw new Fe(e.evaluate(t))
            }
            ],
            typeof: [se, [ue], (t,[e])=>fe(Le(e.evaluate(t)))],
            "to-rgba": [me(oe, 4), [le], (t,[e])=>e.evaluate(t).toArray()],
            rgb: [le, [oe, oe, oe], zr],
            rgba: [le, [oe, oe, oe, oe], zr],
            has: {
                type: ae,
                overloads: [[[se], (t,[e])=>Tr(e.evaluate(t), t.properties())], [[se, ce], (t,[e,i])=>Tr(e.evaluate(t), i.evaluate(t))]]
            },
            get: {
                type: ue,
                overloads: [[[se], (t,[e])=>Er(e.evaluate(t), t.properties())], [[se, ce], (t,[e,i])=>Er(e.evaluate(t), i.evaluate(t))]]
            },
            "feature-state": [ue, [se], (t,[e])=>Er(e.evaluate(t), t.featureState || {})],
            properties: [ce, [], t=>t.properties()],
            "geometry-type": [se, [], t=>t.geometryType()],
            id: [ue, [], t=>t.id()],
            zoom: [oe, [], t=>t.globals.zoom],
            pitch: [oe, [], t=>t.globals.pitch || 0],
            "distance-from-center": [oe, [], t=>t.distanceFromCenter()],
            "heatmap-density": [oe, [], t=>t.globals.heatmapDensity || 0],
            "line-progress": [oe, [], t=>t.globals.lineProgress || 0],
            "sky-radial-progress": [oe, [], t=>t.globals.skyRadialProgress || 0],
            accumulated: [ue, [], t=>void 0 === t.globals.accumulated ? null : t.globals.accumulated],
            "+": [oe, Sr(oe), (t,e)=>{
                let i = 0;
                for (const r of e)
                    i += r.evaluate(t);
                return i
            }
            ],
            "*": [oe, Sr(oe), (t,e)=>{
                let i = 1;
                for (const r of e)
                    i *= r.evaluate(t);
                return i
            }
            ],
            "-": {
                type: oe,
                overloads: [[[oe, oe], (t,[e,i])=>e.evaluate(t) - i.evaluate(t)], [[oe], (t,[e])=>-e.evaluate(t)]]
            },
            "/": [oe, [oe, oe], (t,[e,i])=>e.evaluate(t) / i.evaluate(t)],
            "%": [oe, [oe, oe], (t,[e,i])=>e.evaluate(t) % i.evaluate(t)],
            ln2: [oe, [], ()=>Math.LN2],
            pi: [oe, [], ()=>Math.PI],
            e: [oe, [], ()=>Math.E],
            "^": [oe, [oe, oe], (t,[e,i])=>Math.pow(e.evaluate(t), i.evaluate(t))],
            sqrt: [oe, [oe], (t,[e])=>Math.sqrt(e.evaluate(t))],
            log10: [oe, [oe], (t,[e])=>Math.log(e.evaluate(t)) / Math.LN10],
            ln: [oe, [oe], (t,[e])=>Math.log(e.evaluate(t))],
            log2: [oe, [oe], (t,[e])=>Math.log(e.evaluate(t)) / Math.LN2],
            sin: [oe, [oe], (t,[e])=>Math.sin(e.evaluate(t))],
            cos: [oe, [oe], (t,[e])=>Math.cos(e.evaluate(t))],
            tan: [oe, [oe], (t,[e])=>Math.tan(e.evaluate(t))],
            asin: [oe, [oe], (t,[e])=>Math.asin(e.evaluate(t))],
            acos: [oe, [oe], (t,[e])=>Math.acos(e.evaluate(t))],
            atan: [oe, [oe], (t,[e])=>Math.atan(e.evaluate(t))],
            min: [oe, Sr(oe), (t,e)=>Math.min(...e.map((e=>e.evaluate(t))))],
            max: [oe, Sr(oe), (t,e)=>Math.max(...e.map((e=>e.evaluate(t))))],
            abs: [oe, [oe], (t,[e])=>Math.abs(e.evaluate(t))],
            round: [oe, [oe], (t,[e])=>{
                const i = e.evaluate(t);
                return i < 0 ? -Math.round(-i) : Math.round(i)
            }
            ],
            floor: [oe, [oe], (t,[e])=>Math.floor(e.evaluate(t))],
            ceil: [oe, [oe], (t,[e])=>Math.ceil(e.evaluate(t))],
            "filter-==": [ae, [se, ue], (t,[e,i])=>t.properties()[e.value] === i.value],
            "filter-id-==": [ae, [ue], (t,[e])=>t.id() === e.value],
            "filter-type-==": [ae, [se], (t,[e])=>t.geometryType() === e.value],
            "filter-<": [ae, [se, ue], (t,[e,i])=>{
                const r = t.properties()[e.value]
                  , n = i.value;
                return typeof r == typeof n && r < n
            }
            ],
            "filter-id-<": [ae, [ue], (t,[e])=>{
                const i = t.id()
                  , r = e.value;
                return typeof i == typeof r && i < r
            }
            ],
            "filter->": [ae, [se, ue], (t,[e,i])=>{
                const r = t.properties()[e.value]
                  , n = i.value;
                return typeof r == typeof n && r > n
            }
            ],
            "filter-id->": [ae, [ue], (t,[e])=>{
                const i = t.id()
                  , r = e.value;
                return typeof i == typeof r && i > r
            }
            ],
            "filter-<=": [ae, [se, ue], (t,[e,i])=>{
                const r = t.properties()[e.value]
                  , n = i.value;
                return typeof r == typeof n && r <= n
            }
            ],
            "filter-id-<=": [ae, [ue], (t,[e])=>{
                const i = t.id()
                  , r = e.value;
                return typeof i == typeof r && i <= r
            }
            ],
            "filter->=": [ae, [se, ue], (t,[e,i])=>{
                const r = t.properties()[e.value]
                  , n = i.value;
                return typeof r == typeof n && r >= n
            }
            ],
            "filter-id->=": [ae, [ue], (t,[e])=>{
                const i = t.id()
                  , r = e.value;
                return typeof i == typeof r && i >= r
            }
            ],
            "filter-has": [ae, [ue], (t,[e])=>e.value in t.properties()],
            "filter-has-id": [ae, [], t=>null !== t.id() && void 0 !== t.id()],
            "filter-type-in": [ae, [me(se)], (t,[e])=>e.value.indexOf(t.geometryType()) >= 0],
            "filter-id-in": [ae, [me(ue)], (t,[e])=>e.value.indexOf(t.id()) >= 0],
            "filter-in-small": [ae, [se, me(ue)], (t,[e,i])=>i.value.indexOf(t.properties()[e.value]) >= 0],
            "filter-in-large": [ae, [se, me(ue)], (t,[e,i])=>function(t, e, i, r) {
                for (; i <= r; ) {
                    const n = i + r >> 1;
                    if (e[n] === t)
                        return !0;
                    e[n] > t ? r = n - 1 : i = n + 1
                }
                return !1
            }(t.properties()[e.value], i.value, 0, i.value.length - 1)],
            all: {
                type: ae,
                overloads: [[[ae, ae], (t,[e,i])=>e.evaluate(t) && i.evaluate(t)], [Sr(ae), (t,e)=>{
                    for (const i of e)
                        if (!i.evaluate(t))
                            return !1;
                    return !0
                }
                ]]
            },
            any: {
                type: ae,
                overloads: [[[ae, ae], (t,[e,i])=>e.evaluate(t) || i.evaluate(t)], [Sr(ae), (t,e)=>{
                    for (const i of e)
                        if (i.evaluate(t))
                            return !0;
                    return !1
                }
                ]]
            },
            "!": [ae, [ae], (t,[e])=>!e.evaluate(t)],
            "is-supported-script": [ae, [se], (t,[e])=>{
                const i = t.globals && t.globals.isSupportedScript;
                return !i || i(e.evaluate(t))
            }
            ],
            upcase: [se, [se], (t,[e])=>e.evaluate(t).toUpperCase()],
            downcase: [se, [se], (t,[e])=>e.evaluate(t).toLowerCase()],
            concat: [se, Sr(ue), (t,e)=>e.map((e=>Oe(e.evaluate(t)))).join("")],
            "resolved-locale": [se, [he], (t,[e])=>e.evaluate(t).resolvedLocale()]
        });
        var Mr = wr;
        function Ar(t) {
            return {
                result: "success",
                value: t
            }
        }
        function Ir(t) {
            return {
                result: "error",
                value: t
            }
        }
        function Cr(t) {
            return "data-driven" === t["property-type"]
        }
        function Dr(t) {
            return !!t.expression && t.expression.parameters.indexOf("zoom") > -1
        }
        function kr(t) {
            return !!t.expression && t.expression.interpolated
        }
        function Pr(t) {
            return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t
        }
        function Lr(t) {
            return "object" == typeof t && null !== t && !Array.isArray(t)
        }
        function Or(t) {
            return t
        }
        function Rr(t, e) {
            const i = "color" === e.type
              , r = t.stops && "object" == typeof t.stops[0][0]
              , n = r || !(r || void 0 !== t.property)
              , o = t.type || (kr(e) ? "exponential" : "interval");
            if (i && ((t = Ht({}, t)).stops && (t.stops = t.stops.map((t=>[t[0], Me.parse(t[1])]))),
            t.default = Me.parse(t.default ? t.default : e.default)),
            t.colorSpace && "rgb" !== t.colorSpace && !Ji[t.colorSpace])
                throw new Error(`Unknown color space: ${t.colorSpace}`);
            let s, a, l;
            if ("exponential" === o)
                s = Nr;
            else if ("interval" === o)
                s = Ur;
            else if ("categorical" === o) {
                s = Fr,
                a = Object.create(null);
                for (const e of t.stops)
                    a[e[0]] = e[1];
                l = typeof t.stops[0][0]
            } else {
                if ("identity" !== o)
                    throw new Error(`Unknown function type "${o}"`);
                s = Gr
            }
            if (r) {
                const i = {}
                  , r = [];
                for (let e = 0; e < t.stops.length; e++) {
                    const n = t.stops[e]
                      , o = n[0].zoom;
                    void 0 === i[o] && (i[o] = {
                        zoom: o,
                        type: t.type,
                        property: t.property,
                        default: t.default,
                        stops: []
                    },
                    r.push(o)),
                    i[o].stops.push([n[0].value, n[1]])
                }
                const n = [];
                for (const t of r)
                    n.push([i[t].zoom, Rr(i[t], e)]);
                const o = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: o,
                    interpolationFactor: $i.interpolationFactor.bind(void 0, o),
                    zoomStops: n.map((t=>t[0])),
                    evaluate: ({zoom: i},r)=>Nr({
                        stops: n,
                        base: t.base
                    }, e, i).evaluate(i, r)
                }
            }
            if (n) {
                const i = "exponential" === o ? {
                    name: "exponential",
                    base: void 0 !== t.base ? t.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: i,
                    interpolationFactor: $i.interpolationFactor.bind(void 0, i),
                    zoomStops: t.stops.map((t=>t[0])),
                    evaluate: ({zoom: i})=>s(t, e, i, a, l)
                }
            }
            return {
                kind: "source",
                evaluate(i, r) {
                    const n = r && r.properties ? r.properties[t.property] : void 0;
                    return void 0 === n ? Br(t.default, e.default) : s(t, e, n, a, l)
                }
            }
        }
        function Br(t, e, i) {
            return void 0 !== t ? t : void 0 !== e ? e : void 0 !== i ? i : void 0
        }
        function Fr(t, e, i, r, n) {
            return Br(typeof i === n ? r[i] : void 0, t.default, e.default)
        }
        function Ur(t, e, i) {
            if ("number" !== Pr(i))
                return Br(t.default, e.default);
            const r = t.stops.length;
            if (1 === r)
                return t.stops[0][1];
            if (i <= t.stops[0][0])
                return t.stops[0][1];
            if (i >= t.stops[r - 1][0])
                return t.stops[r - 1][1];
            const n = Ti(t.stops.map((t=>t[0])), i);
            return t.stops[n][1]
        }
        function Nr(t, e, i) {
            const r = void 0 !== t.base ? t.base : 1;
            if ("number" !== Pr(i))
                return Br(t.default, e.default);
            const n = t.stops.length;
            if (1 === n)
                return t.stops[0][1];
            if (i <= t.stops[0][0])
                return t.stops[0][1];
            if (i >= t.stops[n - 1][0])
                return t.stops[n - 1][1];
            const o = Ti(t.stops.map((t=>t[0])), i)
              , s = function(t, e, i, r) {
                const n = r - i
                  , o = t - i;
                return 0 === n ? 0 : 1 === e ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1)
            }(i, r, t.stops[o][0], t.stops[o + 1][0])
              , a = t.stops[o][1]
              , l = t.stops[o + 1][1];
            let c = Ai[e.type] || Or;
            if (t.colorSpace && "rgb" !== t.colorSpace) {
                const e = Ji[t.colorSpace];
                c = (t,i)=>e.reverse(e.interpolate(e.forward(t), e.forward(i), s))
            }
            return "function" == typeof a.evaluate ? {
                evaluate(...t) {
                    const e = a.evaluate.apply(void 0, t)
                      , i = l.evaluate.apply(void 0, t);
                    if (void 0 !== e && void 0 !== i)
                        return c(e, i, s)
                }
            } : c(a, l, s)
        }
        function Gr(t, e, i) {
            return "color" === e.type ? i = Me.parse(i) : "formatted" === e.type ? i = Ce.fromString(i.toString()) : "resolvedImage" === e.type ? i = De.fromString(i.toString()) : Pr(i) === e.type || "enum" === e.type && e.values[i] || (i = void 0),
            Br(i, t.default, e.default)
        }
        class jr {
            constructor(t, e) {
                var i;
                this.expression = t,
                this._warningHistory = {},
                this._evaluator = new $e,
                this._defaultValue = e ? "color" === (i = e).type && (Lr(i.default) || Array.isArray(i.default)) ? new Me(0,0,0,0) : "color" === i.type ? Me.parse(i.default) || null : void 0 === i.default ? null : i.default : null,
                this._enumValues = e && "enum" === e.type ? e.values : null
            }
            evaluateWithoutErrorHandling(t, e, i, r, n, o, s, a) {
                return this._evaluator.globals = t,
                this._evaluator.feature = e,
                this._evaluator.featureState = i,
                this._evaluator.canonical = r || null,
                this._evaluator.availableImages = n || null,
                this._evaluator.formattedSection = o,
                this._evaluator.featureTileCoord = s || null,
                this._evaluator.featureDistanceData = a || null,
                this.expression.evaluate(this._evaluator)
            }
            evaluate(t, e, i, r, n, o, s, a) {
                this._evaluator.globals = t,
                this._evaluator.feature = e || null,
                this._evaluator.featureState = i || null,
                this._evaluator.canonical = r || null,
                this._evaluator.availableImages = n || null,
                this._evaluator.formattedSection = o || null,
                this._evaluator.featureTileCoord = s || null,
                this._evaluator.featureDistanceData = a || null;
                try {
                    const t = this.expression.evaluate(this._evaluator);
                    if (null == t || "number" == typeof t && t != t)
                        return this._defaultValue;
                    if (this._enumValues && !(t in this._enumValues))
                        throw new Fe(`Expected value to be one of ${Object.keys(this._enumValues).map((t=>JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`);
                    return t
                } catch (t) {
                    return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0,
                    "undefined" != typeof console && console.warn(t.message)),
                    this._defaultValue
                }
            }
        }
        function Vr(t) {
            return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0]in Mr
        }
        function Zr(t, e) {
            const i = new wi(Mr,[],e ? function(t) {
                const e = {
                    color: le,
                    string: se,
                    number: oe,
                    enum: se,
                    boolean: ae,
                    formatted: de,
                    resolvedImage: pe
                };
                return "array" === t.type ? me(e[t.value] || ue, t.length) : e[t.type]
            }(e) : void 0)
              , r = i.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return r ? Ar(new jr(r,e)) : Ir(i.errors)
        }
        class Jr {
            constructor(t, e) {
                this.kind = t,
                this._styleExpression = e,
                this.isStateDependent = "constant" !== t && !gi(e.expression)
            }
            evaluateWithoutErrorHandling(t, e, i, r, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, o)
            }
            evaluate(t, e, i, r, n, o) {
                return this._styleExpression.evaluate(t, e, i, r, n, o)
            }
        }
        class Xr {
            constructor(t, e, i, r) {
                this.kind = t,
                this.zoomStops = i,
                this._styleExpression = e,
                this.isStateDependent = "camera" !== t && !gi(e.expression),
                this.interpolationType = r
            }
            evaluateWithoutErrorHandling(t, e, i, r, n, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, o)
            }
            evaluate(t, e, i, r, n, o) {
                return this._styleExpression.evaluate(t, e, i, r, n, o)
            }
            interpolationFactor(t, e, i) {
                return this.interpolationType ? $i.interpolationFactor(this.interpolationType, t, e, i) : 0
            }
        }
        function qr(t, e) {
            if ("error" === (t = Zr(t, e)).result)
                return t;
            const i = t.value.expression
              , r = _i(i);
            if (!r && !Cr(e))
                return Ir([new ee("","data expressions not supported")]);
            const n = yi(i, ["zoom", "pitch", "distance-from-center"]);
            if (!n && !Dr(e))
                return Ir([new ee("","zoom expressions not supported")]);
            const o = Yr(i);
            return o || n ? o instanceof ee ? Ir([o]) : o instanceof $i && !kr(e) ? Ir([new ee("",'"interpolate" expressions cannot be used with this property')]) : Ar(o ? new Xr(r ? "camera" : "composite",t.value,o.labels,o instanceof $i ? o.interpolation : void 0) : new Jr(r ? "constant" : "source",t.value)) : Ir([new ee("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class $r {
            constructor(t, e) {
                this._parameters = t,
                this._specification = e,
                Ht(this, Rr(this._parameters, this._specification))
            }
            static deserialize(t) {
                return new $r(t._parameters,t._specification)
            }
            static serialize(t) {
                return {
                    _parameters: t._parameters,
                    _specification: t._specification
                }
            }
        }
        function Yr(t) {
            let e = null;
            if (t instanceof Ki)
                e = Yr(t.result);
            else if (t instanceof Wi) {
                for (const i of t.args)
                    if (e = Yr(i),
                    e)
                        break
            } else
                (t instanceof Si || t instanceof $i) && t.input instanceof We && "zoom" === t.input.name && (e = t);
            return e instanceof ee || t.eachChild((t=>{
                const i = Yr(t);
                i instanceof ee ? e = i : !e && i ? e = new ee("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && i && e !== i && (e = new ee("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
            }
            )),
            e
        }
        class Wr {
            constructor(t, e, i, r) {
                this.message = (t ? `${t}: ` : "") + i,
                r && (this.identifier = r),
                null != e && e.__line__ && (this.line = e.__line__)
            }
        }
        function Hr(t) {
            const e = t.key
              , i = t.value
              , r = t.valueSpec || {}
              , n = t.objectElementValidators || {}
              , o = t.style
              , s = t.styleSpec;
            let a = [];
            const l = Pr(i);
            if ("object" !== l)
                return [new Wr(e,i,`object expected, ${l} found`)];
            for (const t in i) {
                const l = t.split(".")[0]
                  , c = r[l] || r["*"];
                let u;
                n[l] ? u = n[l] : r[l] ? u = kn : n["*"] ? u = n["*"] : r["*"] && (u = kn),
                u ? a = a.concat(u({
                    key: (e ? `${e}.` : e) + t,
                    value: i[t],
                    valueSpec: c,
                    style: o,
                    styleSpec: s,
                    object: i,
                    objectKey: t
                }, i)) : a.push(new Wr(e,i[t],`unknown property "${t}"`))
            }
            for (const t in r)
                n[t] || r[t].required && void 0 === r[t].default && void 0 === i[t] && a.push(new Wr(e,i,`missing required property "${t}"`));
            return a
        }
        function Kr(t) {
            const e = t.value
              , i = t.valueSpec
              , r = t.style
              , n = t.styleSpec
              , o = t.key
              , s = t.arrayElementValidator || kn;
            if ("array" !== Pr(e))
                return [new Wr(o,e,`array expected, ${Pr(e)} found`)];
            if (i.length && e.length !== i.length)
                return [new Wr(o,e,`array length ${i.length} expected, length ${e.length} found`)];
            if (i["min-length"] && e.length < i["min-length"])
                return [new Wr(o,e,`array length at least ${i["min-length"]} expected, length ${e.length} found`)];
            let a = {
                type: i.value,
                values: i.values,
                minimum: i.minimum,
                maximum: i.maximum,
                function: void 0
            };
            n.$version < 7 && (a.function = i.function),
            "object" === Pr(i.value) && (a = i.value);
            let l = [];
            for (let t = 0; t < e.length; t++)
                l = l.concat(s({
                    array: e,
                    arrayIndex: t,
                    value: e[t],
                    valueSpec: a,
                    style: r,
                    styleSpec: n,
                    key: `${o}[${t}]`
                }));
            return l
        }
        function Qr(t) {
            const e = t.key
              , i = t.value
              , r = t.valueSpec;
            let n = Pr(i);
            if ("number" === n && i != i && (n = "NaN"),
            "number" !== n)
                return [new Wr(e,i,`number expected, ${n} found`)];
            if ("minimum"in r) {
                let n = r.minimum;
                if ("array" === Pr(r.minimum) && (n = r.minimum[t.arrayIndex]),
                i < n)
                    return [new Wr(e,i,`${i} is less than the minimum value ${n}`)]
            }
            if ("maximum"in r) {
                let n = r.maximum;
                if ("array" === Pr(r.maximum) && (n = r.maximum[t.arrayIndex]),
                i > n)
                    return [new Wr(e,i,`${i} is greater than the maximum value ${n}`)]
            }
            return []
        }
        function tn(t) {
            const e = t.valueSpec
              , i = Kt(t.value.type);
            let r, n, o, s = {};
            const a = "categorical" !== i && void 0 === t.value.property
              , l = !a
              , c = "array" === Pr(t.value.stops) && "array" === Pr(t.value.stops[0]) && "object" === Pr(t.value.stops[0][0])
              , u = Hr({
                key: t.key,
                value: t.value,
                valueSpec: t.styleSpec.function,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: {
                    stops: function(t) {
                        if ("identity" === i)
                            return [new Wr(t.key,t.value,'identity function may not have a "stops" property')];
                        let e = [];
                        const r = t.value;
                        return e = e.concat(Kr({
                            key: t.key,
                            value: r,
                            valueSpec: t.valueSpec,
                            style: t.style,
                            styleSpec: t.styleSpec,
                            arrayElementValidator: h
                        })),
                        "array" === Pr(r) && 0 === r.length && e.push(new Wr(t.key,r,"array must have at least one stop")),
                        e
                    },
                    default: function(t) {
                        return kn({
                            key: t.key,
                            value: t.value,
                            valueSpec: e,
                            style: t.style,
                            styleSpec: t.styleSpec
                        })
                    }
                }
            });
            function h(t) {
                let i = [];
                const r = t.value
                  , a = t.key;
                if ("array" !== Pr(r))
                    return [new Wr(a,r,`array expected, ${Pr(r)} found`)];
                if (2 !== r.length)
                    return [new Wr(a,r,`array length 2 expected, length ${r.length} found`)];
                if (c) {
                    if ("object" !== Pr(r[0]))
                        return [new Wr(a,r,`object expected, ${Pr(r[0])} found`)];
                    if (void 0 === r[0].zoom)
                        return [new Wr(a,r,"object stop key must have zoom")];
                    if (void 0 === r[0].value)
                        return [new Wr(a,r,"object stop key must have value")];
                    const e = Kt(r[0].zoom);
                    if ("number" != typeof e)
                        return [new Wr(a,r[0].zoom,"stop zoom values must be numbers")];
                    if (o && o > e)
                        return [new Wr(a,r[0].zoom,"stop zoom values must appear in ascending order")];
                    e !== o && (o = e,
                    n = void 0,
                    s = {}),
                    i = i.concat(Hr({
                        key: `${a}[0]`,
                        value: r[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            zoom: Qr,
                            value: d
                        }
                    }))
                } else
                    i = i.concat(d({
                        key: `${a}[0]`,
                        value: r[0],
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec
                    }, r));
                return Vr(Qt(r[1])) ? i.concat([new Wr(`${a}[1]`,r[1],"expressions are not allowed in function stops.")]) : i.concat(kn({
                    key: `${a}[1]`,
                    value: r[1],
                    valueSpec: e,
                    style: t.style,
                    styleSpec: t.styleSpec
                }))
            }
            function d(t, o) {
                const a = Pr(t.value)
                  , l = Kt(t.value)
                  , c = null !== t.value ? t.value : o;
                if (r) {
                    if (a !== r)
                        return [new Wr(t.key,c,`${a} stop domain type must match previous stop domain type ${r}`)]
                } else
                    r = a;
                if ("number" !== a && "string" !== a && "boolean" !== a && "number" != typeof l && "string" != typeof l && "boolean" != typeof l)
                    return [new Wr(t.key,c,"stop domain value must be a number, string, or boolean")];
                if ("number" !== a && "categorical" !== i) {
                    let r = `number expected, ${a} found`;
                    return Cr(e) && void 0 === i && (r += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new Wr(t.key,c,r)]
                }
                return "categorical" !== i || "number" !== a || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== i && "number" === a && "number" == typeof l && "number" == typeof n && void 0 !== n && l < n ? [new Wr(t.key,c,"stop domain values must appear in ascending order")] : (n = l,
                "categorical" === i && l in s ? [new Wr(t.key,c,"stop domain values must be unique")] : (s[l] = !0,
                [])) : [new Wr(t.key,c,`integer expected, found ${String(l)}`)]
            }
            return "identity" === i && a && u.push(new Wr(t.key,t.value,'missing required property "property"')),
            "identity" === i || t.value.stops || u.push(new Wr(t.key,t.value,'missing required property "stops"')),
            "exponential" === i && t.valueSpec.expression && !kr(t.valueSpec) && u.push(new Wr(t.key,t.value,"exponential functions not supported")),
            t.styleSpec.$version >= 8 && (l && !Cr(t.valueSpec) ? u.push(new Wr(t.key,t.value,"property functions not supported")) : a && !Dr(t.valueSpec) && u.push(new Wr(t.key,t.value,"zoom functions not supported"))),
            "categorical" !== i && !c || void 0 !== t.value.property || u.push(new Wr(t.key,t.value,'"property" property is required')),
            u
        }
        function en(t) {
            const e = ("property" === t.expressionContext ? qr : Zr)(Qt(t.value), t.valueSpec);
            if ("error" === e.result)
                return e.value.map((e=>new Wr(`${t.key}${e.key}`,t.value,e.message)));
            const i = e.value.expression || e.value._styleExpression.expression;
            if ("property" === t.expressionContext && "text-font" === t.propertyKey && !i.outputDefined())
                return [new Wr(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t.expressionContext && "layout" === t.propertyType && !gi(i))
                return [new Wr(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t.expressionContext)
                return rn(i, t);
            if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
                if (!yi(i, ["zoom", "feature-state"]))
                    return [new Wr(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                if ("cluster-initial" === t.expressionContext && !_i(i))
                    return [new Wr(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
            }
            return []
        }
        function rn(t, e) {
            const i = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
            if (e.valueSpec && e.valueSpec.expression)
                for (const t of e.valueSpec.expression.parameters)
                    i.delete(t);
            if (0 === i.size)
                return [];
            const r = [];
            return t instanceof We && i.has(t.name) ? [new Wr(e.key,e.value,`["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild((t=>{
                r.push(...rn(t, e))
            }
            )),
            r)
        }
        function nn(t) {
            const e = t.key
              , i = t.value
              , r = t.valueSpec
              , n = [];
            return Array.isArray(r.values) ? -1 === r.values.indexOf(Kt(i)) && n.push(new Wr(e,i,`expected one of [${r.values.join(", ")}], ${JSON.stringify(i)} found`)) : -1 === Object.keys(r.values).indexOf(Kt(i)) && n.push(new Wr(e,i,`expected one of [${Object.keys(r.values).join(", ")}], ${JSON.stringify(i)} found`)),
            n
        }
        function on(t) {
            if (!0 === t || !1 === t)
                return !0;
            if (!Array.isArray(t) || 0 === t.length)
                return !1;
            switch (t[0]) {
            case "has":
                return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
            case "in":
                return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));
            case "!in":
            case "!has":
            case "none":
                return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
                return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
            case "any":
            case "all":
                for (const e of t.slice(1))
                    if (!on(e) && "boolean" != typeof e)
                        return !1;
                return !0;
            default:
                return !0
            }
        }
        function sn(t, e="fill") {
            if (null == t)
                return {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                };
            on(t) || (t = pn(t));
            const i = t;
            let r = !0;
            try {
                r = function(t) {
                    if (!cn(t))
                        return t;
                    let e = Qt(t);
                    return ln(e),
                    e = an(e),
                    e
                }(i)
            } catch (t) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i, null, 2)}\n        `)
            }
            const n = Wt[`filter_${e}`]
              , o = Zr(r, n);
            let s = null;
            if ("error" === o.result)
                throw new Error(o.value.map((t=>`${t.key}: ${t.message}`)).join(", "));
            s = (t,e,i)=>o.value.evaluate(t, e, {}, i);
            let a = null
              , l = null;
            if (r !== i) {
                const t = Zr(i, n);
                if ("error" === t.result)
                    throw new Error(t.value.map((t=>`${t.key}: ${t.message}`)).join(", "));
                a = (e,i,r,n,o)=>t.value.evaluate(e, i, {}, r, void 0, void 0, n, o),
                l = !_i(t.value.expression)
            }
            return {
                filter: s,
                dynamicFilter: a || void 0,
                needGeometry: dn(r),
                needFeature: !!l
            }
        }
        function an(t) {
            if (!Array.isArray(t))
                return t;
            const e = function(t) {
                if (un.has(t[0]))
                    for (let e = 1; e < t.length; e++)
                        if (cn(t[e]))
                            return !0;
                return t
            }(t);
            return !0 === e ? e : e.map((t=>an(t)))
        }
        function ln(t) {
            let e = !1;
            const i = [];
            if ("case" === t[0]) {
                for (let r = 1; r < t.length - 1; r += 2)
                    e = e || cn(t[r]),
                    i.push(t[r + 1]);
                i.push(t[t.length - 1])
            } else if ("match" === t[0]) {
                e = e || cn(t[1]);
                for (let e = 2; e < t.length - 1; e += 2)
                    i.push(t[e + 1]);
                i.push(t[t.length - 1])
            } else if ("step" === t[0]) {
                e = e || cn(t[1]);
                for (let e = 1; e < t.length - 1; e += 2)
                    i.push(t[e + 1])
            }
            e && (t.length = 0,
            t.push("any", ...i));
            for (let e = 1; e < t.length; e++)
                ln(t[e])
        }
        function cn(t) {
            if (!Array.isArray(t))
                return !1;
            if ("pitch" === (e = t[0]) || "distance-from-center" === e)
                return !0;
            var e;
            for (let e = 1; e < t.length; e++)
                if (cn(t[e]))
                    return !0;
            return !1
        }
        const un = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function hn(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function dn(t) {
            if (!Array.isArray(t))
                return !1;
            if ("within" === t[0])
                return !0;
            for (let e = 1; e < t.length; e++)
                if (dn(t[e]))
                    return !0;
            return !1
        }
        function pn(t) {
            if (!t)
                return !0;
            const e = t[0];
            var i;
            return t.length <= 1 ? "any" !== e : "==" === e ? mn(t[1], t[2], "==") : "!=" === e ? gn(mn(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? mn(t[1], t[2], e) : "any" === e ? (i = t.slice(1),
            ["any"].concat(i.map(pn))) : "all" === e ? ["all"].concat(t.slice(1).map(pn)) : "none" === e ? ["all"].concat(t.slice(1).map(pn).map(gn)) : "in" === e ? fn(t[1], t.slice(2)) : "!in" === e ? gn(fn(t[1], t.slice(2))) : "has" === e ? _n(t[1]) : "!has" === e ? gn(_n(t[1])) : "within" !== e || t
        }
        function mn(t, e, i) {
            switch (t) {
            case "$type":
                return [`filter-type-${i}`, e];
            case "$id":
                return [`filter-id-${i}`, e];
            default:
                return [`filter-${i}`, t, e]
            }
        }
        function fn(t, e) {
            if (0 === e.length)
                return !1;
            switch (t) {
            case "$type":
                return ["filter-type-in", ["literal", e]];
            case "$id":
                return ["filter-id-in", ["literal", e]];
            default:
                return e.length > 200 && !e.some((t=>typeof t != typeof e[0])) ? ["filter-in-large", t, ["literal", e.sort(hn)]] : ["filter-in-small", t, ["literal", e]]
            }
        }
        function _n(t) {
            switch (t) {
            case "$type":
                return !0;
            case "$id":
                return ["filter-has-id"];
            default:
                return ["filter-has", t]
            }
        }
        function gn(t) {
            return ["!", t]
        }
        function yn(t) {
            return on(Qt(t.value)) ? en(Ht({}, t, {
                expressionContext: "filter",
                valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`]
            })) : xn(t)
        }
        function xn(t) {
            const e = t.value
              , i = t.key;
            if ("array" !== Pr(e))
                return [new Wr(i,e,`array expected, ${Pr(e)} found`)];
            const r = t.styleSpec;
            let n, o = [];
            if (e.length < 1)
                return [new Wr(i,e,"filter array must have at least 1 element")];
            switch (o = o.concat(nn({
                key: `${i}[0]`,
                value: e[0],
                valueSpec: r.filter_operator,
                style: t.style,
                styleSpec: t.styleSpec
            })),
            Kt(e[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
                e.length >= 2 && "$type" === Kt(e[1]) && o.push(new Wr(i,e,`"$type" cannot be use with operator "${e[0]}"`));
            case "==":
            case "!=":
                3 !== e.length && o.push(new Wr(i,e,`filter array for operator "${e[0]}" must have 3 elements`));
            case "in":
            case "!in":
                e.length >= 2 && (n = Pr(e[1]),
                "string" !== n && o.push(new Wr(`${i}[1]`,e[1],`string expected, ${n} found`)));
                for (let s = 2; s < e.length; s++)
                    n = Pr(e[s]),
                    "$type" === Kt(e[1]) ? o = o.concat(nn({
                        key: `${i}[${s}]`,
                        value: e[s],
                        valueSpec: r.geometry_type,
                        style: t.style,
                        styleSpec: t.styleSpec
                    })) : "string" !== n && "number" !== n && "boolean" !== n && o.push(new Wr(`${i}[${s}]`,e[s],`string, number, or boolean expected, ${n} found`));
                break;
            case "any":
            case "all":
            case "none":
                for (let r = 1; r < e.length; r++)
                    o = o.concat(xn({
                        key: `${i}[${r}]`,
                        value: e[r],
                        style: t.style,
                        styleSpec: t.styleSpec
                    }));
                break;
            case "has":
            case "!has":
                n = Pr(e[1]),
                2 !== e.length ? o.push(new Wr(i,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== n && o.push(new Wr(`${i}[1]`,e[1],`string expected, ${n} found`));
                break;
            case "within":
                n = Pr(e[1]),
                2 !== e.length ? o.push(new Wr(i,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== n && o.push(new Wr(`${i}[1]`,e[1],`object expected, ${n} found`))
            }
            return o
        }
        function vn(t, e) {
            const i = t.key
              , r = t.style
              , n = t.styleSpec
              , o = t.value
              , s = t.objectKey
              , a = n[`${e}_${t.layerType}`];
            if (!a)
                return [];
            const l = s.match(/^(.*)-transition$/);
            if ("paint" === e && l && a[l[1]] && a[l[1]].transition)
                return kn({
                    key: i,
                    value: o,
                    valueSpec: n.transition,
                    style: r,
                    styleSpec: n
                });
            const c = t.valueSpec || a[s];
            if (!c)
                return [new Wr(i,o,`unknown property "${s}"`)];
            let u;
            if ("string" === Pr(o) && Cr(c) && !c.tokens && (u = /^{([^}]+)}$/.exec(o)))
                return [new Wr(i,o,`"${s}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u[1])} }\`.`)];
            const h = [];
            return "symbol" === t.layerType && ("text-field" === s && r && !r.glyphs && h.push(new Wr(i,o,'use of "text-field" requires a style "glyphs" property')),
            "text-font" === s && Lr(Qt(o)) && "identity" === Kt(o.type) && h.push(new Wr(i,o,'"text-font" does not support identity functions'))),
            h.concat(kn({
                key: t.key,
                value: o,
                valueSpec: c,
                style: r,
                styleSpec: n,
                expressionContext: "property",
                propertyType: e,
                propertyKey: s
            }))
        }
        function bn(t) {
            return vn(t, "paint")
        }
        function wn(t) {
            return vn(t, "layout")
        }
        function zn(t) {
            let e = [];
            const i = t.value
              , r = t.key
              , n = t.style
              , o = t.styleSpec;
            i.type || i.ref || e.push(new Wr(r,i,'either "type" or "ref" is required'));
            let s = Kt(i.type);
            const a = Kt(i.ref);
            if (i.id) {
                const o = Kt(i.id);
                for (let s = 0; s < t.arrayIndex; s++) {
                    const t = n.layers[s];
                    Kt(t.id) === o && e.push(new Wr(r,i.id,`duplicate layer id "${i.id}", previously used at line ${t.id.__line__}`))
                }
            }
            if ("ref"in i) {
                let t;
                ["type", "source", "source-layer", "filter", "layout"].forEach((t=>{
                    t in i && e.push(new Wr(r,i[t],`"${t}" is prohibited for ref layers`))
                }
                )),
                n.layers.forEach((e=>{
                    Kt(e.id) === a && (t = e)
                }
                )),
                t ? t.ref ? e.push(new Wr(r,i.ref,"ref cannot reference another ref layer")) : s = Kt(t.type) : "string" == typeof a && e.push(new Wr(r,i.ref,`ref layer "${a}" not found`))
            } else if ("background" !== s && "sky" !== s)
                if (i.source) {
                    const t = n.sources && n.sources[i.source]
                      , o = t && Kt(t.type);
                    t ? "vector" === o && "raster" === s ? e.push(new Wr(r,i.source,`layer "${i.id}" requires a raster source`)) : "raster" === o && "raster" !== s ? e.push(new Wr(r,i.source,`layer "${i.id}" requires a vector source`)) : "vector" !== o || i["source-layer"] ? "raster-dem" === o && "hillshade" !== s ? e.push(new Wr(r,i.source,"raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !i.paint || !i.paint["line-gradient"] && !i.paint["line-trim-offset"] || "geojson" === o && t.lineMetrics || e.push(new Wr(r,i,`layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new Wr(r,i,`layer "${i.id}" must specify a "source-layer"`)) : e.push(new Wr(r,i.source,`source "${i.source}" not found`))
                } else
                    e.push(new Wr(r,i,'missing required property "source"'));
            return e = e.concat(Hr({
                key: r,
                value: i,
                valueSpec: o.layer,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>kn({
                        key: `${r}.type`,
                        value: i.type,
                        valueSpec: o.layer.type,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        object: i,
                        objectKey: "type"
                    }),
                    filter: t=>yn(Ht({
                        layerType: s
                    }, t)),
                    layout: t=>Hr({
                        layer: i,
                        key: t.key,
                        value: t.value,
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            "*": t=>wn(Ht({
                                layerType: s
                            }, t))
                        }
                    }),
                    paint: t=>Hr({
                        layer: i,
                        key: t.key,
                        value: t.value,
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            "*": t=>bn(Ht({
                                layerType: s
                            }, t))
                        }
                    })
                }
            })),
            e
        }
        function Tn(t) {
            const e = t.value
              , i = t.key
              , r = Pr(e);
            return "string" !== r ? [new Wr(i,e,`string expected, ${r} found`)] : []
        }
        const En = {
            promoteId: function({key: t, value: e}) {
                if ("string" === Pr(e))
                    return Tn({
                        key: t,
                        value: e
                    });
                {
                    const i = [];
                    for (const r in e)
                        i.push(...Tn({
                            key: `${t}.${r}`,
                            value: e[r]
                        }));
                    return i
                }
            }
        };
        function Sn(t) {
            const e = t.value
              , i = t.key
              , r = t.styleSpec
              , n = t.style;
            if (!e.type)
                return [new Wr(i,e,'"type" is required')];
            const o = Kt(e.type);
            let s;
            switch (o) {
            case "vector":
            case "raster":
            case "raster-dem":
                return s = Hr({
                    key: i,
                    value: e,
                    valueSpec: r[`source_${o.replace("-", "_")}`],
                    style: t.style,
                    styleSpec: r,
                    objectElementValidators: En
                }),
                s;
            case "geojson":
                if (s = Hr({
                    key: i,
                    value: e,
                    valueSpec: r.source_geojson,
                    style: n,
                    styleSpec: r,
                    objectElementValidators: En
                }),
                e.cluster)
                    for (const t in e.clusterProperties) {
                        const [r,n] = e.clusterProperties[t]
                          , o = "string" == typeof r ? [r, ["accumulated"], ["get", t]] : r;
                        s.push(...en({
                            key: `${i}.${t}.map`,
                            value: n,
                            expressionContext: "cluster-map"
                        })),
                        s.push(...en({
                            key: `${i}.${t}.reduce`,
                            value: o,
                            expressionContext: "cluster-reduce"
                        }))
                    }
                return s;
            case "video":
                return Hr({
                    key: i,
                    value: e,
                    valueSpec: r.source_video,
                    style: n,
                    styleSpec: r
                });
            case "image":
                return Hr({
                    key: i,
                    value: e,
                    valueSpec: r.source_image,
                    style: n,
                    styleSpec: r
                });
            case "canvas":
                return [new Wr(i,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
            default:
                return nn({
                    key: `${i}.type`,
                    value: e.type,
                    valueSpec: {
                        values: Mn(r)
                    },
                    style: n,
                    styleSpec: r
                })
            }
        }
        function Mn(t) {
            return t.source.reduce(((e,i)=>{
                const r = t[i];
                return "enum" === r.type.type && (e = e.concat(Object.keys(r.type.values))),
                e
            }
            ), [])
        }
        function An(t) {
            const e = t.value
              , i = t.styleSpec
              , r = i.light
              , n = t.style;
            let o = [];
            const s = Pr(e);
            if (void 0 === e)
                return o;
            if ("object" !== s)
                return o = o.concat([new Wr("light",e,`object expected, ${s} found`)]),
                o;
            for (const t in e) {
                const s = t.match(/^(.*)-transition$/);
                o = o.concat(s && r[s[1]] && r[s[1]].transition ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: i.transition,
                    style: n,
                    styleSpec: i
                }) : r[t] ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: r[t],
                    style: n,
                    styleSpec: i
                }) : [new Wr(t,e[t],`unknown property "${t}"`)])
            }
            return o
        }
        function In(t) {
            const e = t.value
              , i = t.key
              , r = t.style
              , n = t.styleSpec
              , o = n.terrain;
            let s = [];
            const a = Pr(e);
            if (void 0 === e)
                return s;
            if ("object" !== a)
                return s = s.concat([new Wr("terrain",e,`object expected, ${a} found`)]),
                s;
            for (const t in e) {
                const i = t.match(/^(.*)-transition$/);
                s = s.concat(i && o[i[1]] && o[i[1]].transition ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: n.transition,
                    style: r,
                    styleSpec: n
                }) : o[t] ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: o[t],
                    style: r,
                    styleSpec: n
                }) : [new Wr(t,e[t],`unknown property "${t}"`)])
            }
            if (e.source) {
                const t = r.sources && r.sources[e.source]
                  , n = t && Kt(t.type);
                t ? "raster-dem" !== n && s.push(new Wr(i,e.source,`terrain cannot be used with a source of type ${String(n)}, it only be used with a "raster-dem" source type`)) : s.push(new Wr(i,e.source,`source "${e.source}" not found`))
            } else
                s.push(new Wr(i,e,'terrain is missing required property "source"'));
            return s
        }
        function Cn(t) {
            const e = t.value
              , i = t.style
              , r = t.styleSpec
              , n = r.fog;
            let o = [];
            const s = Pr(e);
            if (void 0 === e)
                return o;
            if ("object" !== s)
                return o = o.concat([new Wr("fog",e,`object expected, ${s} found`)]),
                o;
            for (const t in e) {
                const s = t.match(/^(.*)-transition$/);
                o = o.concat(s && n[s[1]] && n[s[1]].transition ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                }) : n[t] ? kn({
                    key: t,
                    value: e[t],
                    valueSpec: n[t],
                    style: i,
                    styleSpec: r
                }) : [new Wr(t,e[t],`unknown property "${t}"`)])
            }
            return o
        }
        const Dn = {
            "*": ()=>[],
            array: Kr,
            boolean: function(t) {
                const e = t.value
                  , i = t.key
                  , r = Pr(e);
                return "boolean" !== r ? [new Wr(i,e,`boolean expected, ${r} found`)] : []
            },
            number: Qr,
            color: function(t) {
                const e = t.key
                  , i = t.value
                  , r = Pr(i);
                return "string" !== r ? [new Wr(e,i,`color expected, ${r} found`)] : null === ve(i) ? [new Wr(e,i,`color expected, "${i}" found`)] : []
            },
            enum: nn,
            filter: yn,
            function: tn,
            layer: zn,
            object: Hr,
            source: Sn,
            light: An,
            terrain: In,
            fog: Cn,
            string: Tn,
            formatted: function(t) {
                return 0 === Tn(t).length ? [] : en(t)
            },
            resolvedImage: function(t) {
                return 0 === Tn(t).length ? [] : en(t)
            },
            projection: function(t) {
                const e = t.value
                  , i = t.styleSpec
                  , r = i.projection
                  , n = t.style;
                let o = [];
                const s = Pr(e);
                if ("object" === s)
                    for (const t in e)
                        o = o.concat(kn({
                            key: t,
                            value: e[t],
                            valueSpec: r[t],
                            style: n,
                            styleSpec: i
                        }));
                else
                    "string" !== s && (o = o.concat([new Wr("projection",e,`object or string expected, ${s} found`)]));
                return o
            }
        };
        function kn(t) {
            const e = t.value
              , i = t.valueSpec
              , r = t.styleSpec;
            return i.expression && Lr(Kt(e)) ? tn(t) : i.expression && Vr(Qt(e)) ? en(t) : i.type && Dn[i.type] ? Dn[i.type](t) : Hr(Ht({}, t, {
                valueSpec: i.type ? r[i.type] : i
            }))
        }
        function Pn(t) {
            const e = t.value
              , i = t.key
              , r = Tn(t);
            return r.length || (-1 === e.indexOf("{fontstack}") && r.push(new Wr(i,e,'"glyphs" url must include a "{fontstack}" token')),
            -1 === e.indexOf("{range}") && r.push(new Wr(i,e,'"glyphs" url must include a "{range}" token'))),
            r
        }
        function Ln(t, e=Wt) {
            return Bn(kn({
                key: "",
                value: t,
                valueSpec: e.$root,
                styleSpec: e,
                style: t,
                objectElementValidators: {
                    glyphs: Pn,
                    "*": ()=>[]
                }
            }))
        }
        const On = t=>Bn(bn(t))
          , Rn = t=>Bn(wn(t));
        function Bn(t) {
            return t.slice().sort(((t,e)=>t.line && e.line ? t.line - e.line : 0))
        }
        function Fn(t, e) {
            let i = !1;
            if (e && e.length)
                for (const r of e)
                    t.fire(new $t(new Error(r.message))),
                    i = !0;
            return i
        }
        var Un = Nn;
        function Nn(t, e, i) {
            var r = this.cells = [];
            if (t instanceof ArrayBuffer) {
                this.arrayBuffer = t;
                var n = new Int32Array(this.arrayBuffer);
                t = n[0],
                this.d = (e = n[1]) + 2 * (i = n[2]);
                for (var o = 0; o < this.d * this.d; o++) {
                    var s = n[3 + o]
                      , a = n[3 + o + 1];
                    r.push(s === a ? null : n.subarray(s, a))
                }
                var l = n[3 + r.length + 1];
                this.keys = n.subarray(n[3 + r.length], l),
                this.bboxes = n.subarray(l),
                this.insert = this._insertReadonly
            } else {
                this.d = e + 2 * i;
                for (var c = 0; c < this.d * this.d; c++)
                    r.push([]);
                this.keys = [],
                this.bboxes = []
            }
            this.n = e,
            this.extent = t,
            this.padding = i,
            this.scale = e / t,
            this.uid = 0;
            var u = i / e * t;
            this.min = -u,
            this.max = t + u
        }
        Nn.prototype.insert = function(t, e, i, r, n) {
            this._forEachCell(e, i, r, n, this._insertCell, this.uid++),
            this.keys.push(t),
            this.bboxes.push(e),
            this.bboxes.push(i),
            this.bboxes.push(r),
            this.bboxes.push(n)
        }
        ,
        Nn.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer."
        }
        ,
        Nn.prototype._insertCell = function(t, e, i, r, n, o) {
            this.cells[n].push(o)
        }
        ,
        Nn.prototype.query = function(t, e, i, r, n) {
            var o = this.min
              , s = this.max;
            if (t <= o && e <= o && s <= i && s <= r && !n)
                return Array.prototype.slice.call(this.keys);
            var a = [];
            return this._forEachCell(t, e, i, r, this._queryCell, a, {}, n),
            a
        }
        ,
        Nn.prototype._queryCell = function(t, e, i, r, n, o, s, a) {
            var l = this.cells[n];
            if (null !== l)
                for (var c = this.keys, u = this.bboxes, h = 0; h < l.length; h++) {
                    var d = l[h];
                    if (void 0 === s[d]) {
                        var p = 4 * d;
                        (a ? a(u[p + 0], u[p + 1], u[p + 2], u[p + 3]) : t <= u[p + 2] && e <= u[p + 3] && i >= u[p + 0] && r >= u[p + 1]) ? (s[d] = !0,
                        o.push(c[d])) : s[d] = !1
                    }
                }
        }
        ,
        Nn.prototype._forEachCell = function(t, e, i, r, n, o, s, a) {
            for (var l = this._convertToCellCoord(t), c = this._convertToCellCoord(e), u = this._convertToCellCoord(i), h = this._convertToCellCoord(r), d = l; d <= u; d++)
                for (var p = c; p <= h; p++) {
                    var m = this.d * p + d;
                    if ((!a || a(this._convertFromCellCoord(d), this._convertFromCellCoord(p), this._convertFromCellCoord(d + 1), this._convertFromCellCoord(p + 1))) && n.call(this, t, e, i, r, m, o, s, a))
                        return
                }
        }
        ,
        Nn.prototype._convertFromCellCoord = function(t) {
            return (t - this.padding) / this.scale
        }
        ,
        Nn.prototype._convertToCellCoord = function(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
        }
        ,
        Nn.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer)
                return this.arrayBuffer;
            for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, i = 0, r = 0; r < this.cells.length; r++)
                i += this.cells[r].length;
            var n = new Int32Array(e + i + this.keys.length + this.bboxes.length);
            n[0] = this.extent,
            n[1] = this.n,
            n[2] = this.padding;
            for (var o = e, s = 0; s < t.length; s++) {
                var a = t[s];
                n[3 + s] = o,
                n.set(a, o),
                o += a.length
            }
            return n[3 + t.length] = o,
            n.set(this.keys, o),
            n[3 + t.length + 1] = o += this.keys.length,
            n.set(this.bboxes, o),
            o += this.bboxes.length,
            n.buffer
        }
        ;
        const Gn = {};
        function jn(t, e, i={}) {
            Object.defineProperty(t, "_classRegistryKey", {
                value: e,
                writeable: !1
            }),
            Gn[e] = {
                klass: t,
                omit: i.omit || []
            }
        }
        jn(Object, "Object"),
        Un.serialize = function(t, e) {
            const i = t.toArrayBuffer();
            return e && e.push(i),
            {
                buffer: i
            }
        }
        ,
        Un.deserialize = function(t) {
            return new Un(t.buffer)
        }
        ,
        Object.defineProperty(Un, "name", {
            value: "Grid"
        }),
        jn(Un, "Grid"),
        jn(Me, "Color"),
        jn(Error, "Error"),
        jn(st, "AJAXError"),
        jn(De, "ResolvedImage"),
        jn($r, "StylePropertyFunction"),
        jn(jr, "StyleExpression", {
            omit: ["_evaluator"]
        }),
        jn(Xr, "ZoomDependentExpression"),
        jn(Jr, "ZoomConstantExpression"),
        jn(We, "CompoundExpression", {
            omit: ["_evaluate"]
        });
        for (const t in Mr)
            Gn[Mr[t]._classRegistryKey] || jn(Mr[t], `Expression${t}`);
        function Vn(t) {
            return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name)
        }
        function Zn(t) {
            return e.ImageBitmap && t instanceof e.ImageBitmap
        }
        function Jn(t, i) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp)
                return t;
            if (Vn(t) || Zn(t))
                return i && i.push(t),
                t;
            if (ArrayBuffer.isView(t)) {
                const e = t;
                return i && i.push(e.buffer),
                e
            }
            if (t instanceof e.ImageData)
                return i && i.push(t.data.buffer),
                t;
            if (Array.isArray(t)) {
                const e = [];
                for (const r of t)
                    e.push(Jn(r, i));
                return e
            }
            if ("object" == typeof t) {
                const e = t.constructor
                  , r = e._classRegistryKey;
                if (!r)
                    throw new Error(`can't serialize object of unregistered class ${r}`);
                const n = e.serialize ? e.serialize(t, i) : {};
                if (!e.serialize) {
                    for (const e in t)
                        t.hasOwnProperty(e) && (Gn[r].omit.indexOf(e) >= 0 || (n[e] = Jn(t[e], i)));
                    t instanceof Error && (n.message = t.message)
                }
                if (n.$name)
                    throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== r && (n.$name = r),
                n
            }
            throw new Error("can't serialize object of type " + typeof t)
        }
        function Xn(t) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Vn(t) || Zn(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData)
                return t;
            if (Array.isArray(t))
                return t.map(Xn);
            if ("object" == typeof t) {
                const e = t.$name || "Object"
                  , {klass: i} = Gn[e];
                if (!i)
                    throw new Error(`can't deserialize unregistered class ${e}`);
                if (i.deserialize)
                    return i.deserialize(t);
                const r = Object.create(i.prototype);
                for (const e of Object.keys(t))
                    "$name" !== e && (r[e] = Xn(t[e]));
                return r
            }
            throw new Error("can't deserialize object of type " + typeof t)
        }
        const qn = t=>t >= 1536 && t <= 1791
          , $n = t=>t >= 1872 && t <= 1919
          , Yn = t=>t >= 2208 && t <= 2303
          , Wn = t=>t >= 11904 && t <= 12031
          , Hn = t=>t >= 12032 && t <= 12255
          , Kn = t=>t >= 12272 && t <= 12287
          , Qn = t=>t >= 12288 && t <= 12351
          , to = t=>t >= 12352 && t <= 12447
          , eo = t=>t >= 12448 && t <= 12543
          , io = t=>t >= 12544 && t <= 12591
          , ro = t=>t >= 12704 && t <= 12735
          , no = t=>t >= 12736 && t <= 12783
          , oo = t=>t >= 12784 && t <= 12799
          , so = t=>t >= 12800 && t <= 13055
          , ao = t=>t >= 13056 && t <= 13311
          , lo = t=>t >= 13312 && t <= 19903
          , co = t=>t >= 19968 && t <= 40959
          , uo = t=>t >= 40960 && t <= 42127
          , ho = t=>t >= 42128 && t <= 42191
          , po = t=>t >= 44032 && t <= 55215
          , mo = t=>t >= 63744 && t <= 64255
          , fo = t=>t >= 64336 && t <= 65023
          , _o = t=>t >= 65040 && t <= 65055
          , go = t=>t >= 65072 && t <= 65103
          , yo = t=>t >= 65104 && t <= 65135
          , xo = t=>t >= 65136 && t <= 65279
          , vo = t=>t >= 65280 && t <= 65519;
        function bo(t) {
            for (const e of t)
                if (To(e.charCodeAt(0)))
                    return !0;
            return !1
        }
        function wo(t) {
            for (const e of t)
                if (!zo(e.charCodeAt(0)))
                    return !1;
            return !0
        }
        function zo(t) {
            return !(qn(t) || $n(t) || Yn(t) || fo(t) || xo(t))
        }
        function To(t) {
            return !(746 !== t && 747 !== t && (t < 4352 || !(ro(t) || io(t) || go(t) && !(t >= 65097 && t <= 65103) || mo(t) || ao(t) || Wn(t) || no(t) || !(!Qn(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || lo(t) || co(t) || so(t) || (e = t,
            e >= 12592 && e <= 12687) || (t=>t >= 43360 && t <= 43391)(t) || (t=>t >= 55216 && t <= 55295)(t) || (t=>t >= 4352 && t <= 4607)(t) || po(t) || to(t) || Kn(t) || (t=>t >= 12688 && t <= 12703)(t) || Hn(t) || oo(t) || eo(t) && 12540 !== t || !(!vo(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!yo(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t=>t >= 5120 && t <= 5759)(t) || (t=>t >= 6320 && t <= 6399)(t) || _o(t) || (t=>t >= 19904 && t <= 19967)(t) || uo(t) || ho(t))));
            var e
        }
        function Eo(t) {
            return !(To(t) || (e = t,
            (i = e) >= 128 && i <= 255 && (167 === e || 169 === e || 174 === e || 177 === e || 188 === e || 189 === e || 190 === e || 215 === e || 247 === e) || (t=>t >= 8192 && t <= 8303)(e) && (8214 === e || 8224 === e || 8225 === e || 8240 === e || 8241 === e || 8251 === e || 8252 === e || 8258 === e || 8263 === e || 8264 === e || 8265 === e || 8273 === e) || (t=>t >= 8448 && t <= 8527)(e) || (t=>t >= 8528 && t <= 8591)(e) || (t=>t >= 8960 && t <= 9215)(e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || 9003 === e || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || 9167 === e || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || (t=>t >= 9216 && t <= 9279)(e) && 9251 !== e || (t=>t >= 9280 && t <= 9311)(e) || (t=>t >= 9312 && t <= 9471)(e) || (t=>t >= 9632 && t <= 9727)(e) || (t=>t >= 9728 && t <= 9983)(e) && !(e >= 9754 && e <= 9759) || (t=>t >= 11008 && t <= 11263)(e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Qn(e) || eo(e) || (t=>t >= 57344 && t <= 63743)(e) || go(e) || yo(e) || vo(e) || 8734 === e || 8756 === e || 8757 === e || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || 65532 === e || 65533 === e));
            var e, i
        }
        function So(t) {
            return t >= 1424 && t <= 2303 || fo(t) || xo(t)
        }
        function Mo(t, e) {
            return !(!e && So(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (i = t,
            i >= 6016 && i <= 6143));
            var i
        }
        function Ao(t) {
            for (const e of t)
                if (So(e.charCodeAt(0)))
                    return !0;
            return !1
        }
        const Io = "deferred"
          , Co = "loading"
          , Do = "loaded";
        let ko = null
          , Po = "unavailable"
          , Lo = null;
        const Oo = function(t) {
            t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Po = "error"),
            ko && ko(t)
        };
        function Ro() {
            Bo.fire(new qt("pluginStateChange",{
                pluginStatus: Po,
                pluginURL: Lo
            }))
        }
        const Bo = new Yt
          , Fo = function() {
            return Po
        }
          , Uo = function() {
            if (Po !== Io || !Lo)
                throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Po = Co,
            Ro(),
            Lo && ct({
                url: Lo
            }, (t=>{
                t ? Oo(t) : (Po = Do,
                Ro())
            }
            ))
        }
          , No = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Po === Do || null != No.applyArabicShaping,
            isLoading: ()=>Po === Co,
            setState(t) {
                Po = t.pluginStatus,
                Lo = t.pluginURL
            },
            isParsed: ()=>null != No.applyArabicShaping && null != No.processBidirectionalText && null != No.processStyledBidirectionalText,
            getPluginURL: ()=>Lo
        };
        class Go {
            constructor(t, e) {
                this.zoom = t,
                e ? (this.now = e.now,
                this.fadeDuration = e.fadeDuration,
                this.transition = e.transition,
                this.pitch = e.pitch) : (this.now = 0,
                this.fadeDuration = 0,
                this.transition = {},
                this.pitch = 0)
            }
            isSupportedScript(t) {
                return function(t, e) {
                    for (const i of t)
                        if (!Mo(i.charCodeAt(0), e))
                            return !1;
                    return !0
                }(t, No.isLoaded())
            }
        }
        class jo {
            constructor(t, e) {
                this.property = t,
                this.value = e,
                this.expression = function(t, e) {
                    if (Lr(t))
                        return new $r(t,e);
                    if (Vr(t)) {
                        const i = qr(t, e);
                        if ("error" === i.result)
                            throw new Error(i.value.map((t=>`${t.key}: ${t.message}`)).join(", "));
                        return i.value
                    }
                    {
                        let i = t;
                        return "string" == typeof t && "color" === e.type && (i = Me.parse(t)),
                        {
                            kind: "constant",
                            evaluate: ()=>i
                        }
                    }
                }(void 0 === e ? t.specification.default : e, t.specification)
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind
            }
            possiblyEvaluate(t, e, i) {
                return this.property.possiblyEvaluate(this, t, e, i)
            }
        }
        class Vo {
            constructor(t) {
                this.property = t,
                this.value = new jo(t,void 0)
            }
            transitioned(t, e) {
                return new Jo(this.property,this.value,e,I({}, t.transition, this.transition),t.now)
            }
            untransitioned() {
                return new Jo(this.property,this.value,null,{},0)
            }
        }
        class Zo {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultTransitionablePropertyValues)
            }
            getValue(t) {
                return U(this._values[t].value.value)
            }
            setValue(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Vo(this._values[t].property)),
                this._values[t].value = new jo(this._values[t].property,null === e ? void 0 : U(e))
            }
            getTransition(t) {
                return U(this._values[t].transition)
            }
            setTransition(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Vo(this._values[t].property)),
                this._values[t].transition = U(e) || void 0
            }
            serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                    const i = this.getValue(e);
                    void 0 !== i && (t[e] = i);
                    const r = this.getTransition(e);
                    void 0 !== r && (t[`${e}-transition`] = r)
                }
                return t
            }
            transitioned(t, e) {
                const i = new Xo(this._properties);
                for (const r of Object.keys(this._values))
                    i._values[r] = this._values[r].transitioned(t, e._values[r]);
                return i
            }
            untransitioned() {
                const t = new Xo(this._properties);
                for (const e of Object.keys(this._values))
                    t._values[e] = this._values[e].untransitioned();
                return t
            }
        }
        class Jo {
            constructor(t, e, i, r, n) {
                const o = r.delay || 0
                  , s = r.duration || 0;
                n = n || 0,
                this.property = t,
                this.value = e,
                this.begin = n + o,
                this.end = this.begin + s,
                t.specification.transition && (r.delay || r.duration) && (this.prior = i)
            }
            possiblyEvaluate(t, e, i) {
                const r = t.now || 0
                  , n = this.value.possiblyEvaluate(t, e, i)
                  , o = this.prior;
                if (o) {
                    if (r > this.end)
                        return this.prior = null,
                        n;
                    if (this.value.isDataDriven())
                        return this.prior = null,
                        n;
                    if (r < this.begin)
                        return o.possiblyEvaluate(t, e, i);
                    {
                        const s = (r - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(o.possiblyEvaluate(t, e, i), n, b(s))
                    }
                }
                return n
            }
        }
        class Xo {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultTransitioningPropertyValues)
            }
            possiblyEvaluate(t, e, i) {
                const r = new Yo(this._properties);
                for (const n of Object.keys(this._values))
                    r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
                return r
            }
            hasTransition() {
                for (const t of Object.keys(this._values))
                    if (this._values[t].prior)
                        return !0;
                return !1
            }
        }
        class qo {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultPropertyValues)
            }
            getValue(t) {
                return U(this._values[t].value)
            }
            setValue(t, e) {
                this._values[t] = new jo(this._values[t].property,null === e ? void 0 : U(e))
            }
            serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                    const i = this.getValue(e);
                    void 0 !== i && (t[e] = i)
                }
                return t
            }
            possiblyEvaluate(t, e, i) {
                const r = new Yo(this._properties);
                for (const n of Object.keys(this._values))
                    r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
                return r
            }
        }
        class $o {
            constructor(t, e, i) {
                this.property = t,
                this.value = e,
                this.parameters = i
            }
            isConstant() {
                return "constant" === this.value.kind
            }
            constantOr(t) {
                return "constant" === this.value.kind ? this.value.value : t
            }
            evaluate(t, e, i, r) {
                return this.property.evaluate(this.value, this.parameters, t, e, i, r)
            }
        }
        class Yo {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultPossiblyEvaluatedValues)
            }
            get(t) {
                return this._values[t]
            }
        }
        class Wo {
            constructor(t) {
                this.specification = t
            }
            possiblyEvaluate(t, e) {
                return t.expression.evaluate(e)
            }
            interpolate(t, e, i) {
                const r = Ai[this.specification.type];
                return r ? r(t, e, i) : t
            }
        }
        class Ho {
            constructor(t, e) {
                this.specification = t,
                this.overrides = e
            }
            possiblyEvaluate(t, e, i, r) {
                return new $o(this,"constant" === t.expression.kind || "camera" === t.expression.kind ? {
                    kind: "constant",
                    value: t.expression.evaluate(e, null, {}, i, r)
                } : t.expression,e)
            }
            interpolate(t, e, i) {
                if ("constant" !== t.value.kind || "constant" !== e.value.kind)
                    return t;
                if (void 0 === t.value.value || void 0 === e.value.value)
                    return new $o(this,{
                        kind: "constant",
                        value: void 0
                    },t.parameters);
                const r = Ai[this.specification.type];
                return r ? new $o(this,{
                    kind: "constant",
                    value: r(t.value.value, e.value.value, i)
                },t.parameters) : t
            }
            evaluate(t, e, i, r, n, o) {
                return "constant" === t.kind ? t.value : t.evaluate(e, i, r, n, o)
            }
        }
        class Ko {
            constructor(t) {
                this.specification = t
            }
            possiblyEvaluate(t, e, i, r) {
                return !!t.expression.evaluate(e, null, {}, i, r)
            }
            interpolate() {
                return !1
            }
        }
        class Qo {
            constructor(t) {
                this.properties = t,
                this.defaultPropertyValues = {},
                this.defaultTransitionablePropertyValues = {},
                this.defaultTransitioningPropertyValues = {},
                this.defaultPossiblyEvaluatedValues = {},
                this.overridableProperties = [];
                const e = new Go(0,{});
                for (const i in t) {
                    const r = t[i];
                    r.specification.overridable && this.overridableProperties.push(i);
                    const n = this.defaultPropertyValues[i] = new jo(r,void 0)
                      , o = this.defaultTransitionablePropertyValues[i] = new Vo(r);
                    this.defaultTransitioningPropertyValues[i] = o.untransitioned(),
                    this.defaultPossiblyEvaluatedValues[i] = n.possiblyEvaluate(e)
                }
            }
        }
        function ts(t, e) {
            return 256 * (t = T(Math.floor(t), 0, 255)) + T(Math.floor(e), 0, 255)
        }
        jn(Ho, "DataDrivenProperty"),
        jn(Wo, "DataConstantProperty"),
        jn(Ko, "ColorRampProperty");
        const es = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class is {
            constructor(t, e) {
                this._structArray = t,
                this._pos1 = e * this.size,
                this._pos2 = this._pos1 / 2,
                this._pos4 = this._pos1 / 4,
                this._pos8 = this._pos1 / 8
            }
        }
        class rs {
            constructor() {
                this.isTransferred = !1,
                this.capacity = -1,
                this.resize(0)
            }
            static serialize(t, e) {
                return t._trim(),
                e && (t.isTransferred = !0,
                e.push(t.arrayBuffer)),
                {
                    length: t.length,
                    arrayBuffer: t.arrayBuffer
                }
            }
            static deserialize(t) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t.arrayBuffer,
                e.length = t.length,
                e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement,
                e._refreshViews(),
                e
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length,
                this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                this._refreshViews())
            }
            clear() {
                this.length = 0
            }
            resize(t) {
                this.reserve(t),
                this.length = t
            }
            reserve(t) {
                if (t > this.capacity) {
                    this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                    this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(),
                    e && this.uint8.set(e)
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null,
                this.arrayBuffer = null
            }
        }
        function ns(t, e=1) {
            let i = 0
              , r = 0;
            return {
                members: t.map((t=>{
                    const n = es[t.type].BYTES_PER_ELEMENT
                      , o = i = os(i, Math.max(e, n))
                      , s = t.components || 1;
                    return r = Math.max(r, n),
                    i += n * s,
                    {
                        name: t.name,
                        type: t.type,
                        components: s,
                        offset: o
                    }
                }
                )),
                size: os(i, Math.max(r, e)),
                alignment: e
            }
        }
        function os(t, e) {
            return Math.ceil(t / e) * e
        }
        class ss extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e)
            }
            emplace(t, e, i) {
                const r = 2 * t;
                return this.int16[r + 0] = e,
                this.int16[r + 1] = i,
                t
            }
        }
        ss.prototype.bytesPerElement = 4,
        jn(ss, "StructArrayLayout2i4");
        class as extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e, i)
            }
            emplace(t, e, i, r) {
                const n = 3 * t;
                return this.int16[n + 0] = e,
                this.int16[n + 1] = i,
                this.int16[n + 2] = r,
                t
            }
        }
        as.prototype.bytesPerElement = 6,
        jn(as, "StructArrayLayout3i6");
        class ls extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, i, r)
            }
            emplace(t, e, i, r, n) {
                const o = 4 * t;
                return this.int16[o + 0] = e,
                this.int16[o + 1] = i,
                this.int16[o + 2] = r,
                this.int16[o + 3] = n,
                t
            }
        }
        ls.prototype.bytesPerElement = 8,
        jn(ls, "StructArrayLayout4i8");
        class cs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s) {
                const a = this.length;
                return this.resize(a + 1),
                this.emplace(a, t, e, i, r, n, o, s)
            }
            emplace(t, e, i, r, n, o, s, a) {
                const l = 6 * t
                  , c = 12 * t
                  , u = 3 * t;
                return this.int16[l + 0] = e,
                this.int16[l + 1] = i,
                this.uint8[c + 4] = r,
                this.uint8[c + 5] = n,
                this.uint8[c + 6] = o,
                this.uint8[c + 7] = s,
                this.float32[u + 2] = a,
                t
            }
        }
        cs.prototype.bytesPerElement = 12,
        jn(cs, "StructArrayLayout2i4ub1f12");
        class us extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, i, r)
            }
            emplace(t, e, i, r, n) {
                const o = 4 * t;
                return this.float32[o + 0] = e,
                this.float32[o + 1] = i,
                this.float32[o + 2] = r,
                this.float32[o + 3] = n,
                t
            }
        }
        us.prototype.bytesPerElement = 16,
        jn(us, "StructArrayLayout4f16");
        class hs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n) {
                const o = this.length;
                return this.resize(o + 1),
                this.emplace(o, t, e, i, r, n)
            }
            emplace(t, e, i, r, n, o) {
                const s = 6 * t
                  , a = 3 * t;
                return this.uint16[s + 0] = e,
                this.uint16[s + 1] = i,
                this.uint16[s + 2] = r,
                this.uint16[s + 3] = n,
                this.float32[a + 2] = o,
                t
            }
        }
        hs.prototype.bytesPerElement = 12,
        jn(hs, "StructArrayLayout4ui1f12");
        class ds extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, i, r)
            }
            emplace(t, e, i, r, n) {
                const o = 4 * t;
                return this.uint16[o + 0] = e,
                this.uint16[o + 1] = i,
                this.uint16[o + 2] = r,
                this.uint16[o + 3] = n,
                t
            }
        }
        ds.prototype.bytesPerElement = 8,
        jn(ds, "StructArrayLayout4ui8");
        class ps extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o) {
                const s = this.length;
                return this.resize(s + 1),
                this.emplace(s, t, e, i, r, n, o)
            }
            emplace(t, e, i, r, n, o, s) {
                const a = 6 * t;
                return this.int16[a + 0] = e,
                this.int16[a + 1] = i,
                this.int16[a + 2] = r,
                this.int16[a + 3] = n,
                this.int16[a + 4] = o,
                this.int16[a + 5] = s,
                t
            }
        }
        ps.prototype.bytesPerElement = 12,
        jn(ps, "StructArrayLayout6i12");
        class ms extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s, a, l, c, u, h) {
                const d = this.length;
                return this.resize(d + 1),
                this.emplace(d, t, e, i, r, n, o, s, a, l, c, u, h)
            }
            emplace(t, e, i, r, n, o, s, a, l, c, u, h, d) {
                const p = 12 * t;
                return this.int16[p + 0] = e,
                this.int16[p + 1] = i,
                this.int16[p + 2] = r,
                this.int16[p + 3] = n,
                this.uint16[p + 4] = o,
                this.uint16[p + 5] = s,
                this.uint16[p + 6] = a,
                this.uint16[p + 7] = l,
                this.int16[p + 8] = c,
                this.int16[p + 9] = u,
                this.int16[p + 10] = h,
                this.int16[p + 11] = d,
                t
            }
        }
        ms.prototype.bytesPerElement = 24,
        jn(ms, "StructArrayLayout4i4ui4i24");
        class fs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o) {
                const s = this.length;
                return this.resize(s + 1),
                this.emplace(s, t, e, i, r, n, o)
            }
            emplace(t, e, i, r, n, o, s) {
                const a = 10 * t
                  , l = 5 * t;
                return this.int16[a + 0] = e,
                this.int16[a + 1] = i,
                this.int16[a + 2] = r,
                this.float32[l + 2] = n,
                this.float32[l + 3] = o,
                this.float32[l + 4] = s,
                t
            }
        }
        fs.prototype.bytesPerElement = 20,
        jn(fs, "StructArrayLayout3i3f20");
        class _s extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer)
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.uint32[1 * t + 0] = e,
                t
            }
        }
        _s.prototype.bytesPerElement = 4,
        jn(_s, "StructArrayLayout1ul4");
        class gs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s, a, l, c, u, h, d) {
                const p = this.length;
                return this.resize(p + 1),
                this.emplace(p, t, e, i, r, n, o, s, a, l, c, u, h, d)
            }
            emplace(t, e, i, r, n, o, s, a, l, c, u, h, d, p) {
                const m = 20 * t
                  , f = 10 * t;
                return this.int16[m + 0] = e,
                this.int16[m + 1] = i,
                this.int16[m + 2] = r,
                this.int16[m + 3] = n,
                this.int16[m + 4] = o,
                this.float32[f + 3] = s,
                this.float32[f + 4] = a,
                this.float32[f + 5] = l,
                this.float32[f + 6] = c,
                this.int16[m + 14] = u,
                this.uint32[f + 8] = h,
                this.uint16[m + 18] = d,
                this.uint16[m + 19] = p,
                t
            }
        }
        gs.prototype.bytesPerElement = 40,
        jn(gs, "StructArrayLayout5i4f1i1ul2ui40");
        class ys extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s) {
                const a = this.length;
                return this.resize(a + 1),
                this.emplace(a, t, e, i, r, n, o, s)
            }
            emplace(t, e, i, r, n, o, s, a) {
                const l = 8 * t;
                return this.int16[l + 0] = e,
                this.int16[l + 1] = i,
                this.int16[l + 2] = r,
                this.int16[l + 4] = n,
                this.int16[l + 5] = o,
                this.int16[l + 6] = s,
                this.int16[l + 7] = a,
                t
            }
        }
        ys.prototype.bytesPerElement = 16,
        jn(ys, "StructArrayLayout3i2i2i16");
        class xs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n) {
                const o = this.length;
                return this.resize(o + 1),
                this.emplace(o, t, e, i, r, n)
            }
            emplace(t, e, i, r, n, o) {
                const s = 4 * t
                  , a = 8 * t;
                return this.float32[s + 0] = e,
                this.float32[s + 1] = i,
                this.float32[s + 2] = r,
                this.int16[a + 6] = n,
                this.int16[a + 7] = o,
                t
            }
        }
        xs.prototype.bytesPerElement = 16,
        jn(xs, "StructArrayLayout2f1f2i16");
        class vs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, i, r)
            }
            emplace(t, e, i, r, n) {
                const o = 12 * t
                  , s = 3 * t;
                return this.uint8[o + 0] = e,
                this.uint8[o + 1] = i,
                this.float32[s + 1] = r,
                this.float32[s + 2] = n,
                t
            }
        }
        vs.prototype.bytesPerElement = 12,
        jn(vs, "StructArrayLayout2ub2f12");
        class bs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e, i)
            }
            emplace(t, e, i, r) {
                const n = 3 * t;
                return this.float32[n + 0] = e,
                this.float32[n + 1] = i,
                this.float32[n + 2] = r,
                t
            }
        }
        bs.prototype.bytesPerElement = 12,
        jn(bs, "StructArrayLayout3f12");
        class ws extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e, i)
            }
            emplace(t, e, i, r) {
                const n = 3 * t;
                return this.uint16[n + 0] = e,
                this.uint16[n + 1] = i,
                this.uint16[n + 2] = r,
                t
            }
        }
        ws.prototype.bytesPerElement = 6,
        jn(ws, "StructArrayLayout3ui6");
        class zs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v) {
                const b = this.length;
                return this.resize(b + 1),
                this.emplace(b, t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v)
            }
            emplace(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v, b) {
                const w = 30 * t
                  , z = 15 * t
                  , T = 60 * t;
                return this.int16[w + 0] = e,
                this.int16[w + 1] = i,
                this.int16[w + 2] = r,
                this.float32[z + 2] = n,
                this.float32[z + 3] = o,
                this.uint16[w + 8] = s,
                this.uint16[w + 9] = a,
                this.uint32[z + 5] = l,
                this.uint32[z + 6] = c,
                this.uint32[z + 7] = u,
                this.uint16[w + 16] = h,
                this.uint16[w + 17] = d,
                this.uint16[w + 18] = p,
                this.float32[z + 10] = m,
                this.float32[z + 11] = f,
                this.uint8[T + 48] = _,
                this.uint8[T + 49] = g,
                this.uint8[T + 50] = y,
                this.uint32[z + 13] = x,
                this.int16[w + 28] = v,
                this.uint8[T + 58] = b,
                t
            }
        }
        zs.prototype.bytesPerElement = 60,
        jn(zs, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Ts extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v, b, w, z, T, E, S, M, A, I) {
                const C = this.length;
                return this.resize(C + 1),
                this.emplace(C, t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v, b, w, z, T, E, S, M, A, I)
            }
            emplace(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v, b, w, z, T, E, S, M, A, I, C) {
                const D = 38 * t
                  , k = 19 * t;
                return this.int16[D + 0] = e,
                this.int16[D + 1] = i,
                this.int16[D + 2] = r,
                this.float32[k + 2] = n,
                this.float32[k + 3] = o,
                this.int16[D + 8] = s,
                this.int16[D + 9] = a,
                this.int16[D + 10] = l,
                this.int16[D + 11] = c,
                this.int16[D + 12] = u,
                this.int16[D + 13] = h,
                this.uint16[D + 14] = d,
                this.uint16[D + 15] = p,
                this.uint16[D + 16] = m,
                this.uint16[D + 17] = f,
                this.uint16[D + 18] = _,
                this.uint16[D + 19] = g,
                this.uint16[D + 20] = y,
                this.uint16[D + 21] = x,
                this.uint16[D + 22] = v,
                this.uint16[D + 23] = b,
                this.uint16[D + 24] = w,
                this.uint16[D + 25] = z,
                this.uint16[D + 26] = T,
                this.uint16[D + 27] = E,
                this.uint16[D + 28] = S,
                this.uint32[k + 15] = M,
                this.float32[k + 16] = A,
                this.float32[k + 17] = I,
                this.float32[k + 18] = C,
                t
            }
        }
        Ts.prototype.bytesPerElement = 76,
        jn(Ts, "StructArrayLayout3i2f6i15ui1ul3f76");
        class Es extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.float32[1 * t + 0] = e,
                t
            }
        }
        Es.prototype.bytesPerElement = 4,
        jn(Es, "StructArrayLayout1f4");
        class Ss extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r, n) {
                const o = this.length;
                return this.resize(o + 1),
                this.emplace(o, t, e, i, r, n)
            }
            emplace(t, e, i, r, n, o) {
                const s = 5 * t;
                return this.float32[s + 0] = e,
                this.float32[s + 1] = i,
                this.float32[s + 2] = r,
                this.float32[s + 3] = n,
                this.float32[s + 4] = o,
                t
            }
        }
        Ss.prototype.bytesPerElement = 20,
        jn(Ss, "StructArrayLayout5f20");
        class Ms extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e, i, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, i, r)
            }
            emplace(t, e, i, r, n) {
                const o = 6 * t;
                return this.uint32[3 * t + 0] = e,
                this.uint16[o + 2] = i,
                this.uint16[o + 3] = r,
                this.uint16[o + 4] = n,
                t
            }
        }
        Ms.prototype.bytesPerElement = 12,
        jn(Ms, "StructArrayLayout1ul3ui12");
        class As extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t, e) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e)
            }
            emplace(t, e, i) {
                const r = 2 * t;
                return this.uint16[r + 0] = e,
                this.uint16[r + 1] = i,
                t
            }
        }
        As.prototype.bytesPerElement = 4,
        jn(As, "StructArrayLayout2ui4");
        class Is extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer)
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.uint16[1 * t + 0] = e,
                t
            }
        }
        Is.prototype.bytesPerElement = 2,
        jn(Is, "StructArrayLayout1ui2");
        class Cs extends rs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer)
            }
            emplaceBack(t, e) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e)
            }
            emplace(t, e, i) {
                const r = 2 * t;
                return this.float32[r + 0] = e,
                this.float32[r + 1] = i,
                t
            }
        }
        Cs.prototype.bytesPerElement = 8,
        jn(Cs, "StructArrayLayout2f8");
        class Ds extends is {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3]
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4]
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4]
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5]
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6]
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14]
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8]
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19]
            }
        }
        Ds.prototype.size = 40;
        class ks extends gs {
            get(t) {
                return new Ds(this,t)
            }
        }
        jn(ks, "CollisionBoxArray");
        class Ps extends is {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2]
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8]
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9]
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5]
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6]
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7]
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16]
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17]
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10]
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11]
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48]
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49]
            }
            set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 49] = t
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50]
            }
            set hidden(t) {
                this._structArray.uint8[this._pos1 + 50] = t
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13]
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 13] = t
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28]
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58]
            }
            set flipState(t) {
                this._structArray.uint8[this._pos1 + 58] = t
            }
        }
        Ps.prototype.size = 60;
        class Ls extends zs {
            get(t) {
                return new Ps(this,t)
            }
        }
        jn(Ls, "PlacedSymbolArray");
        class Os extends is {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2]
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8]
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9]
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10]
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11]
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12]
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13]
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 14]
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15]
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16]
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17]
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19]
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20]
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21]
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22]
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23]
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24]
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25]
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26]
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27]
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28]
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15]
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 15] = t
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 16]
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 17]
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18]
            }
        }
        Os.prototype.size = 76;
        class Rs extends Ts {
            get(t) {
                return new Os(this,t)
            }
        }
        jn(Rs, "SymbolInstanceArray");
        class Bs extends Es {
            getoffsetX(t) {
                return this.float32[1 * t + 0]
            }
        }
        jn(Bs, "GlyphOffsetArray");
        class Fs extends ss {
            getx(t) {
                return this.int16[2 * t + 0]
            }
            gety(t) {
                return this.int16[2 * t + 1]
            }
        }
        jn(Fs, "SymbolLineVertexArray");
        class Us extends is {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0]
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2]
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3]
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4]
            }
        }
        Us.prototype.size = 12;
        class Ns extends Ms {
            get(t) {
                return new Us(this,t)
            }
        }
        jn(Ns, "FeatureIndexArray");
        class Gs extends As {
            geta_centroid_pos0(t) {
                return this.uint16[2 * t + 0]
            }
            geta_centroid_pos1(t) {
                return this.uint16[2 * t + 1]
            }
        }
        jn(Gs, "FillExtrusionCentroidArray");
        const js = ns([{
            name: "a_pattern",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_pixel_ratio",
            components: 1,
            type: "Float32"
        }])
          , Vs = ns([{
            name: "a_dash",
            components: 4,
            type: "Uint16"
        }]);
        var Zs = {
            exports: {}
        }
          , Js = {
            exports: {}
        };
        Js.exports = function(t, e) {
            var i, r, n, o, s, a, l, c;
            for (r = t.length - (i = 3 & t.length),
            n = e,
            s = 3432918353,
            a = 461845907,
            c = 0; c < r; )
                l = 255 & t.charCodeAt(c) | (255 & t.charCodeAt(++c)) << 8 | (255 & t.charCodeAt(++c)) << 16 | (255 & t.charCodeAt(++c)) << 24,
                ++c,
                n = 27492 + (65535 & (o = 5 * (65535 & (n = (n ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 13 | n >>> 19)) + ((5 * (n >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16);
            switch (l = 0,
            i) {
            case 3:
                l ^= (255 & t.charCodeAt(c + 2)) << 16;
            case 2:
                l ^= (255 & t.charCodeAt(c + 1)) << 8;
            case 1:
                n ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(c))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295
            }
            return n ^= t.length,
            n = 2246822507 * (65535 & (n ^= n >>> 16)) + ((2246822507 * (n >>> 16) & 65535) << 16) & 4294967295,
            n = 3266489909 * (65535 & (n ^= n >>> 13)) + ((3266489909 * (n >>> 16) & 65535) << 16) & 4294967295,
            (n ^= n >>> 16) >>> 0
        }
        ;
        var Xs = {
            exports: {}
        };
        Xs.exports = function(t, e) {
            for (var i, r = t.length, n = e ^ r, o = 0; r >= 4; )
                i = 1540483477 * (65535 & (i = 255 & t.charCodeAt(o) | (255 & t.charCodeAt(++o)) << 8 | (255 & t.charCodeAt(++o)) << 16 | (255 & t.charCodeAt(++o)) << 24)) + ((1540483477 * (i >>> 16) & 65535) << 16),
                n = 1540483477 * (65535 & n) + ((1540483477 * (n >>> 16) & 65535) << 16) ^ (i = 1540483477 * (65535 & (i ^= i >>> 24)) + ((1540483477 * (i >>> 16) & 65535) << 16)),
                r -= 4,
                ++o;
            switch (r) {
            case 3:
                n ^= (255 & t.charCodeAt(o + 2)) << 16;
            case 2:
                n ^= (255 & t.charCodeAt(o + 1)) << 8;
            case 1:
                n = 1540483477 * (65535 & (n ^= 255 & t.charCodeAt(o))) + ((1540483477 * (n >>> 16) & 65535) << 16)
            }
            return n = 1540483477 * (65535 & (n ^= n >>> 13)) + ((1540483477 * (n >>> 16) & 65535) << 16),
            (n ^= n >>> 15) >>> 0
        }
        ;
        var qs = Js.exports
          , $s = Xs.exports;
        Zs.exports = qs,
        Zs.exports.murmur3 = qs,
        Zs.exports.murmur2 = $s;
        class Ys {
            constructor() {
                this.ids = [],
                this.positions = [],
                this.indexed = !1
            }
            add(t, e, i, r) {
                this.ids.push(Ws(t)),
                this.positions.push(e, i, r)
            }
            getPositions(t) {
                const e = Ws(t);
                let i = 0
                  , r = this.ids.length - 1;
                for (; i < r; ) {
                    const t = i + r >> 1;
                    this.ids[t] >= e ? r = t : i = t + 1
                }
                const n = [];
                for (; this.ids[i] === e; )
                    n.push({
                        index: this.positions[3 * i],
                        start: this.positions[3 * i + 1],
                        end: this.positions[3 * i + 2]
                    }),
                    i++;
                return n
            }
            static serialize(t, e) {
                const i = new Float64Array(t.ids)
                  , r = new Uint32Array(t.positions);
                return Hs(i, r, 0, i.length - 1),
                e && e.push(i.buffer, r.buffer),
                {
                    ids: i,
                    positions: r
                }
            }
            static deserialize(t) {
                const e = new Ys;
                return e.ids = t.ids,
                e.positions = t.positions,
                e.indexed = !0,
                e
            }
        }
        function Ws(t) {
            const e = +t;
            return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Zs.exports(String(t))
        }
        function Hs(t, e, i, r) {
            for (; i < r; ) {
                const n = t[i + r >> 1];
                let o = i - 1
                  , s = r + 1;
                for (; ; ) {
                    do {
                        o++
                    } while (t[o] < n);
                    do {
                        s--
                    } while (t[s] > n);
                    if (o >= s)
                        break;
                    Ks(t, o, s),
                    Ks(e, 3 * o, 3 * s),
                    Ks(e, 3 * o + 1, 3 * s + 1),
                    Ks(e, 3 * o + 2, 3 * s + 2)
                }
                s - i < r - s ? (Hs(t, e, i, s),
                i = s + 1) : (Hs(t, e, s + 1, r),
                r = s)
            }
        }
        function Ks(t, e, i) {
            const r = t[e];
            t[e] = t[i],
            t[i] = r
        }
        jn(Ys, "FeaturePositionMap");
        class Qs {
            constructor(t) {
                this.gl = t.gl,
                this.initialized = !1
            }
            fetchUniformLocation(t, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e),
                this.initialized = !0),
                !!this.location
            }
        }
        class ta extends Qs {
            constructor(t) {
                super(t),
                this.current = 0
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && this.current !== i && (this.current = i,
                this.gl.uniform1f(this.location, i))
            }
        }
        class ea extends Qs {
            constructor(t) {
                super(t),
                this.current = [0, 0, 0, 0]
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] && i[3] === this.current[3] || (this.current = i,
                this.gl.uniform4f(this.location, i[0], i[1], i[2], i[3])))
            }
        }
        class ia extends Qs {
            constructor(t) {
                super(t),
                this.current = Me.transparent
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && (i.r === this.current.r && i.g === this.current.g && i.b === this.current.b && i.a === this.current.a || (this.current = i,
                this.gl.uniform4f(this.location, i.r, i.g, i.b, i.a)))
            }
        }
        const ra = new Float32Array(16)
          , na = new Float32Array(9)
          , oa = new Float32Array(4);
        function sa(t) {
            return [ts(255 * t.r, 255 * t.g), ts(255 * t.b, 255 * t.a)]
        }
        class aa {
            constructor(t, e, i) {
                this.value = t,
                this.uniformNames = e.map((t=>`u_${t}`)),
                this.type = i
            }
            setUniform(t, e, i, r, n) {
                e.set(t, n, r.constantOr(this.value))
            }
            getBinding(t, e) {
                return "color" === this.type ? new ia(t) : new ta(t)
            }
        }
        class la {
            constructor(t, e) {
                this.uniformNames = e.map((t=>`u_${t}`)),
                this.pattern = null,
                this.pixelRatio = 1
            }
            setConstantPatternPositions(t) {
                this.pixelRatio = t.pixelRatio || 1,
                this.pattern = t.tl.concat(t.br)
            }
            setUniform(t, e, i, r, n) {
                const o = "u_pattern" === n || "u_dash" === n ? this.pattern : "u_pixel_ratio" === n ? this.pixelRatio : null;
                o && e.set(t, n, o)
            }
            getBinding(t, e) {
                return "u_pattern" === e || "u_dash" === e ? new ea(t) : new ta(t)
            }
        }
        class ca {
            constructor(t, e, i, r) {
                this.expression = t,
                this.type = i,
                this.maxValue = 0,
                this.paintVertexAttributes = e.map((t=>({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === i ? 2 : 1,
                    offset: 0
                }))),
                this.paintVertexArray = new r
            }
            populatePaintArray(t, e, i, r, n, o) {
                const s = this.paintVertexArray.length
                  , a = this.expression.evaluate(new Go(0), e, {}, n, r, o);
                this.paintVertexArray.resize(t),
                this._setPaintValue(s, t, a)
            }
            updatePaintArray(t, e, i, r, n) {
                const o = this.expression.evaluate({
                    zoom: 0
                }, i, r, void 0, n);
                this._setPaintValue(t, e, o)
            }
            _setPaintValue(t, e, i) {
                if ("color" === this.type) {
                    const r = sa(i);
                    for (let i = t; i < e; i++)
                        this.paintVertexArray.emplace(i, r[0], r[1])
                } else {
                    for (let r = t; r < e; r++)
                        this.paintVertexArray.emplace(r, i);
                    this.maxValue = Math.max(this.maxValue, Math.abs(i))
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy()
            }
        }
        class ua {
            constructor(t, e, i, r, n, o) {
                this.expression = t,
                this.uniformNames = e.map((t=>`u_${t}_t`)),
                this.type = i,
                this.useIntegerZoom = r,
                this.zoom = n,
                this.maxValue = 0,
                this.paintVertexAttributes = e.map((t=>({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === i ? 4 : 2,
                    offset: 0
                }))),
                this.paintVertexArray = new o
            }
            populatePaintArray(t, e, i, r, n, o) {
                const s = this.expression.evaluate(new Go(this.zoom), e, {}, n, r, o)
                  , a = this.expression.evaluate(new Go(this.zoom + 1), e, {}, n, r, o)
                  , l = this.paintVertexArray.length;
                this.paintVertexArray.resize(t),
                this._setPaintValue(l, t, s, a)
            }
            updatePaintArray(t, e, i, r, n) {
                const o = this.expression.evaluate({
                    zoom: this.zoom
                }, i, r, void 0, n)
                  , s = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, i, r, void 0, n);
                this._setPaintValue(t, e, o, s)
            }
            _setPaintValue(t, e, i, r) {
                if ("color" === this.type) {
                    const n = sa(i)
                      , o = sa(r);
                    for (let i = t; i < e; i++)
                        this.paintVertexArray.emplace(i, n[0], n[1], o[0], o[1])
                } else {
                    for (let n = t; n < e; n++)
                        this.paintVertexArray.emplace(n, i, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(r))
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy()
            }
            setUniform(t, e, i, r, n) {
                const o = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom
                  , s = T(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
                e.set(t, n, s)
            }
            getBinding(t, e) {
                return new ta(t)
            }
        }
        class ha {
            constructor(t, e, i, r, n) {
                this.expression = t,
                this.layerId = n,
                this.paintVertexAttributes = ("array" === i ? Vs : js).members;
                for (let t = 0; t < e.length; ++t)
                    ;
                this.paintVertexArray = new r
            }
            populatePaintArray(t, e, i) {
                const r = this.paintVertexArray.length;
                this.paintVertexArray.resize(t),
                this._setPaintValues(r, t, e.patterns && e.patterns[this.layerId], i)
            }
            updatePaintArray(t, e, i, r, n, o) {
                this._setPaintValues(t, e, i.patterns && i.patterns[this.layerId], o)
            }
            _setPaintValues(t, e, i, r) {
                if (!r || !i)
                    return;
                const n = r[i];
                if (!n)
                    return;
                const {tl: o, br: s, pixelRatio: a} = n;
                for (let i = t; i < e; i++)
                    this.paintVertexArray.emplace(i, o[0], o[1], s[0], s[1], a)
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy()
            }
        }
        class da {
            constructor(t, e, i=(()=>!0)) {
                this.binders = {},
                this._buffers = [];
                const r = [];
                for (const s in t.paint._values) {
                    if (!i(s))
                        continue;
                    const a = t.paint.get(s);
                    if (!(a instanceof $o && Cr(a.property.specification)))
                        continue;
                    const l = (n = s,
                    o = t.type,
                    ma[n] || [n.replace(`${o}-`, "").replace(/-/g, "_")])
                      , c = a.value
                      , u = a.property.specification.type
                      , h = a.property.useIntegerZoom
                      , d = "line-dasharray" === s || s.endsWith("pattern")
                      , p = "line-dasharray" === s && "constant" !== t.layout.get("line-cap").value.kind;
                    if ("constant" !== c.kind || p)
                        if ("source" === c.kind || p || d) {
                            const e = ga(s, u, "source");
                            this.binders[s] = d ? new ha(c,l,u,e,t.id) : new ca(c,l,u,e),
                            r.push(`/a_${s}`)
                        } else {
                            const t = ga(s, u, "composite");
                            this.binders[s] = new ua(c,l,u,h,e,t),
                            r.push(`/z_${s}`)
                        }
                    else
                        this.binders[s] = d ? new la(c.value,l) : new aa(c.value,l,u),
                        r.push(`/u_${s}`)
                }
                var n, o;
                this.cacheKey = r.sort().join("")
            }
            getMaxValue(t) {
                const e = this.binders[t];
                return e instanceof ca || e instanceof ua ? e.maxValue : 0
            }
            populatePaintArrays(t, e, i, r, n, o) {
                for (const s in this.binders) {
                    const a = this.binders[s];
                    (a instanceof ca || a instanceof ua || a instanceof ha) && a.populatePaintArray(t, e, i, r, n, o)
                }
            }
            setConstantPatternPositions(t) {
                for (const e in this.binders) {
                    const i = this.binders[e];
                    i instanceof la && i.setConstantPatternPositions(t)
                }
            }
            updatePaintArrays(t, e, i, r, n, o) {
                let s = !1;
                for (const a in t) {
                    const l = e.getPositions(a);
                    for (const e of l) {
                        const l = i.feature(e.index);
                        for (const i in this.binders) {
                            const c = this.binders[i];
                            if ((c instanceof ca || c instanceof ua || c instanceof ha) && !0 === c.expression.isStateDependent) {
                                const u = r.paint.get(i);
                                c.expression = u.value,
                                c.updatePaintArray(e.start, e.end, l, t[a], n, o),
                                s = !0
                            }
                        }
                    }
                }
                return s
            }
            defines() {
                const t = [];
                for (const e in this.binders) {
                    const i = this.binders[e];
                    (i instanceof aa || i instanceof la) && t.push(...i.uniformNames.map((t=>`#define HAS_UNIFORM_${t}`)))
                }
                return t
            }
            getBinderAttributes() {
                const t = [];
                for (const e in this.binders) {
                    const i = this.binders[e];
                    if (i instanceof ca || i instanceof ua || i instanceof ha)
                        for (let e = 0; e < i.paintVertexAttributes.length; e++)
                            t.push(i.paintVertexAttributes[e].name)
                }
                return t
            }
            getBinderUniforms() {
                const t = [];
                for (const e in this.binders) {
                    const i = this.binders[e];
                    if (i instanceof aa || i instanceof la || i instanceof ua)
                        for (const e of i.uniformNames)
                            t.push(e)
                }
                return t
            }
            getPaintVertexBuffers() {
                return this._buffers
            }
            getUniforms(t) {
                const e = [];
                for (const i in this.binders) {
                    const r = this.binders[i];
                    if (r instanceof aa || r instanceof la || r instanceof ua)
                        for (const n of r.uniformNames)
                            e.push({
                                name: n,
                                property: i,
                                binding: r.getBinding(t, n)
                            })
                }
                return e
            }
            setUniforms(t, e, i, r, n) {
                for (const {name: e, property: o, binding: s} of i)
                    this.binders[o].setUniform(t, s, n, r.get(o), e)
            }
            updatePaintBuffers() {
                this._buffers = [];
                for (const t in this.binders) {
                    const e = this.binders[t];
                    (e instanceof ca || e instanceof ua || e instanceof ha) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer)
                }
            }
            upload(t) {
                for (const e in this.binders) {
                    const i = this.binders[e];
                    (i instanceof ca || i instanceof ua || i instanceof ha) && i.upload(t)
                }
                this.updatePaintBuffers()
            }
            destroy() {
                for (const t in this.binders) {
                    const e = this.binders[t];
                    (e instanceof ca || e instanceof ua || e instanceof ha) && e.destroy()
                }
            }
        }
        class pa {
            constructor(t, e, i=(()=>!0)) {
                this.programConfigurations = {};
                for (const r of t)
                    this.programConfigurations[r.id] = new da(r,e,i);
                this.needsUpload = !1,
                this._featureMap = new Ys,
                this._bufferOffset = 0
            }
            populatePaintArrays(t, e, i, r, n, o, s) {
                for (const i in this.programConfigurations)
                    this.programConfigurations[i].populatePaintArrays(t, e, r, n, o, s);
                void 0 !== e.id && this._featureMap.add(e.id, i, this._bufferOffset, t),
                this._bufferOffset = t,
                this.needsUpload = !0
            }
            updatePaintArrays(t, e, i, r, n) {
                for (const o of i)
                    this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, r, n) || this.needsUpload
            }
            get(t) {
                return this.programConfigurations[t]
            }
            upload(t) {
                if (this.needsUpload) {
                    for (const e in this.programConfigurations)
                        this.programConfigurations[e].upload(t);
                    this.needsUpload = !1
                }
            }
            destroy() {
                for (const t in this.programConfigurations)
                    this.programConfigurations[t].destroy()
            }
        }
        const ma = {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern", "pixel_ratio"],
            "fill-pattern": ["pattern", "pixel_ratio"],
            "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
            "line-dasharray": ["dash"]
        };
        const fa = {
            "line-pattern": {
                source: hs,
                composite: hs
            },
            "fill-pattern": {
                source: hs,
                composite: hs
            },
            "fill-extrusion-pattern": {
                source: hs,
                composite: hs
            },
            "line-dasharray": {
                source: ds,
                composite: ds
            }
        }
          , _a = {
            color: {
                source: Cs,
                composite: us
            },
            number: {
                source: Es,
                composite: Cs
            }
        };
        function ga(t, e, i) {
            const r = fa[t];
            return r && r[i] || _a[e][i]
        }
        jn(aa, "ConstantBinder"),
        jn(la, "PatternConstantBinder"),
        jn(ca, "SourceExpressionBinder"),
        jn(ha, "PatternCompositeBinder"),
        jn(ua, "CompositeExpressionBinder"),
        jn(da, "ProgramConfiguration", {
            omit: ["_buffers"]
        }),
        jn(pa, "ProgramConfigurationSet");
        const ya = "-transition";
        class xa extends Yt {
            constructor(t, e) {
                if (super(),
                this.id = t.id,
                this.type = t.type,
                this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                },
                this._filterCompiled = !1,
                "custom" !== t.type && (this.metadata = t.metadata,
                this.minzoom = t.minzoom,
                this.maxzoom = t.maxzoom,
                "background" !== t.type && "sky" !== t.type && (this.source = t.source,
                this.sourceLayer = t["source-layer"],
                this.filter = t.filter),
                e.layout && (this._unevaluatedLayout = new qo(e.layout)),
                e.paint)) {
                    this._transitionablePaint = new Zo(e.paint);
                    for (const e in t.paint)
                        this.setPaintProperty(e, t.paint[e], {
                            validate: !1
                        });
                    for (const e in t.layout)
                        this.setLayoutProperty(e, t.layout[e], {
                            validate: !1
                        });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(),
                    this.paint = new Yo(e.paint)
                }
            }
            getLayoutProperty(t) {
                return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t)
            }
            setLayoutProperty(t, e, i={}) {
                null != e && this._validate(Rn, `layers.${this.id}.layout.${t}`, t, e, i) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e)
            }
            getPaintProperty(t) {
                return R(t, ya) ? this._transitionablePaint.getTransition(t.slice(0, -ya.length)) : this._transitionablePaint.getValue(t)
            }
            setPaintProperty(t, e, i={}) {
                if (null != e && this._validate(On, `layers.${this.id}.paint.${t}`, t, e, i))
                    return !1;
                if (R(t, ya))
                    return this._transitionablePaint.setTransition(t.slice(0, -ya.length), e || void 0),
                    !1;
                {
                    const i = this._transitionablePaint._values[t]
                      , r = i.value.isDataDriven()
                      , n = i.value;
                    this._transitionablePaint.setValue(t, e),
                    this._handleSpecialPaintPropertyUpdate(t);
                    const o = this._transitionablePaint._values[t].value
                      , s = o.isDataDriven()
                      , a = R(t, "pattern") || "line-dasharray" === t;
                    return s || r || a || this._handleOverridablePaintPropertyUpdate(t, n, o)
                }
            }
            _handleSpecialPaintPropertyUpdate(t) {}
            getProgramIds() {
                return null
            }
            getProgramConfiguration(t) {
                return null
            }
            _handleOverridablePaintPropertyUpdate(t, e, i) {
                return !1
            }
            isHidden(t) {
                return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility
            }
            updateTransitions(t) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition()
            }
            recalculate(t, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)),
                this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e)
            }
            serialize() {
                const t = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t.layout = t.layout || {},
                t.layout.visibility = this.visibility),
                F(t, ((t,e)=>!(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length)))
            }
            _validate(t, e, i, r, n={}) {
                return (!n || !1 !== n.validate) && Fn(this, t.call(Ln, {
                    key: e,
                    layerType: this.type,
                    objectKey: i,
                    value: r,
                    styleSpec: Wt,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }))
            }
            is3D() {
                return !1
            }
            isSky() {
                return !1
            }
            isTileClipped() {
                return !1
            }
            hasOffscreenPass() {
                return !1
            }
            resize() {}
            isStateDependent() {
                for (const t in this.paint._values) {
                    const e = this.paint.get(t);
                    if (e instanceof $o && Cr(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent)
                        return !0
                }
                return !1
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = sn(this.filter),
                this._filterCompiled = !0)
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature
            }
        }
        const va = ns([{
            name: "a_pos",
            components: 2,
            type: "Int16"
        }], 4)
          , ba = ns([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }, {
            name: "a_pos_normal_3",
            components: 3,
            type: "Int16"
        }]);
        class wa {
            constructor(t=[]) {
                this.segments = t
            }
            prepareSegment(t, e, i, r) {
                let n = this.segments[this.segments.length - 1];
                return t > wa.MAX_VERTEX_ARRAY_LENGTH && G(`Max vertices per segment is ${wa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),
                (!n || n.vertexLength + t > wa.MAX_VERTEX_ARRAY_LENGTH || n.sortKey !== r) && (n = {
                    vertexOffset: e.length,
                    primitiveOffset: i.length,
                    vertexLength: 0,
                    primitiveLength: 0
                },
                void 0 !== r && (n.sortKey = r),
                this.segments.push(n)),
                n
            }
            get() {
                return this.segments
            }
            destroy() {
                for (const t of this.segments)
                    for (const e in t.vaos)
                        t.vaos[e].destroy()
            }
            static simpleSegment(t, e, i, r) {
                return new wa([{
                    vertexOffset: t,
                    primitiveOffset: e,
                    vertexLength: i,
                    primitiveLength: r,
                    vaos: {},
                    sortKey: 0
                }])
            }
        }
        wa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
        jn(wa, "SegmentVector");
        var za = 8192;
        class Ta {
            constructor(t, e) {
                t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]))
            }
            setNorthEast(t) {
                return this._ne = t instanceof Sa ? new Sa(t.lng,t.lat) : Sa.convert(t),
                this
            }
            setSouthWest(t) {
                return this._sw = t instanceof Sa ? new Sa(t.lng,t.lat) : Sa.convert(t),
                this
            }
            extend(t) {
                const e = this._sw
                  , i = this._ne;
                let r, n;
                if (t instanceof Sa)
                    r = t,
                    n = t;
                else {
                    if (!(t instanceof Ta))
                        return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Ta.convert(t)) : this.extend(Sa.convert(t)) : "object" == typeof t && null !== t && t.hasOwnProperty("lat") && t.hasOwnProperty("lon") ? this.extend(Sa.convert(t)) : this;
                    if (r = t._sw,
                    n = t._ne,
                    !r || !n)
                        return this
                }
                return e || i ? (e.lng = Math.min(r.lng, e.lng),
                e.lat = Math.min(r.lat, e.lat),
                i.lng = Math.max(n.lng, i.lng),
                i.lat = Math.max(n.lat, i.lat)) : (this._sw = new Sa(r.lng,r.lat),
                this._ne = new Sa(n.lng,n.lat)),
                this
            }
            getCenter() {
                return new Sa((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
            }
            getSouthWest() {
                return this._sw
            }
            getNorthEast() {
                return this._ne
            }
            getNorthWest() {
                return new Sa(this.getWest(),this.getNorth())
            }
            getSouthEast() {
                return new Sa(this.getEast(),this.getSouth())
            }
            getWest() {
                return this._sw.lng
            }
            getSouth() {
                return this._sw.lat
            }
            getEast() {
                return this._ne.lng
            }
            getNorth() {
                return this._ne.lat
            }
            toArray() {
                return [this._sw.toArray(), this._ne.toArray()]
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
            }
            isEmpty() {
                return !(this._sw && this._ne)
            }
            contains(t) {
                const {lng: e, lat: i} = Sa.convert(t);
                let r = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (r = this._sw.lng >= e && e >= this._ne.lng),
                this._sw.lat <= i && i <= this._ne.lat && r
            }
            static convert(t) {
                return !t || t instanceof Ta ? t : new Ta(t)
            }
        }
        const Ea = 6371008.8;
        class Sa {
            constructor(t, e) {
                if (isNaN(t) || isNaN(e))
                    throw new Error(`Invalid LngLat object: (${t}, ${e})`);
                if (this.lng = +t,
                this.lat = +e,
                this.lat > 90 || this.lat < -90)
                    throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
            }
            wrap() {
                return new Sa(S(this.lng, -180, 180),this.lat)
            }
            toArray() {
                return [this.lng, this.lat]
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`
            }
            distanceTo(t) {
                const e = Math.PI / 180
                  , i = this.lat * e
                  , r = t.lat * e
                  , n = Math.sin(i) * Math.sin(r) + Math.cos(i) * Math.cos(r) * Math.cos((t.lng - this.lng) * e);
                return Ea * Math.acos(Math.min(n, 1))
            }
            toBounds(t=0) {
                const e = 360 * t / 40075017
                  , i = e / Math.cos(Math.PI / 180 * this.lat);
                return new Ta(new Sa(this.lng - i,this.lat - e),new Sa(this.lng + i,this.lat + e))
            }
            static convert(t) {
                if (t instanceof Sa)
                    return t;
                if (Array.isArray(t) && (2 === t.length || 3 === t.length))
                    return new Sa(Number(t[0]),Number(t[1]));
                if (!Array.isArray(t) && "object" == typeof t && null !== t)
                    return new Sa(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
            }
        }
        const Ma = 2 * Math.PI * Ea;
        function Aa(t) {
            return Ma * Math.cos(t * Math.PI / 180)
        }
        function Ia(t) {
            return (180 + t) / 360
        }
        function Ca(t) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360
        }
        function Da(t, e) {
            return t / Aa(e)
        }
        function ka(t) {
            return 360 * t - 180
        }
        function Pa(t) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90
        }
        function La(t, e) {
            return t * Aa(Pa(e))
        }
        const Oa = 85.051129;
        function Ra(t) {
            return 1 / Math.cos(t * Math.PI / 180)
        }
        class Ba {
            constructor(t, e, i=0) {
                this.x = +t,
                this.y = +e,
                this.z = +i
            }
            static fromLngLat(t, e=0) {
                const i = Sa.convert(t);
                return new Ba(Ia(i.lng),Ca(i.lat),Da(e, i.lat))
            }
            toLngLat() {
                return new Sa(ka(this.x),Pa(this.y))
            }
            toAltitude() {
                return La(this.z, this.y)
            }
            meterInMercatorCoordinateUnits() {
                return 1 / Ma * Ra(Pa(this.y))
            }
        }
        function Fa(t, e, i, r, n, o, s, a, l) {
            const c = (e + r) / 2
              , u = (i + n) / 2
              , h = new m(c,u);
            a(h),
            function(t, e, i, r, n, o) {
                const s = i - n
                  , a = r - o;
                return Math.abs((r - e) * s - (i - t) * a) / Math.hypot(s, a)
            }(h.x, h.y, o.x, o.y, s.x, s.y) >= l ? (Fa(t, e, i, c, u, o, h, a, l),
            Fa(t, c, u, r, n, h, s, a, l)) : t.push(s)
        }
        function Ua(t, e, i) {
            let r = t[0]
              , n = r.x
              , o = r.y;
            e(r);
            const s = [r];
            for (let a = 1; a < t.length; a++) {
                const l = t[a]
                  , {x: c, y: u} = l;
                e(l),
                Fa(s, n, o, c, u, r, l, e, i),
                n = c,
                o = u,
                r = l
            }
            return s
        }
        function Na(t, e, i, r) {
            if (r(e, i)) {
                const n = e.add(i)._mult(.5);
                Na(t, e, n, r),
                Na(t, n, i, r)
            } else
                t.push(i)
        }
        function Ga(t, e) {
            let i = t[0];
            const r = [i];
            for (let n = 1; n < t.length; n++) {
                const o = t[n];
                Na(r, i, o, e),
                i = o
            }
            return r
        }
        const ja = Math.pow(2, 14) - 1
          , Va = -ja - 1;
        function Za(t, e) {
            const i = Math.round(t.x * e)
              , r = Math.round(t.y * e);
            return t.x = T(i, Va, ja),
            t.y = T(r, Va, ja),
            (i < t.x || i > t.x + 1 || r < t.y || r > t.y + 1) && G("Geometry exceeds allowed extent, reduce your vector tile buffer size"),
            t
        }
        function Ja(t, e, i) {
            const r = t.loadGeometry()
              , n = t.extent
              , o = za / n;
            if (e && i && i.projection.isReprojectedInTileSpace) {
                const o = 1 << e.z
                  , {scale: s, x: a, y: l, projection: c} = i
                  , u = t=>{
                    const i = ka((e.x + t.x / n) / o)
                      , r = Pa((e.y + t.y / n) / o)
                      , u = c.project(i, r);
                    t.x = (u.x * s - a) * n,
                    t.y = (u.y * s - l) * n
                }
                ;
                for (let e = 0; e < r.length; e++)
                    if (1 !== t.type)
                        r[e] = Ua(r[e], u, 1);
                    else {
                        const t = [];
                        for (const i of r[e])
                            i.x < 0 || i.x >= n || i.y < 0 || i.y >= n || (u(i),
                            t.push(i));
                        r[e] = t
                    }
            }
            for (const t of r)
                for (const e of t)
                    Za(e, o);
            return r
        }
        function Xa(t, e) {
            return {
                type: t.type,
                id: t.id,
                properties: t.properties,
                geometry: e ? Ja(t) : []
            }
        }
        function qa(t, e, i, r, n) {
            t.emplaceBack(2 * e + (r + 1) / 2, 2 * i + (n + 1) / 2)
        }
        function $a(t, e, i) {
            const r = 16384;
            t.emplaceBack(e.x, e.y, e.z, i[0] * r, i[1] * r, i[2] * r)
        }
        class Ya {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t=>t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.projection = t.projection,
                this.layoutVertexArray = new ss,
                this.indexArray = new ws,
                this.segments = new wa,
                this.programConfigurations = new pa(t.layers,t.zoom),
                this.stateDependentLayerIds = this.layers.filter((t=>t.isStateDependent())).map((t=>t.id))
            }
            populate(t, e, i, r) {
                const n = this.layers[0]
                  , o = [];
                let s = null;
                "circle" === n.type && (s = n.layout.get("circle-sort-key"));
                for (const {feature: e, id: n, index: a, sourceLayerIndex: l} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , c = Xa(e, t);
                    if (!this.layers[0]._featureFilter.filter(new Go(this.zoom), c, i))
                        continue;
                    const u = s ? s.evaluate(c, {}, i) : void 0
                      , h = {
                        id: n,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: a,
                        geometry: t ? c.geometry : Ja(e, i, r),
                        patterns: {},
                        sortKey: u
                    };
                    o.push(h)
                }
                s && o.sort(((t,e)=>t.sortKey - e.sortKey));
                let a = null;
                "globe" === r.projection.name && (this.globeExtVertexArray = new ps,
                a = r.projection);
                for (const r of o) {
                    const {geometry: n, index: o, sourceLayerIndex: s} = r
                      , l = t[o].feature;
                    this.addFeature(r, n, o, e.availableImages, i, a),
                    e.featureIndex.insert(l, n, o, s, this.index)
                }
            }
            update(t, e, i, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, r)
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, va.members),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, ba.members))),
                this.programConfigurations.upload(t),
                this.uploaded = !0
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
            }
            addFeature(t, e, i, r, n, o) {
                for (const i of e)
                    for (const e of i) {
                        const i = e.x
                          , r = e.y;
                        if (i < 0 || i >= za || r < 0 || r >= za)
                            continue;
                        if (o) {
                            const t = o.projectTilePoint(i, r, n)
                              , e = o.upVector(n, i, r)
                              , s = this.globeExtVertexArray;
                            $a(s, t, e),
                            $a(s, t, e),
                            $a(s, t, e),
                            $a(s, t, e)
                        }
                        const s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey)
                          , a = s.vertexLength;
                        qa(this.layoutVertexArray, i, r, -1, -1),
                        qa(this.layoutVertexArray, i, r, 1, -1),
                        qa(this.layoutVertexArray, i, r, 1, 1),
                        qa(this.layoutVertexArray, i, r, -1, 1),
                        this.indexArray.emplaceBack(a, a + 1, a + 2),
                        this.indexArray.emplaceBack(a, a + 2, a + 3),
                        s.vertexLength += 4,
                        s.primitiveLength += 2
                    }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, {}, r, n)
            }
        }
        function Wa(t, e) {
            for (let i = 0; i < t.length; i++)
                if (ol(e, t[i]))
                    return !0;
            for (let i = 0; i < e.length; i++)
                if (ol(t, e[i]))
                    return !0;
            return !!tl(t, e)
        }
        function Ha(t, e, i) {
            return !!ol(t, e) || !!il(e, t, i)
        }
        function Ka(t, e) {
            if (1 === t.length)
                return nl(e, t[0]);
            for (let i = 0; i < e.length; i++) {
                const r = e[i];
                for (let e = 0; e < r.length; e++)
                    if (ol(t, r[e]))
                        return !0
            }
            for (let i = 0; i < t.length; i++)
                if (nl(e, t[i]))
                    return !0;
            for (let i = 0; i < e.length; i++)
                if (tl(t, e[i]))
                    return !0;
            return !1
        }
        function Qa(t, e, i) {
            if (t.length > 1) {
                if (tl(t, e))
                    return !0;
                for (let r = 0; r < e.length; r++)
                    if (il(e[r], t, i))
                        return !0
            }
            for (let r = 0; r < t.length; r++)
                if (il(t[r], e, i))
                    return !0;
            return !1
        }
        function tl(t, e) {
            if (0 === t.length || 0 === e.length)
                return !1;
            for (let i = 0; i < t.length - 1; i++) {
                const r = t[i]
                  , n = t[i + 1];
                for (let t = 0; t < e.length - 1; t++)
                    if (el(r, n, e[t], e[t + 1]))
                        return !0
            }
            return !1
        }
        function el(t, e, i, r) {
            return j(t, i, r) !== j(e, i, r) && j(t, e, i) !== j(t, e, r)
        }
        function il(t, e, i) {
            const r = i * i;
            if (1 === e.length)
                return t.distSqr(e[0]) < r;
            for (let i = 1; i < e.length; i++)
                if (rl(t, e[i - 1], e[i]) < r)
                    return !0;
            return !1
        }
        function rl(t, e, i) {
            const r = e.distSqr(i);
            if (0 === r)
                return t.distSqr(e);
            const n = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / r;
            return t.distSqr(n < 0 ? e : n > 1 ? i : i.sub(e)._mult(n)._add(e))
        }
        function nl(t, e) {
            let i, r, n, o = !1;
            for (let s = 0; s < t.length; s++) {
                i = t[s];
                for (let t = 0, s = i.length - 1; t < i.length; s = t++)
                    r = i[t],
                    n = i[s],
                    r.y > e.y != n.y > e.y && e.x < (n.x - r.x) * (e.y - r.y) / (n.y - r.y) + r.x && (o = !o)
            }
            return o
        }
        function ol(t, e) {
            let i = !1;
            for (let r = 0, n = t.length - 1; r < t.length; n = r++) {
                const o = t[r]
                  , s = t[n];
                o.y > e.y != s.y > e.y && e.x < (s.x - o.x) * (e.y - o.y) / (s.y - o.y) + o.x && (i = !i)
            }
            return i
        }
        function sl(t, e, i, r, n) {
            for (const o of t)
                if (e <= o.x && i <= o.y && r >= o.x && n >= o.y)
                    return !0;
            const o = [new m(e,i), new m(e,n), new m(r,n), new m(r,i)];
            if (t.length > 2)
                for (const e of o)
                    if (ol(t, e))
                        return !0;
            for (let e = 0; e < t.length - 1; e++)
                if (al(t[e], t[e + 1], o))
                    return !0;
            return !1
        }
        function al(t, e, i) {
            const r = i[0]
              , n = i[2];
            if (t.x < r.x && e.x < r.x || t.x > n.x && e.x > n.x || t.y < r.y && e.y < r.y || t.y > n.y && e.y > n.y)
                return !1;
            const o = j(t, e, i[0]);
            return o !== j(t, e, i[1]) || o !== j(t, e, i[2]) || o !== j(t, e, i[3])
        }
        function ll(t, e, i) {
            const r = e.paint.get(t).value;
            return "constant" === r.kind ? r.value : i.programConfigurations.get(e.id).getMaxValue(t)
        }
        function cl(t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        }
        function ul(t, e, i, r, n) {
            if (!e[0] && !e[1])
                return t;
            const o = m.convert(e)._mult(n);
            "viewport" === i && o._rotate(-r);
            const s = [];
            for (let e = 0; e < t.length; e++)
                s.push(t[e].sub(o));
            return s
        }
        function hl(t, e, i, r) {
            const n = m.convert(t)._mult(r);
            return "viewport" === e && n._rotate(-i),
            n
        }
        jn(Ya, "CircleBucket", {
            omit: ["layers"]
        });
        const dl = new Qo({
            "circle-sort-key": new Ho(Wt.layout_circle["circle-sort-key"])
        });
        var pl = {
            paint: new Qo({
                "circle-radius": new Ho(Wt.paint_circle["circle-radius"]),
                "circle-color": new Ho(Wt.paint_circle["circle-color"]),
                "circle-blur": new Ho(Wt.paint_circle["circle-blur"]),
                "circle-opacity": new Ho(Wt.paint_circle["circle-opacity"]),
                "circle-translate": new Wo(Wt.paint_circle["circle-translate"]),
                "circle-translate-anchor": new Wo(Wt.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new Wo(Wt.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new Wo(Wt.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new Ho(Wt.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new Ho(Wt.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new Ho(Wt.paint_circle["circle-stroke-opacity"])
            }),
            layout: dl
        }
          , ml = 1e-6
          , fl = "undefined" != typeof Float32Array ? Float32Array : Array;
        function _l() {
            var t = new fl(9);
            return fl != Float32Array && (t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0),
            t[0] = 1,
            t[4] = 1,
            t[8] = 1,
            t
        }
        function gl(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3]
              , a = e[4]
              , l = e[5]
              , c = e[6]
              , u = e[7]
              , h = e[8]
              , d = i[0]
              , p = i[1]
              , m = i[2]
              , f = i[3]
              , _ = i[4]
              , g = i[5]
              , y = i[6]
              , x = i[7]
              , v = i[8];
            return t[0] = d * r + p * s + m * c,
            t[1] = d * n + p * a + m * u,
            t[2] = d * o + p * l + m * h,
            t[3] = f * r + _ * s + g * c,
            t[4] = f * n + _ * a + g * u,
            t[5] = f * o + _ * l + g * h,
            t[6] = y * r + x * s + v * c,
            t[7] = y * n + x * a + v * u,
            t[8] = y * o + x * l + v * h,
            t
        }
        function yl(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = 1,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 1,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        function xl(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = e[3]
              , s = e[4]
              , a = e[5]
              , l = e[6]
              , c = e[7]
              , u = e[8]
              , h = e[9]
              , d = e[10]
              , p = e[11]
              , m = e[12]
              , f = e[13]
              , _ = e[14]
              , g = e[15]
              , y = i * a - r * s
              , x = i * l - n * s
              , v = i * c - o * s
              , b = r * l - n * a
              , w = r * c - o * a
              , z = n * c - o * l
              , T = u * f - h * m
              , E = u * _ - d * m
              , S = u * g - p * m
              , M = h * _ - d * f
              , A = h * g - p * f
              , I = d * g - p * _
              , C = y * I - x * A + v * M + b * S - w * E + z * T;
            return C ? (t[0] = (a * I - l * A + c * M) * (C = 1 / C),
            t[1] = (n * A - r * I - o * M) * C,
            t[2] = (f * z - _ * w + g * b) * C,
            t[3] = (d * w - h * z - p * b) * C,
            t[4] = (l * S - s * I - c * E) * C,
            t[5] = (i * I - n * S + o * E) * C,
            t[6] = (_ * v - m * z - g * x) * C,
            t[7] = (u * z - d * v + p * x) * C,
            t[8] = (s * A - a * S + c * T) * C,
            t[9] = (r * S - i * A - o * T) * C,
            t[10] = (m * w - f * v + g * y) * C,
            t[11] = (h * v - u * w - p * y) * C,
            t[12] = (a * E - s * M - l * T) * C,
            t[13] = (i * M - r * E + n * T) * C,
            t[14] = (f * x - m * b - _ * y) * C,
            t[15] = (u * b - h * x + d * y) * C,
            t) : null
        }
        function vl(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3]
              , a = e[4]
              , l = e[5]
              , c = e[6]
              , u = e[7]
              , h = e[8]
              , d = e[9]
              , p = e[10]
              , m = e[11]
              , f = e[12]
              , _ = e[13]
              , g = e[14]
              , y = e[15]
              , x = i[0]
              , v = i[1]
              , b = i[2]
              , w = i[3];
            return t[0] = x * r + v * a + b * h + w * f,
            t[1] = x * n + v * l + b * d + w * _,
            t[2] = x * o + v * c + b * p + w * g,
            t[3] = x * s + v * u + b * m + w * y,
            t[4] = (x = i[4]) * r + (v = i[5]) * a + (b = i[6]) * h + (w = i[7]) * f,
            t[5] = x * n + v * l + b * d + w * _,
            t[6] = x * o + v * c + b * p + w * g,
            t[7] = x * s + v * u + b * m + w * y,
            t[8] = (x = i[8]) * r + (v = i[9]) * a + (b = i[10]) * h + (w = i[11]) * f,
            t[9] = x * n + v * l + b * d + w * _,
            t[10] = x * o + v * c + b * p + w * g,
            t[11] = x * s + v * u + b * m + w * y,
            t[12] = (x = i[12]) * r + (v = i[13]) * a + (b = i[14]) * h + (w = i[15]) * f,
            t[13] = x * n + v * l + b * d + w * _,
            t[14] = x * o + v * c + b * p + w * g,
            t[15] = x * s + v * u + b * m + w * y,
            t
        }
        function bl(t, e, i) {
            var r, n, o, s, a, l, c, u, h, d, p, m, f = i[0], _ = i[1], g = i[2];
            return e === t ? (t[12] = e[0] * f + e[4] * _ + e[8] * g + e[12],
            t[13] = e[1] * f + e[5] * _ + e[9] * g + e[13],
            t[14] = e[2] * f + e[6] * _ + e[10] * g + e[14],
            t[15] = e[3] * f + e[7] * _ + e[11] * g + e[15]) : (n = e[1],
            o = e[2],
            s = e[3],
            a = e[4],
            l = e[5],
            c = e[6],
            u = e[7],
            h = e[8],
            d = e[9],
            p = e[10],
            m = e[11],
            t[0] = r = e[0],
            t[1] = n,
            t[2] = o,
            t[3] = s,
            t[4] = a,
            t[5] = l,
            t[6] = c,
            t[7] = u,
            t[8] = h,
            t[9] = d,
            t[10] = p,
            t[11] = m,
            t[12] = r * f + a * _ + h * g + e[12],
            t[13] = n * f + l * _ + d * g + e[13],
            t[14] = o * f + c * _ + p * g + e[14],
            t[15] = s * f + u * _ + m * g + e[15]),
            t
        }
        function wl(t, e, i) {
            var r = i[0]
              , n = i[1]
              , o = i[2];
            return t[0] = e[0] * r,
            t[1] = e[1] * r,
            t[2] = e[2] * r,
            t[3] = e[3] * r,
            t[4] = e[4] * n,
            t[5] = e[5] * n,
            t[6] = e[6] * n,
            t[7] = e[7] * n,
            t[8] = e[8] * o,
            t[9] = e[9] * o,
            t[10] = e[10] * o,
            t[11] = e[11] * o,
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15],
            t
        }
        function zl(t, e, i) {
            var r = Math.sin(i)
              , n = Math.cos(i)
              , o = e[4]
              , s = e[5]
              , a = e[6]
              , l = e[7]
              , c = e[8]
              , u = e[9]
              , h = e[10]
              , d = e[11];
            return e !== t && (t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[4] = o * n + c * r,
            t[5] = s * n + u * r,
            t[6] = a * n + h * r,
            t[7] = l * n + d * r,
            t[8] = c * n - o * r,
            t[9] = u * n - s * r,
            t[10] = h * n - a * r,
            t[11] = d * n - l * r,
            t
        }
        function Tl(t, e, i) {
            var r = Math.sin(i)
              , n = Math.cos(i)
              , o = e[0]
              , s = e[1]
              , a = e[2]
              , l = e[3]
              , c = e[8]
              , u = e[9]
              , h = e[10]
              , d = e[11];
            return e !== t && (t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[0] = o * n - c * r,
            t[1] = s * n - u * r,
            t[2] = a * n - h * r,
            t[3] = l * n - d * r,
            t[8] = o * r + c * n,
            t[9] = s * r + u * n,
            t[10] = a * r + h * n,
            t[11] = l * r + d * n,
            t
        }
        function El(t, e) {
            return t[0] = e[0],
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = e[1],
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = e[2],
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        function Sl(t, e, i) {
            var r, n, o, s = i[0], a = i[1], l = i[2], c = Math.hypot(s, a, l);
            return c < ml ? null : (s *= c = 1 / c,
            a *= c,
            l *= c,
            r = Math.sin(e),
            n = Math.cos(e),
            t[0] = s * s * (o = 1 - n) + n,
            t[1] = a * s * o + l * r,
            t[2] = l * s * o - a * r,
            t[3] = 0,
            t[4] = s * a * o - l * r,
            t[5] = a * a * o + n,
            t[6] = l * a * o + s * r,
            t[7] = 0,
            t[8] = s * l * o + a * r,
            t[9] = a * l * o - s * r,
            t[10] = l * l * o + n,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t)
        }
        Math.hypot || (Math.hypot = function() {
            for (var t = 0, e = arguments.length; e--; )
                t += arguments[e] * arguments[e];
            return Math.sqrt(t)
        }
        );
        var Ml = vl;
        function Al() {
            var t = new fl(3);
            return fl != Float32Array && (t[0] = 0,
            t[1] = 0,
            t[2] = 0),
            t
        }
        function Il(t) {
            var e = new fl(3);
            return e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e
        }
        function Cl(t) {
            return Math.hypot(t[0], t[1], t[2])
        }
        function Dl(t, e, i) {
            var r = new fl(3);
            return r[0] = t,
            r[1] = e,
            r[2] = i,
            r
        }
        function kl(t, e, i) {
            return t[0] = e[0] + i[0],
            t[1] = e[1] + i[1],
            t[2] = e[2] + i[2],
            t
        }
        function Pl(t, e, i) {
            return t[0] = e[0] - i[0],
            t[1] = e[1] - i[1],
            t[2] = e[2] - i[2],
            t
        }
        function Ll(t, e, i) {
            return t[0] = e[0] * i[0],
            t[1] = e[1] * i[1],
            t[2] = e[2] * i[2],
            t
        }
        function Ol(t, e, i) {
            return t[0] = Math.min(e[0], i[0]),
            t[1] = Math.min(e[1], i[1]),
            t[2] = Math.min(e[2], i[2]),
            t
        }
        function Rl(t, e, i) {
            return t[0] = Math.max(e[0], i[0]),
            t[1] = Math.max(e[1], i[1]),
            t[2] = Math.max(e[2], i[2]),
            t
        }
        function Bl(t, e, i) {
            return t[0] = e[0] * i,
            t[1] = e[1] * i,
            t[2] = e[2] * i,
            t
        }
        function Fl(t, e, i, r) {
            return t[0] = e[0] + i[0] * r,
            t[1] = e[1] + i[1] * r,
            t[2] = e[2] + i[2] * r,
            t
        }
        function Ul(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = i * i + r * r + n * n;
            return o > 0 && (o = 1 / Math.sqrt(o)),
            t[0] = e[0] * o,
            t[1] = e[1] * o,
            t[2] = e[2] * o,
            t
        }
        function Nl(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
        }
        function Gl(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = i[0]
              , a = i[1]
              , l = i[2];
            return t[0] = n * l - o * a,
            t[1] = o * s - r * l,
            t[2] = r * a - n * s,
            t
        }
        function jl(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = i[3] * r + i[7] * n + i[11] * o + i[15];
            return t[0] = (i[0] * r + i[4] * n + i[8] * o + i[12]) / (s = s || 1),
            t[1] = (i[1] * r + i[5] * n + i[9] * o + i[13]) / s,
            t[2] = (i[2] * r + i[6] * n + i[10] * o + i[14]) / s,
            t
        }
        function Vl(t, e, i) {
            var r = i[0]
              , n = i[1]
              , o = i[2]
              , s = e[0]
              , a = e[1]
              , l = e[2]
              , c = n * l - o * a
              , u = o * s - r * l
              , h = r * a - n * s
              , d = n * h - o * u
              , p = o * c - r * h
              , m = r * u - n * c
              , f = 2 * i[3];
            return u *= f,
            h *= f,
            p *= 2,
            m *= 2,
            t[0] = s + (c *= f) + (d *= 2),
            t[1] = a + u + p,
            t[2] = l + h + m,
            t
        }
        var Zl, Jl = Pl, Xl = Ll, ql = Cl;
        function $l(t, e, i) {
            return t[0] = e[0] * i,
            t[1] = e[1] * i,
            t[2] = e[2] * i,
            t[3] = e[3] * i,
            t
        }
        function Yl(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = e[3]
              , s = i * i + r * r + n * n + o * o;
            return s > 0 && (s = 1 / Math.sqrt(s)),
            t[0] = i * s,
            t[1] = r * s,
            t[2] = n * s,
            t[3] = o * s,
            t
        }
        function Wl(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3];
            return t[0] = i[0] * r + i[4] * n + i[8] * o + i[12] * s,
            t[1] = i[1] * r + i[5] * n + i[9] * o + i[13] * s,
            t[2] = i[2] * r + i[6] * n + i[10] * o + i[14] * s,
            t[3] = i[3] * r + i[7] * n + i[11] * o + i[15] * s,
            t
        }
        function Hl() {
            var t = new fl(4);
            return fl != Float32Array && (t[0] = 0,
            t[1] = 0,
            t[2] = 0),
            t[3] = 1,
            t
        }
        function Kl(t) {
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        function Ql(t, e, i) {
            i *= .5;
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3]
              , a = Math.sin(i)
              , l = Math.cos(i);
            return t[0] = r * l + s * a,
            t[1] = n * l + o * a,
            t[2] = o * l - n * a,
            t[3] = s * l - r * a,
            t
        }
        function tc(t, e, i) {
            i *= .5;
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3]
              , a = Math.sin(i)
              , l = Math.cos(i);
            return t[0] = r * l - o * a,
            t[1] = n * l + s * a,
            t[2] = o * l + r * a,
            t[3] = s * l - n * a,
            t
        }
        Al(),
        Zl = new fl(4),
        fl != Float32Array && (Zl[0] = 0,
        Zl[1] = 0,
        Zl[2] = 0,
        Zl[3] = 0);
        var ec = Yl;
        Al(),
        Dl(1, 0, 0),
        Dl(0, 1, 0),
        Hl(),
        Hl(),
        _l();
        class ic {
            constructor(t, e) {
                this.pos = t,
                this.dir = e
            }
            intersectsPlane(t, e, i) {
                const r = Nl(e, this.dir);
                if (Math.abs(r) < 1e-6)
                    return !1;
                const n = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / r;
                return i[0] = this.pos[0] + this.dir[0] * n,
                i[1] = this.pos[1] + this.dir[1] * n,
                i[2] = this.pos[2] + this.dir[2] * n,
                !0
            }
            closestPointOnSphere(t, e, i) {
                if (r = this.pos,
                n = t,
                o = r[0],
                s = r[1],
                a = r[2],
                l = n[0],
                c = n[1],
                u = n[2],
                Math.abs(o - l) <= ml * Math.max(1, Math.abs(o), Math.abs(l)) && Math.abs(s - c) <= ml * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(a - u) <= ml * Math.max(1, Math.abs(a), Math.abs(u)) || 0 === e)
                    return i[0] = i[1] = i[2] = 0,
                    !1;
                var r, n, o, s, a, l, c, u;
                const [h,d,p] = this.dir
                  , m = this.pos[0] - t[0]
                  , f = this.pos[1] - t[1]
                  , _ = this.pos[2] - t[2]
                  , g = h * h + d * d + p * p
                  , y = 2 * (m * h + f * d + _ * p)
                  , x = y * y - 4 * g * (m * m + f * f + _ * _ - e * e);
                if (x < 0) {
                    const t = Math.max(-y / 2, 0)
                      , r = m + h * t
                      , n = f + d * t
                      , o = _ + p * t
                      , s = Math.hypot(r, n, o);
                    return i[0] = r * e / s,
                    i[1] = n * e / s,
                    i[2] = o * e / s,
                    !1
                }
                {
                    const t = (-y - Math.sqrt(x)) / (2 * g);
                    if (t < 0) {
                        const t = Math.hypot(m, f, _);
                        return i[0] = m * e / t,
                        i[1] = f * e / t,
                        i[2] = _ * e / t,
                        !1
                    }
                    return i[0] = m + h * t,
                    i[1] = f + d * t,
                    i[2] = _ + p * t,
                    !0
                }
            }
        }
        class rc {
            constructor(t, e, i, r, n) {
                this.TL = t,
                this.TR = e,
                this.BR = i,
                this.BL = r,
                this.horizon = n
            }
            static fromInvProjectionMatrix(t, e, i) {
                const r = [-1, 1, 1]
                  , n = [1, 1, 1]
                  , o = [1, -1, 1]
                  , s = [-1, -1, 1]
                  , a = jl(r, r, t)
                  , l = jl(n, n, t)
                  , c = jl(o, o, t)
                  , u = jl(s, s, t);
                return new rc(a,l,c,u,e / i)
            }
        }
        class nc {
            constructor(t, e) {
                this.points = t,
                this.planes = e
            }
            static fromInvProjectionMatrix(t, e, i, r) {
                const n = Math.pow(2, i)
                  , o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((i=>{
                    const o = Wl([], i, t)
                      , s = 1 / o[3] / e * n;
                    return a = o,
                    l = o,
                    c = [s, s, r ? 1 / o[3] : s, s],
                    a[0] = l[0] * c[0],
                    a[1] = l[1] * c[1],
                    a[2] = l[2] * c[2],
                    a[3] = l[3] * c[3],
                    a;
                    var a, l, c
                }
                ))
                  , s = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t=>{
                    const e = Ul([], Gl([], Jl([], o[t[0]], o[t[1]]), Jl([], o[t[2]], o[t[1]])))
                      , i = -Nl(e, o[t[1]]);
                    return e.concat(i)
                }
                ));
                return new nc(o,s)
            }
        }
        class oc {
            static fromPoints(t) {
                const e = [1 / 0, 1 / 0, 1 / 0]
                  , i = [-1 / 0, -1 / 0, -1 / 0];
                for (const r of t)
                    Ol(e, e, r),
                    Rl(i, i, r);
                return new oc(e,i)
            }
            static applyTransform(t, e) {
                const i = t.getCorners();
                for (let t = 0; t < i.length; ++t)
                    jl(i[t], i[t], e);
                return oc.fromPoints(i)
            }
            constructor(t, e) {
                this.min = t,
                this.max = e,
                this.center = Bl([], kl([], this.min, this.max), .5)
            }
            quadrant(t) {
                const e = [t % 2 == 0, t < 2]
                  , i = Il(this.min)
                  , r = Il(this.max);
                for (let t = 0; t < e.length; t++)
                    i[t] = e[t] ? this.min[t] : this.center[t],
                    r[t] = e[t] ? this.center[t] : this.max[t];
                return r[2] = this.max[2],
                new oc(i,r)
            }
            distanceX(t) {
                return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0]
            }
            distanceY(t) {
                return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1]
            }
            distanceZ(t) {
                return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2]
            }
            getCorners() {
                const t = this.min
                  , e = this.max;
                return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]]
            }
            intersects(t) {
                const e = this.getCorners();
                let i = !0;
                for (let r = 0; r < t.planes.length; r++) {
                    const n = t.planes[r];
                    let o = 0;
                    for (let t = 0; t < e.length; t++)
                        o += Nl(n, e[t]) + n[3] >= 0;
                    if (0 === o)
                        return 0;
                    o !== e.length && (i = !1)
                }
                if (i)
                    return 2;
                for (let e = 0; e < 3; e++) {
                    let i = Number.MAX_VALUE
                      , r = -Number.MAX_VALUE;
                    for (let n = 0; n < t.points.length; n++) {
                        const o = t.points[n][e] - this.min[e];
                        i = Math.min(i, o),
                        r = Math.max(r, o)
                    }
                    if (r < 0 || i > this.max[e] - this.min[e])
                        return 0
                }
                return 1
            }
        }
        function sc(t, e, i, r, n, o, s, a, l) {
            if (o && t.queryGeometry.isAboveHorizon)
                return !1;
            o && (l *= t.pixelToTileUnitsFactor);
            const c = t.tileID.canonical
              , u = i.projection.upVectorScale(c, i.center.lat, i.worldSize).metersToTile;
            for (const h of e)
                for (const e of h) {
                    const h = e.add(a)
                      , d = n && i.elevation ? i.elevation.exaggeration() * n.getElevationAt(h.x, h.y, !0) : 0
                      , p = i.projection.projectTilePoint(h.x, h.y, c);
                    if (d > 0) {
                        const t = i.projection.upVector(c, h.x, h.y);
                        p.x += t[0] * u * d,
                        p.y += t[1] * u * d,
                        p.z += t[2] * u * d
                    }
                    const m = o ? h : ac(p.x, p.y, p.z, r)
                      , f = o ? t.tilespaceRays.map((t=>uc(t, d))) : t.queryGeometry.screenGeometry
                      , _ = Wl([], [p.x, p.y, p.z, 1], r);
                    if (!s && o ? l *= _[3] / i.cameraToCenterDistance : s && !o && (l *= i.cameraToCenterDistance / _[3]),
                    o) {
                        const t = Pa((e.y / za + c.y) / (1 << c.z));
                        l /= i.projection.pixelsPerMeter(t, 1) / Da(1, t)
                    }
                    if (Ha(f, m, l))
                        return !0
                }
            return !1
        }
        function ac(t, e, i, r) {
            const n = Wl([], [t, e, i, 1], r);
            return new m(n[0] / n[3],n[1] / n[3])
        }
        const lc = Dl(0, 0, 0)
          , cc = Dl(0, 0, 1);
        function uc(t, e) {
            const i = Al();
            return lc[2] = e,
            t.intersectsPlane(lc, cc, i),
            new m(i[0],i[1])
        }
        class hc extends Ya {
        }
        function dc(t, {width: e, height: i}, r, n) {
            if (n) {
                if (n instanceof Uint8ClampedArray)
                    n = new Uint8Array(n.buffer);
                else if (n.length !== e * i * r)
                    throw new RangeError("mismatched image size")
            } else
                n = new Uint8Array(e * i * r);
            return t.width = e,
            t.height = i,
            t.data = n,
            t
        }
        function pc(t, e, i) {
            const {width: r, height: n} = e;
            r === t.width && n === t.height || (mc(t, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t.width, r),
                height: Math.min(t.height, n)
            }, i),
            t.width = r,
            t.height = n,
            t.data = e.data)
        }
        function mc(t, e, i, r, n, o) {
            if (0 === n.width || 0 === n.height)
                return e;
            if (n.width > t.width || n.height > t.height || i.x > t.width - n.width || i.y > t.height - n.height)
                throw new RangeError("out of range source coordinates for image copy");
            if (n.width > e.width || n.height > e.height || r.x > e.width - n.width || r.y > e.height - n.height)
                throw new RangeError("out of range destination coordinates for image copy");
            const s = t.data
              , a = e.data;
            for (let l = 0; l < n.height; l++) {
                const c = ((i.y + l) * t.width + i.x) * o
                  , u = ((r.y + l) * e.width + r.x) * o;
                for (let t = 0; t < n.width * o; t++)
                    a[u + t] = s[c + t]
            }
            return e
        }
        jn(hc, "HeatmapBucket", {
            omit: ["layers"]
        });
        class fc {
            constructor(t, e) {
                dc(this, t, 1, e)
            }
            resize(t) {
                pc(this, new fc(t), 1)
            }
            clone() {
                return new fc({
                    width: this.width,
                    height: this.height
                },new Uint8Array(this.data))
            }
            static copy(t, e, i, r, n) {
                mc(t, e, i, r, n, 1)
            }
        }
        class _c {
            constructor(t, e) {
                dc(this, t, 4, e)
            }
            resize(t) {
                pc(this, new _c(t), 4)
            }
            replace(t, e) {
                e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
            }
            clone() {
                return new _c({
                    width: this.width,
                    height: this.height
                },new Uint8Array(this.data))
            }
            static copy(t, e, i, r, n) {
                mc(t, e, i, r, n, 4)
            }
        }
        jn(fc, "AlphaImage"),
        jn(_c, "RGBAImage");
        var gc = {
            paint: new Qo({
                "heatmap-radius": new Ho(Wt.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new Ho(Wt.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new Wo(Wt.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new Ko(Wt.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new Wo(Wt.paint_heatmap["heatmap-opacity"])
            })
        };
        function yc(t) {
            const e = {}
              , i = t.resolution || 256
              , r = t.clips ? t.clips.length : 1
              , n = t.image || new _c({
                width: i,
                height: r
            })
              , o = (i,r,o)=>{
                e[t.evaluationKey] = o;
                const s = t.expression.evaluate(e);
                n.data[i + r + 0] = Math.floor(255 * s.r / s.a),
                n.data[i + r + 1] = Math.floor(255 * s.g / s.a),
                n.data[i + r + 2] = Math.floor(255 * s.b / s.a),
                n.data[i + r + 3] = Math.floor(255 * s.a)
            }
            ;
            if (t.clips)
                for (let e = 0, n = 0; e < r; ++e,
                n += 4 * i)
                    for (let r = 0, s = 0; r < i; r++,
                    s += 4) {
                        const a = r / (i - 1)
                          , {start: l, end: c} = t.clips[e];
                        o(n, s, l * (1 - a) + c * a)
                    }
            else
                for (let t = 0, e = 0; t < i; t++,
                e += 4)
                    o(0, e, t / (i - 1));
            return n
        }
        var xc = {
            paint: new Qo({
                "hillshade-illumination-direction": new Wo(Wt.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new Wo(Wt.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new Wo(Wt.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new Wo(Wt.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new Wo(Wt.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new Wo(Wt.paint_hillshade["hillshade-accent-color"])
            })
        };
        const vc = ns([{
            name: "a_pos",
            components: 2,
            type: "Int16"
        }], 4)
          , {members: bc} = vc;
        var wc = {
            exports: {}
        };
        function zc(t, e, i) {
            i = i || 2;
            var r, n, o, s, a, l, c, u = e && e.length, h = u ? e[0] * i : t.length, d = Tc(t, 0, h, i, !0), p = [];
            if (!d || d.next === d.prev)
                return p;
            if (u && (d = function(t, e, i, r) {
                var n, o, s, a = [];
                for (n = 0,
                o = e.length; n < o; n++)
                    (s = Tc(t, e[n] * r, n < o - 1 ? e[n + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0),
                    a.push(Oc(s));
                for (a.sort(Dc),
                n = 0; n < a.length; n++)
                    i = kc(a[n], i);
                return i
            }(t, e, d, i)),
            t.length > 80 * i) {
                r = o = t[0],
                n = s = t[1];
                for (var m = i; m < h; m += i)
                    (a = t[m]) < r && (r = a),
                    (l = t[m + 1]) < n && (n = l),
                    a > o && (o = a),
                    l > s && (s = l);
                c = 0 !== (c = Math.max(o - r, s - n)) ? 32767 / c : 0
            }
            return Sc(d, p, i, r, n, c, 0),
            p
        }
        function Tc(t, e, i, r, n) {
            var o, s;
            if (n === qc(t, e, i, r) > 0)
                for (o = e; o < i; o += r)
                    s = Zc(o, t[o], t[o + 1], s);
            else
                for (o = i - r; o >= e; o -= r)
                    s = Zc(o, t[o], t[o + 1], s);
            return s && Fc(s, s.next) && (Jc(s),
            s = s.next),
            s
        }
        function Ec(t, e) {
            if (!t)
                return t;
            e || (e = t);
            var i, r = t;
            do {
                if (i = !1,
                r.steiner || !Fc(r, r.next) && 0 !== Bc(r.prev, r, r.next))
                    r = r.next;
                else {
                    if (Jc(r),
                    (r = e = r.prev) === r.next)
                        break;
                    i = !0
                }
            } while (i || r !== e);
            return e
        }
        function Sc(t, e, i, r, n, o, s) {
            if (t) {
                !s && o && function(t, e, i, r) {
                    var n = t;
                    do {
                        0 === n.z && (n.z = Lc(n.x, n.y, e, i, r)),
                        n.prevZ = n.prev,
                        n.nextZ = n.next,
                        n = n.next
                    } while (n !== t);
                    n.prevZ.nextZ = null,
                    n.prevZ = null,
                    function(t) {
                        var e, i, r, n, o, s, a, l, c = 1;
                        do {
                            for (i = t,
                            t = null,
                            o = null,
                            s = 0; i; ) {
                                for (s++,
                                r = i,
                                a = 0,
                                e = 0; e < c && (a++,
                                r = r.nextZ); e++)
                                    ;
                                for (l = c; a > 0 || l > 0 && r; )
                                    0 !== a && (0 === l || !r || i.z <= r.z) ? (n = i,
                                    i = i.nextZ,
                                    a--) : (n = r,
                                    r = r.nextZ,
                                    l--),
                                    o ? o.nextZ = n : t = n,
                                    n.prevZ = o,
                                    o = n;
                                i = r
                            }
                            o.nextZ = null,
                            c *= 2
                        } while (s > 1)
                    }(n)
                }(t, r, n, o);
                for (var a, l, c = t; t.prev !== t.next; )
                    if (a = t.prev,
                    l = t.next,
                    o ? Ac(t, r, n, o) : Mc(t))
                        e.push(a.i / i | 0),
                        e.push(t.i / i | 0),
                        e.push(l.i / i | 0),
                        Jc(t),
                        t = l.next,
                        c = l.next;
                    else if ((t = l) === c) {
                        s ? 1 === s ? Sc(t = Ic(Ec(t), e, i), e, i, r, n, o, 2) : 2 === s && Cc(t, e, i, r, n, o) : Sc(Ec(t), e, i, r, n, o, 1);
                        break
                    }
            }
        }
        function Mc(t) {
            var e = t.prev
              , i = t
              , r = t.next;
            if (Bc(e, i, r) >= 0)
                return !1;
            for (var n = e.x, o = i.x, s = r.x, a = e.y, l = i.y, c = r.y, u = n < o ? n < s ? n : s : o < s ? o : s, h = a < l ? a < c ? a : c : l < c ? l : c, d = n > o ? n > s ? n : s : o > s ? o : s, p = a > l ? a > c ? a : c : l > c ? l : c, m = r.next; m !== e; ) {
                if (m.x >= u && m.x <= d && m.y >= h && m.y <= p && Rc(n, a, o, l, s, c, m.x, m.y) && Bc(m.prev, m, m.next) >= 0)
                    return !1;
                m = m.next
            }
            return !0
        }
        function Ac(t, e, i, r) {
            var n = t.prev
              , o = t
              , s = t.next;
            if (Bc(n, o, s) >= 0)
                return !1;
            for (var a = n.x, l = o.x, c = s.x, u = n.y, h = o.y, d = s.y, p = a < l ? a < c ? a : c : l < c ? l : c, m = u < h ? u < d ? u : d : h < d ? h : d, f = a > l ? a > c ? a : c : l > c ? l : c, _ = u > h ? u > d ? u : d : h > d ? h : d, g = Lc(p, m, e, i, r), y = Lc(f, _, e, i, r), x = t.prevZ, v = t.nextZ; x && x.z >= g && v && v.z <= y; ) {
                if (x.x >= p && x.x <= f && x.y >= m && x.y <= _ && x !== n && x !== s && Rc(a, u, l, h, c, d, x.x, x.y) && Bc(x.prev, x, x.next) >= 0)
                    return !1;
                if (x = x.prevZ,
                v.x >= p && v.x <= f && v.y >= m && v.y <= _ && v !== n && v !== s && Rc(a, u, l, h, c, d, v.x, v.y) && Bc(v.prev, v, v.next) >= 0)
                    return !1;
                v = v.nextZ
            }
            for (; x && x.z >= g; ) {
                if (x.x >= p && x.x <= f && x.y >= m && x.y <= _ && x !== n && x !== s && Rc(a, u, l, h, c, d, x.x, x.y) && Bc(x.prev, x, x.next) >= 0)
                    return !1;
                x = x.prevZ
            }
            for (; v && v.z <= y; ) {
                if (v.x >= p && v.x <= f && v.y >= m && v.y <= _ && v !== n && v !== s && Rc(a, u, l, h, c, d, v.x, v.y) && Bc(v.prev, v, v.next) >= 0)
                    return !1;
                v = v.nextZ
            }
            return !0
        }
        function Ic(t, e, i) {
            var r = t;
            do {
                var n = r.prev
                  , o = r.next.next;
                !Fc(n, o) && Uc(n, r, r.next, o) && jc(n, o) && jc(o, n) && (e.push(n.i / i | 0),
                e.push(r.i / i | 0),
                e.push(o.i / i | 0),
                Jc(r),
                Jc(r.next),
                r = t = o),
                r = r.next
            } while (r !== t);
            return Ec(r)
        }
        function Cc(t, e, i, r, n, o) {
            var s, a, l = t;
            do {
                for (var c = l.next.next; c !== l.prev; ) {
                    if (l.i !== c.i && (a = c,
                    (s = l).next.i !== a.i && s.prev.i !== a.i && !function(t, e) {
                        var i = t;
                        do {
                            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Uc(i, i.next, t, e))
                                return !0;
                            i = i.next
                        } while (i !== t);
                        return !1
                    }(s, a) && (jc(s, a) && jc(a, s) && function(t, e) {
                        var i = t
                          , r = !1
                          , n = (t.x + e.x) / 2
                          , o = (t.y + e.y) / 2;
                        do {
                            i.y > o != i.next.y > o && i.next.y !== i.y && n < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (r = !r),
                            i = i.next
                        } while (i !== t);
                        return r
                    }(s, a) && (Bc(s.prev, s, a.prev) || Bc(s, a.prev, a)) || Fc(s, a) && Bc(s.prev, s, s.next) > 0 && Bc(a.prev, a, a.next) > 0))) {
                        var u = Vc(l, c);
                        return l = Ec(l, l.next),
                        u = Ec(u, u.next),
                        Sc(l, e, i, r, n, o, 0),
                        void Sc(u, e, i, r, n, o, 0)
                    }
                    c = c.next
                }
                l = l.next
            } while (l !== t)
        }
        function Dc(t, e) {
            return t.x - e.x
        }
        function kc(t, e) {
            var i = function(t, e) {
                var i, r = e, n = t.x, o = t.y, s = -1 / 0;
                do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                        var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (a <= n && a > s && (s = a,
                        i = r.x < r.next.x ? r : r.next,
                        a === n))
                            return i
                    }
                    r = r.next
                } while (r !== e);
                if (!i)
                    return null;
                var l, c = i, u = i.x, h = i.y, d = 1 / 0;
                r = i;
                do {
                    n >= r.x && r.x >= u && n !== r.x && Rc(o < h ? n : s, o, u, h, o < h ? s : n, o, r.x, r.y) && (l = Math.abs(o - r.y) / (n - r.x),
                    jc(r, t) && (l < d || l === d && (r.x > i.x || r.x === i.x && Pc(i, r))) && (i = r,
                    d = l)),
                    r = r.next
                } while (r !== c);
                return i
            }(t, e);
            if (!i)
                return e;
            var r = Vc(i, t);
            return Ec(r, r.next),
            Ec(i, i.next)
        }
        function Pc(t, e) {
            return Bc(t.prev, t, e.prev) < 0 && Bc(e.next, t, t.next) < 0
        }
        function Lc(t, e, i, r, n) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * n | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function Oc(t) {
            var e = t
              , i = t;
            do {
                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
                e = e.next
            } while (e !== t);
            return i
        }
        function Rc(t, e, i, r, n, o, s, a) {
            return (n - s) * (e - a) >= (t - s) * (o - a) && (t - s) * (r - a) >= (i - s) * (e - a) && (i - s) * (o - a) >= (n - s) * (r - a)
        }
        function Bc(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }
        function Fc(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function Uc(t, e, i, r) {
            var n = Gc(Bc(t, e, i))
              , o = Gc(Bc(t, e, r))
              , s = Gc(Bc(i, r, t))
              , a = Gc(Bc(i, r, e));
            return n !== o && s !== a || !(0 !== n || !Nc(t, i, e)) || !(0 !== o || !Nc(t, r, e)) || !(0 !== s || !Nc(i, t, r)) || !(0 !== a || !Nc(i, e, r))
        }
        function Nc(t, e, i) {
            return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
        }
        function Gc(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function jc(t, e) {
            return Bc(t.prev, t, t.next) < 0 ? Bc(t, e, t.next) >= 0 && Bc(t, t.prev, e) >= 0 : Bc(t, e, t.prev) < 0 || Bc(t, t.next, e) < 0
        }
        function Vc(t, e) {
            var i = new Xc(t.i,t.x,t.y)
              , r = new Xc(e.i,e.x,e.y)
              , n = t.next
              , o = e.prev;
            return t.next = e,
            e.prev = t,
            i.next = n,
            n.prev = i,
            r.next = i,
            i.prev = r,
            o.next = r,
            r.prev = o,
            r
        }
        function Zc(t, e, i, r) {
            var n = new Xc(t,e,i);
            return r ? (n.next = r.next,
            n.prev = r,
            r.next.prev = n,
            r.next = n) : (n.prev = n,
            n.next = n),
            n
        }
        function Jc(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Xc(t, e, i) {
            this.i = t,
            this.x = e,
            this.y = i,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        function qc(t, e, i, r) {
            for (var n = 0, o = e, s = i - r; o < i; o += r)
                n += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
                s = o;
            return n
        }
        function $c(t, e, i, r, n) {
            Yc(t, e, i || 0, r || t.length - 1, n || Hc)
        }
        function Yc(t, e, i, r, n) {
            for (; r > i; ) {
                if (r - i > 600) {
                    var o = r - i + 1
                      , s = e - i + 1
                      , a = Math.log(o)
                      , l = .5 * Math.exp(2 * a / 3)
                      , c = .5 * Math.sqrt(a * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);
                    Yc(t, e, Math.max(i, Math.floor(e - s * l / o + c)), Math.min(r, Math.floor(e + (o - s) * l / o + c)), n)
                }
                var u = t[e]
                  , h = i
                  , d = r;
                for (Wc(t, i, e),
                n(t[r], u) > 0 && Wc(t, i, r); h < d; ) {
                    for (Wc(t, h, d),
                    h++,
                    d--; n(t[h], u) < 0; )
                        h++;
                    for (; n(t[d], u) > 0; )
                        d--
                }
                0 === n(t[i], u) ? Wc(t, i, d) : Wc(t, ++d, r),
                d <= e && (i = d + 1),
                e <= d && (r = d - 1)
            }
        }
        function Wc(t, e, i) {
            var r = t[e];
            t[e] = t[i],
            t[i] = r
        }
        function Hc(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function Kc(t, e) {
            const i = t.length;
            if (i <= 1)
                return [t];
            const r = [];
            let n, o;
            for (let e = 0; e < i; e++) {
                const i = V(t[e]);
                0 !== i && (t[e].area = Math.abs(i),
                void 0 === o && (o = i < 0),
                o === i < 0 ? (n && r.push(n),
                n = [t[e]]) : n.push(t[e]))
            }
            if (n && r.push(n),
            e > 1)
                for (let t = 0; t < r.length; t++)
                    r[t].length <= e || ($c(r[t], e, 1, r[t].length - 1, Qc),
                    r[t] = r[t].slice(0, e));
            return r
        }
        function Qc(t, e) {
            return e.area - t.area
        }
        function tu(t, e, i) {
            const r = i.patternDependencies;
            let n = !1;
            for (const i of e) {
                const e = i.paint.get(`${t}-pattern`);
                e.isConstant() || (n = !0);
                const o = e.constantOr(null);
                o && (n = !0,
                r[o] = !0)
            }
            return n
        }
        function eu(t, e, i, r, n) {
            const o = n.patternDependencies;
            for (const s of e) {
                const e = s.paint.get(`${t}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t = e.evaluate({
                        zoom: r
                    }, i, {}, n.availableImages);
                    t = t && t.name ? t.name : t,
                    o[t] = !0,
                    i.patterns[s.id] = t
                }
            }
            return i
        }
        wc.exports = zc,
        wc.exports.default = zc,
        zc.deviation = function(t, e, i, r) {
            var n = e && e.length
              , o = Math.abs(qc(t, 0, n ? e[0] * i : t.length, i));
            if (n)
                for (var s = 0, a = e.length; s < a; s++)
                    o -= Math.abs(qc(t, e[s] * i, s < a - 1 ? e[s + 1] * i : t.length, i));
            var l = 0;
            for (s = 0; s < r.length; s += 3) {
                var c = r[s] * i
                  , u = r[s + 1] * i
                  , h = r[s + 2] * i;
                l += Math.abs((t[c] - t[h]) * (t[u + 1] - t[c + 1]) - (t[c] - t[u]) * (t[h + 1] - t[c + 1]))
            }
            return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o)
        }
        ,
        zc.flatten = function(t) {
            for (var e = t[0][0].length, i = {
                vertices: [],
                holes: [],
                dimensions: e
            }, r = 0, n = 0; n < t.length; n++) {
                for (var o = 0; o < t[n].length; o++)
                    for (var s = 0; s < e; s++)
                        i.vertices.push(t[n][o][s]);
                n > 0 && i.holes.push(r += t[n - 1].length)
            }
            return i
        }
        ;
        class iu {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t=>t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.patternFeatures = [],
                this.layoutVertexArray = new ss,
                this.indexArray = new ws,
                this.indexArray2 = new As,
                this.programConfigurations = new pa(t.layers,t.zoom),
                this.segments = new wa,
                this.segments2 = new wa,
                this.stateDependentLayerIds = this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),
                this.projection = t.projection
            }
            populate(t, e, i, r) {
                this.hasPattern = tu("fill", this.layers, e);
                const n = this.layers[0].layout.get("fill-sort-key")
                  , o = [];
                for (const {feature: s, id: a, index: l, sourceLayerIndex: c} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , u = Xa(s, t);
                    if (!this.layers[0]._featureFilter.filter(new Go(this.zoom), u, i))
                        continue;
                    const h = n ? n.evaluate(u, {}, i, e.availableImages) : void 0
                      , d = {
                        id: a,
                        properties: s.properties,
                        type: s.type,
                        sourceLayerIndex: c,
                        index: l,
                        geometry: t ? u.geometry : Ja(s, i, r),
                        patterns: {},
                        sortKey: h
                    };
                    o.push(d)
                }
                n && o.sort(((t,e)=>t.sortKey - e.sortKey));
                for (const r of o) {
                    const {geometry: n, index: o, sourceLayerIndex: s} = r;
                    if (this.hasPattern) {
                        const t = eu("fill", this.layers, r, this.zoom, e);
                        this.patternFeatures.push(t)
                    } else
                        this.addFeature(r, n, o, i, {}, e.availableImages);
                    e.featureIndex.insert(t[o].feature, n, o, s, this.index)
                }
            }
            update(t, e, i, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, r)
            }
            addFeatures(t, e, i, r, n) {
                for (const t of this.patternFeatures)
                    this.addFeature(t, t.geometry, t.index, e, i, r)
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, bc),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                this.programConfigurations.upload(t),
                this.uploaded = !0
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.indexBuffer2.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.segments2.destroy())
            }
            addFeature(t, e, i, r, n, o=[]) {
                for (const t of Kc(e, 500)) {
                    let e = 0;
                    for (const i of t)
                        e += i.length;
                    const i = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)
                      , r = i.vertexLength
                      , n = []
                      , o = [];
                    for (const e of t) {
                        if (0 === e.length)
                            continue;
                        e !== t[0] && o.push(n.length / 2);
                        const i = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2)
                          , r = i.vertexLength;
                        this.layoutVertexArray.emplaceBack(e[0].x, e[0].y),
                        this.indexArray2.emplaceBack(r + e.length - 1, r),
                        n.push(e[0].x),
                        n.push(e[0].y);
                        for (let t = 1; t < e.length; t++)
                            this.layoutVertexArray.emplaceBack(e[t].x, e[t].y),
                            this.indexArray2.emplaceBack(r + t - 1, r + t),
                            n.push(e[t].x),
                            n.push(e[t].y);
                        i.vertexLength += e.length,
                        i.primitiveLength += e.length
                    }
                    const s = wc.exports(n, o);
                    for (let t = 0; t < s.length; t += 3)
                        this.indexArray.emplaceBack(r + s[t], r + s[t + 1], r + s[t + 2]);
                    i.vertexLength += e,
                    i.primitiveLength += s.length / 3
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, o, r)
            }
        }
        jn(iu, "FillBucket", {
            omit: ["layers", "patternFeatures"]
        });
        const ru = new Qo({
            "fill-sort-key": new Ho(Wt.layout_fill["fill-sort-key"])
        });
        var nu = {
            paint: new Qo({
                "fill-antialias": new Wo(Wt.paint_fill["fill-antialias"]),
                "fill-opacity": new Ho(Wt.paint_fill["fill-opacity"]),
                "fill-color": new Ho(Wt.paint_fill["fill-color"]),
                "fill-outline-color": new Ho(Wt.paint_fill["fill-outline-color"]),
                "fill-translate": new Wo(Wt.paint_fill["fill-translate"]),
                "fill-translate-anchor": new Wo(Wt.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new Ho(Wt.paint_fill["fill-pattern"])
            }),
            layout: ru
        };
        const ou = ns([{
            name: "a_pos_normal_ed",
            components: 4,
            type: "Int16"
        }])
          , su = ns([{
            name: "a_centroid_pos",
            components: 2,
            type: "Uint16"
        }])
          , au = ns([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }, {
            name: "a_pos_normal_3",
            components: 3,
            type: "Int16"
        }])
          , {members: lu} = ou;
        var cu = {}
          , uu = m
          , hu = du;
        function du(t, e, i, r, n) {
            this.properties = {},
            this.extent = i,
            this.type = 0,
            this._pbf = t,
            this._geometry = -1,
            this._keys = r,
            this._values = n,
            t.readFields(pu, this, e)
        }
        function pu(t, e, i) {
            1 == t ? e.id = i.readVarint() : 2 == t ? function(t, e) {
                for (var i = t.readVarint() + t.pos; t.pos < i; ) {
                    var r = e._keys[t.readVarint()]
                      , n = e._values[t.readVarint()];
                    e.properties[r] = n
                }
            }(i, e) : 3 == t ? e.type = i.readVarint() : 4 == t && (e._geometry = i.pos)
        }
        function mu(t) {
            for (var e, i, r = 0, n = 0, o = t.length, s = o - 1; n < o; s = n++)
                r += ((i = t[s]).x - (e = t[n]).x) * (e.y + i.y);
            return r
        }
        du.types = ["Unknown", "Point", "LineString", "Polygon"],
        du.prototype.loadGeometry = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e, i = t.readVarint() + t.pos, r = 1, n = 0, o = 0, s = 0, a = []; t.pos < i; ) {
                if (n <= 0) {
                    var l = t.readVarint();
                    r = 7 & l,
                    n = l >> 3
                }
                if (n--,
                1 === r || 2 === r)
                    o += t.readSVarint(),
                    s += t.readSVarint(),
                    1 === r && (e && a.push(e),
                    e = []),
                    e.push(new uu(o,s));
                else {
                    if (7 !== r)
                        throw new Error("unknown command " + r);
                    e && e.push(e[0].clone())
                }
            }
            return e && a.push(e),
            a
        }
        ,
        du.prototype.bbox = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e = t.readVarint() + t.pos, i = 1, r = 0, n = 0, o = 0, s = 1 / 0, a = -1 / 0, l = 1 / 0, c = -1 / 0; t.pos < e; ) {
                if (r <= 0) {
                    var u = t.readVarint();
                    i = 7 & u,
                    r = u >> 3
                }
                if (r--,
                1 === i || 2 === i)
                    (n += t.readSVarint()) < s && (s = n),
                    n > a && (a = n),
                    (o += t.readSVarint()) < l && (l = o),
                    o > c && (c = o);
                else if (7 !== i)
                    throw new Error("unknown command " + i)
            }
            return [s, l, a, c]
        }
        ,
        du.prototype.toGeoJSON = function(t, e, i) {
            var r, n, o = this.extent * Math.pow(2, i), s = this.extent * t, a = this.extent * e, l = this.loadGeometry(), c = du.types[this.type];
            function u(t) {
                for (var e = 0; e < t.length; e++) {
                    var i = t[e];
                    t[e] = [360 * (i.x + s) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (i.y + a) / o) * Math.PI / 180)) - 90]
                }
            }
            switch (this.type) {
            case 1:
                var h = [];
                for (r = 0; r < l.length; r++)
                    h[r] = l[r][0];
                u(l = h);
                break;
            case 2:
                for (r = 0; r < l.length; r++)
                    u(l[r]);
                break;
            case 3:
                for (l = function(t) {
                    var e = t.length;
                    if (e <= 1)
                        return [t];
                    for (var i, r, n = [], o = 0; o < e; o++) {
                        var s = mu(t[o]);
                        0 !== s && (void 0 === r && (r = s < 0),
                        r === s < 0 ? (i && n.push(i),
                        i = [t[o]]) : i.push(t[o]))
                    }
                    return i && n.push(i),
                    n
                }(l),
                r = 0; r < l.length; r++)
                    for (n = 0; n < l[r].length; n++)
                        u(l[r][n])
            }
            1 === l.length ? l = l[0] : c = "Multi" + c;
            var d = {
                type: "Feature",
                geometry: {
                    type: c,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id"in this && (d.id = this.id),
            d
        }
        ;
        var fu = hu
          , _u = gu;
        function gu(t, e) {
            this.version = 1,
            this.name = null,
            this.extent = 4096,
            this.length = 0,
            this._pbf = t,
            this._keys = [],
            this._values = [],
            this._features = [],
            t.readFields(yu, this, e),
            this.length = this._features.length
        }
        function yu(t, e, i) {
            15 === t ? e.version = i.readVarint() : 1 === t ? e.name = i.readString() : 5 === t ? e.extent = i.readVarint() : 2 === t ? e._features.push(i.pos) : 3 === t ? e._keys.push(i.readString()) : 4 === t && e._values.push(function(t) {
                for (var e = null, i = t.readVarint() + t.pos; t.pos < i; ) {
                    var r = t.readVarint() >> 3;
                    e = 1 === r ? t.readString() : 2 === r ? t.readFloat() : 3 === r ? t.readDouble() : 4 === r ? t.readVarint64() : 5 === r ? t.readVarint() : 6 === r ? t.readSVarint() : 7 === r ? t.readBoolean() : null
                }
                return e
            }(i))
        }
        gu.prototype.feature = function(t) {
            if (t < 0 || t >= this._features.length)
                throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            var e = this._pbf.readVarint() + this._pbf.pos;
            return new fu(this._pbf,e,this.extent,this._keys,this._values)
        }
        ;
        var xu = _u;
        function vu(t, e, i) {
            if (3 === t) {
                var r = new xu(i,i.readVarint() + i.pos);
                r.length && (e[r.name] = r)
            }
        }
        var bu = cu.VectorTile = function(t, e) {
            this.layers = t.readFields(vu, {}, e)
        }
          , wu = cu.VectorTileFeature = hu;
        function zu(t, e, i, r) {
            const n = []
              , o = 0 === r ? (t,e,i,r,n,o)=>{
                t.push(new m(o,i + (o - e) / (r - e) * (n - i)))
            }
            : (t,e,i,r,n,o)=>{
                t.push(new m(e + (o - i) / (n - i) * (r - e),o))
            }
            ;
            for (const s of t) {
                const t = [];
                for (const n of s) {
                    if (n.length <= 2)
                        continue;
                    const s = [];
                    for (let t = 0; t < n.length - 1; t++) {
                        const a = n[t].x
                          , l = n[t].y
                          , c = n[t + 1].x
                          , u = n[t + 1].y
                          , h = 0 === r ? a : l
                          , d = 0 === r ? c : u;
                        h < e ? d > e && o(s, a, l, c, u, e) : h > i ? d < i && o(s, a, l, c, u, i) : s.push(n[t]),
                        d < e && h >= e && o(s, a, l, c, u, e),
                        d > i && h <= i && o(s, a, l, c, u, i)
                    }
                    let a = n[n.length - 1];
                    const l = 0 === r ? a.x : a.y;
                    l >= e && l <= i && s.push(a),
                    s.length && (a = s[s.length - 1],
                    s[0].x === a.x && s[0].y === a.y || s.push(s[0]),
                    t.push(s))
                }
                t.length && n.push(t)
            }
            return n
        }
        cu.VectorTileLayer = _u;
        const Tu = wu.types
          , Eu = Math.pow(2, 13);
        function Su(t, e, i, r, n, o, s, a) {
            t.emplaceBack((e << 1) + s, (i << 1) + o, (Math.floor(r * Eu) << 1) + n, Math.round(a))
        }
        function Mu(t, e, i) {
            const r = 16384;
            t.emplaceBack(e.x, e.y, e.z, i[0] * r, i[1] * r, i[2] * r)
        }
        class Au {
            constructor() {
                this.acc = new m(0,0),
                this.polyCount = []
            }
            startRing(t) {
                this.currentPolyCount = {
                    edges: 0,
                    top: 0
                },
                this.polyCount.push(this.currentPolyCount),
                this.min || (this.min = new m(t.x,t.y),
                this.max = new m(t.x,t.y))
            }
            append(t, e) {
                this.currentPolyCount.edges++,
                this.acc._add(t);
                const i = this.min
                  , r = this.max;
                t.x < i.x ? i.x = t.x : t.x > r.x && (r.x = t.x),
                t.y < i.y ? i.y = t.y : t.y > r.y && (r.y = t.y),
                ((0 === t.x || t.x === za) && t.x === e.x) != ((0 === t.y || t.y === za) && t.y === e.y) && this.processBorderOverlap(t, e),
                e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Mi(e.y, t.y, (0 - e.x) / (t.x - e.x))),
                e.x > za != t.x > za && this.addBorderIntersection(1, Mi(e.y, t.y, (za - e.x) / (t.x - e.x))),
                e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Mi(e.x, t.x, (0 - e.y) / (t.y - e.y))),
                e.y > za != t.y > za && this.addBorderIntersection(3, Mi(e.x, t.x, (za - e.y) / (t.y - e.y)))
            }
            addBorderIntersection(t, e) {
                this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                const i = this.borders[t];
                e < i[0] && (i[0] = e),
                e > i[1] && (i[1] = e)
            }
            processBorderOverlap(t, e) {
                if (t.x === e.x) {
                    if (t.y === e.y)
                        return;
                    const i = 0 === t.x ? 0 : 1;
                    this.addBorderIntersection(i, e.y),
                    this.addBorderIntersection(i, t.y)
                } else {
                    const i = 0 === t.y ? 2 : 3;
                    this.addBorderIntersection(i, e.x),
                    this.addBorderIntersection(i, t.x)
                }
            }
            centroid() {
                const t = this.polyCount.reduce(((t,e)=>t + e.edges), 0);
                return 0 !== t ? this.acc.div(t)._round() : new m(0,0)
            }
            span() {
                return new m(this.max.x - this.min.x,this.max.y - this.min.y)
            }
            intersectsCount() {
                return this.borders.reduce(((t,e)=>t + +(e[0] !== Number.MAX_VALUE)), 0)
            }
        }
        class Iu {
            constructor(t) {
                this.zoom = t.zoom,
                this.canonical = t.canonical,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t=>t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.edgeRadius = 0,
                this.projection = t.projection,
                this.layoutVertexArray = new ls,
                this.centroidVertexArray = new Gs,
                this.indexArray = new ws,
                this.programConfigurations = new pa(t.layers,t.zoom),
                this.segments = new wa,
                this.stateDependentLayerIds = this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),
                this.enableTerrain = t.enableTerrain
            }
            populate(t, e, i, r) {
                this.features = [],
                this.hasPattern = tu("fill-extrusion", this.layers, e),
                this.featuresOnBorder = [],
                this.borders = [[], [], [], []],
                this.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                this.tileToMeter = function(t) {
                    const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));
                    return 80150034 * e / (e * e + 1) / za / (1 << t.z)
                }(i),
                this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const {feature: n, id: o, index: s, sourceLayerIndex: a} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , l = Xa(n, t);
                    if (!this.layers[0]._featureFilter.filter(new Go(this.zoom), l, i))
                        continue;
                    const c = {
                        id: o,
                        sourceLayerIndex: a,
                        index: s,
                        geometry: t ? l.geometry : Ja(n, i, r),
                        properties: n.properties,
                        type: n.type,
                        patterns: {}
                    }
                      , u = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(eu("fill-extrusion", this.layers, c, this.zoom, e)) : this.addFeature(c, c.geometry, s, i, {}, e.availableImages, r),
                    e.featureIndex.insert(n, c.geometry, s, a, this.index, u)
                }
                this.sortBorders()
            }
            addFeatures(t, e, i, r, n) {
                for (const t of this.features) {
                    const {geometry: o} = t;
                    this.addFeature(t, o, t.index, e, i, r, n)
                }
                this.sortBorders()
            }
            update(t, e, i, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, r)
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, lu),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, au.members, !0))),
                this.programConfigurations.upload(t),
                this.uploaded = !0
            }
            uploadCentroid(t) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, su.members, !0),
                this.needsCentroidUpdate = !1)
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(),
                this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy())
            }
            addFeature(t, e, i, r, n, o, s) {
                const a = [new m(0,0), new m(za,za)]
                  , l = s.projection
                  , c = "globe" === l.name
                  , u = this.enableTerrain && !c ? new Au : null
                  , h = "Polygon" === Tu[t.type];
                c && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new ps);
                const d = Kc(e, 500);
                for (let t = d.length - 1; t >= 0; t--) {
                    const e = d[t];
                    (0 === e.length || (p = e[0]).every((t=>t.x <= 0)) || p.every((t=>t.x >= za)) || p.every((t=>t.y <= 0)) || p.every((t=>t.y >= za))) && d.splice(t, 1)
                }
                var p;
                let f;
                if (c)
                    f = Bu(d, a, r);
                else {
                    f = [];
                    for (const t of d)
                        f.push({
                            polygon: t,
                            bounds: a
                        })
                }
                const _ = h ? this.edgeRadius : 0;
                for (const {polygon: t, bounds: e} of f) {
                    let i = 0
                      , n = 0;
                    for (const e of t)
                        h && !e[0].equals(e[e.length - 1]) && e.push(e[0]),
                        n += h ? e.length - 1 : e.length;
                    const o = this.segments.prepareSegment((h ? 5 : 4) * n, this.layoutVertexArray, this.indexArray);
                    if (h) {
                        const e = []
                          , n = [];
                        i = o.vertexLength;
                        for (const i of t) {
                            let s, a;
                            i.length && i !== t[0] && n.push(e.length / 2),
                            s = i[1].sub(i[0])._perp()._unit();
                            for (let t = 1; t < i.length; t++) {
                                const n = i[t]
                                  , u = i[t === i.length - 1 ? 1 : t + 1];
                                let {x: h, y: d} = n;
                                if (_) {
                                    a = u.sub(n)._perp()._unit();
                                    const t = s.add(a)._unit()
                                      , e = _ * Math.min(4, 1 / (s.x * t.x + s.y * t.y));
                                    h += e * t.x,
                                    d += e * t.y,
                                    s = a
                                }
                                Su(this.layoutVertexArray, h, d, 0, 0, 1, 1, 0),
                                o.vertexLength++,
                                e.push(n.x, n.y),
                                c && Mu(this.layoutVertexExtArray, l.projectTilePoint(h, d, r), l.upVector(r, h, d))
                            }
                        }
                        const s = wc.exports(e, n);
                        for (let t = 0; t < s.length; t += 3)
                            this.indexArray.emplaceBack(i + s[t], i + s[t + 2], i + s[t + 1]),
                            o.primitiveLength++
                    }
                    for (const n of t) {
                        u && n.length && u.startRing(n[0]);
                        let t, s, a, d = n.length > 4 && Lu(n[n.length - 2], n[0], n[1]), p = _ ? Du(n[n.length - 2], n[0], n[1], _) : 0;
                        s = n[1].sub(n[0])._perp()._unit();
                        let m = !0;
                        for (let f = 1, g = 0; f < n.length; f++) {
                            let y = n[f - 1]
                              , x = n[f];
                            const v = n[f === n.length - 1 ? 1 : f + 1];
                            if (u && h && u.currentPolyCount.top++,
                            Pu(x, y, e)) {
                                _ && (s = v.sub(x)._perp()._unit(),
                                m = !m);
                                continue
                            }
                            u && u.append(x, y);
                            const b = x.sub(y)._perp()
                              , w = b.x / (Math.abs(b.x) + Math.abs(b.y))
                              , z = b.y > 0 ? 1 : 0
                              , T = y.dist(x);
                            if (g + T > 32768 && (g = 0),
                            _) {
                                a = v.sub(x)._perp()._unit();
                                let t = ku(y, x, v, Cu(s, a), _);
                                isNaN(t) && (t = 0);
                                const e = x.sub(y)._unit();
                                y = y.add(e.mult(p))._round(),
                                x = x.add(e.mult(-t))._round(),
                                p = t,
                                s = a
                            }
                            const E = o.vertexLength
                              , S = n.length > 4 && Lu(y, x, v);
                            let M = Ou(g, d, m);
                            if (Su(this.layoutVertexArray, y.x, y.y, w, z, 0, 0, M),
                            Su(this.layoutVertexArray, y.x, y.y, w, z, 0, 1, M),
                            g += T,
                            M = Ou(g, S, !m),
                            d = S,
                            Su(this.layoutVertexArray, x.x, x.y, w, z, 0, 0, M),
                            Su(this.layoutVertexArray, x.x, x.y, w, z, 0, 1, M),
                            o.vertexLength += 4,
                            this.indexArray.emplaceBack(E + 0, E + 1, E + 2),
                            this.indexArray.emplaceBack(E + 1, E + 3, E + 2),
                            o.primitiveLength += 2,
                            _) {
                                const r = i + (1 === f ? n.length - 2 : f - 2)
                                  , s = 1 === f ? i : r + 1;
                                if (this.indexArray.emplaceBack(E + 1, r, E + 3),
                                this.indexArray.emplaceBack(r, s, E + 3),
                                o.primitiveLength += 2,
                                void 0 === t && (t = E),
                                !Pu(v, n[f], e)) {
                                    const e = f === n.length - 1 ? t : o.vertexLength;
                                    this.indexArray.emplaceBack(E + 2, E + 3, e),
                                    this.indexArray.emplaceBack(E + 3, e + 1, e),
                                    this.indexArray.emplaceBack(E + 3, s, e + 1),
                                    o.primitiveLength += 3
                                }
                                m = !m
                            }
                            if (c) {
                                const t = this.layoutVertexExtArray
                                  , e = l.projectTilePoint(y.x, y.y, r)
                                  , i = l.projectTilePoint(x.x, x.y, r)
                                  , n = l.upVector(r, y.x, y.y)
                                  , o = l.upVector(r, x.x, x.y);
                                Mu(t, e, n),
                                Mu(t, e, n),
                                Mu(t, i, o),
                                Mu(t, i, o)
                            }
                        }
                        h && (i += n.length - 1)
                    }
                }
                if (u && u.polyCount.length > 0) {
                    if (u.borders) {
                        u.vertexArrayOffset = this.centroidVertexArray.length;
                        const t = u.borders
                          , e = this.featuresOnBorder.push(u) - 1;
                        for (let i = 0; i < 4; i++)
                            t[i][0] !== Number.MAX_VALUE && this.borders[i].push(e)
                    }
                    this.encodeCentroid(u.borders ? void 0 : u.centroid(), u)
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, o, r)
            }
            sortBorders() {
                for (let t = 0; t < 4; t++)
                    this.borders[t].sort(((e,i)=>this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[i].borders[t][0]))
            }
            encodeCentroid(t, e, i=!0) {
                let r, n;
                if (t)
                    if (0 !== t.y) {
                        const i = e.span()._mult(this.tileToMeter);
                        r = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(i.x / 10)),
                        n = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(i.y / 10))
                    } else
                        r = Math.ceil(7 * (t.x + 450)),
                        n = 0;
                else
                    r = 0,
                    n = +i;
                let o = i ? this.centroidVertexArray.length : e.vertexArrayOffset;
                for (const t of e.polyCount) {
                    i && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);
                    for (let e = 0; e < t.top; e++)
                        this.centroidVertexArray.emplace(o++, r, n);
                    for (let e = 0; e < 2 * t.edges; e++)
                        this.centroidVertexArray.emplace(o++, 0, n),
                        this.centroidVertexArray.emplace(o++, r, n)
                }
            }
        }
        function Cu(t, e) {
            const i = t.add(e)._unit();
            return t.x * i.x + t.y * i.y
        }
        function Du(t, e, i, r) {
            const n = e.sub(t)._perp()._unit()
              , o = i.sub(e)._perp()._unit();
            return ku(t, e, i, Cu(n, o), r)
        }
        function ku(t, e, i, r, n) {
            const o = Math.sqrt(1 - r * r);
            return Math.min(t.dist(e) / 3, e.dist(i) / 3, n * o / r)
        }
        function Pu(t, e, i) {
            return t.x < i[0].x && e.x < i[0].x || t.x > i[1].x && e.x > i[1].x || t.y < i[0].y && e.y < i[0].y || t.y > i[1].y && e.y > i[1].y
        }
        function Lu(t, e, i) {
            if (t.x < 0 || t.x >= za || e.x < 0 || e.x >= za || i.x < 0 || i.x >= za)
                return !1;
            const r = i.sub(e)
              , n = r.perp()
              , o = t.sub(e);
            return (r.x * o.x + r.y * o.y) / Math.sqrt((r.x * r.x + r.y * r.y) * (o.x * o.x + o.y * o.y)) > -.866 && n.x * o.x + n.y * o.y < 0
        }
        function Ou(t, e, i) {
            const r = e ? 2 | t : -3 & t;
            return i ? 1 | r : -2 & r
        }
        function Ru() {
            const t = Math.PI / 32
              , e = Math.tan(t)
              , i = Ea;
            return i * Math.sqrt(1 + 2 * e * e) - i
        }
        function Bu(t, e, i) {
            const r = 1 << i.z
              , n = ka(i.x / r)
              , o = ka((i.x + 1) / r)
              , s = Pa(i.y / r)
              , a = Pa((i.y + 1) / r);
            return function(t, e, i, r, n=0, o) {
                const s = [];
                if (!t.length || !i || !r)
                    return s;
                const a = (t,e)=>{
                    for (const i of t)
                        s.push({
                            polygon: i,
                            bounds: e
                        })
                }
                  , l = Math.ceil(Math.log2(i))
                  , c = Math.ceil(Math.log2(r))
                  , u = l - c
                  , h = [];
                for (let t = 0; t < Math.abs(u); t++)
                    h.push(u > 0 ? 0 : 1);
                for (let t = 0; t < Math.min(l, c); t++)
                    h.push(0),
                    h.push(1);
                let d = t;
                if (d = zu(d, e[0].y - n, e[1].y + n, 1),
                d = zu(d, e[0].x - n, e[1].x + n, 0),
                !d.length)
                    return s;
                const p = [];
                for (h.length ? p.push({
                    polygons: d,
                    bounds: e,
                    depth: 0
                }) : a(d, e); p.length; ) {
                    const t = p.pop()
                      , e = t.depth
                      , i = h[e]
                      , r = t.bounds[0]
                      , s = t.bounds[1]
                      , l = 0 === i ? r.x : r.y
                      , c = 0 === i ? s.x : s.y
                      , u = o ? o(i, l, c) : .5 * (l + c)
                      , d = zu(t.polygons, l - n, u + n, i)
                      , f = zu(t.polygons, u - n, c + n, i);
                    if (d.length) {
                        const t = [r, new m(0 === i ? u : s.x,1 === i ? u : s.y)];
                        h.length > e + 1 ? p.push({
                            polygons: d,
                            bounds: t,
                            depth: e + 1
                        }) : a(d, t)
                    }
                    if (f.length) {
                        const t = [new m(0 === i ? u : r.x,1 === i ? u : r.y), s];
                        h.length > e + 1 ? p.push({
                            polygons: f,
                            bounds: t,
                            depth: e + 1
                        }) : a(f, t)
                    }
                }
                return s
            }(t, e, Math.ceil((o - n) / 11.25), Math.ceil((s - a) / 11.25), 1, ((t,e,n)=>{
                if (0 === t)
                    return .5 * (e + n);
                {
                    const t = Pa((i.y + e / za) / r);
                    return (Ca(.5 * (Pa((i.y + n / za) / r) + t)) * r - i.y) * za
                }
            }
            ))
        }
        jn(Iu, "FillExtrusionBucket", {
            omit: ["layers", "features"]
        }),
        jn(Au, "PartMetadata");
        const Fu = new Qo({
            "fill-extrusion-edge-radius": new Wo(Wt["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var Uu = {
            paint: new Qo({
                "fill-extrusion-opacity": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new Ho(Wt["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new Ho(Wt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new Ho(Wt["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new Ho(Wt["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new Wo(Wt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"])
            }),
            layout: Fu
        };
        function Nu(t, e, i) {
            var r = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
            return [t * r - 2 * Math.PI * 6378137 / 2, e * r - 2 * Math.PI * 6378137 / 2]
        }
        class Gu {
            constructor(t, e, i) {
                this.z = t,
                this.x = e,
                this.y = i,
                this.key = Zu(0, t, t, e, i)
            }
            equals(t) {
                return this.z === t.z && this.x === t.x && this.y === t.y
            }
            url(t, e) {
                const i = (n = this.x,
                o = this.y,
                s = this.z,
                a = Nu(256 * n, 256 * (o = Math.pow(2, s) - o - 1), s),
                l = Nu(256 * (n + 1), 256 * (o + 1), s),
                a[0] + "," + a[1] + "," + l[0] + "," + l[1])
                  , r = function(t, e, i) {
                    let r, n = "";
                    for (let o = t; o > 0; o--)
                        r = 1 << o - 1,
                        n += (e & r ? 1 : 0) + (i & r ? 2 : 0);
                    return n
                }(this.z, this.x, this.y);
                var n, o, s, a, l;
                return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", r).replace("{bbox-epsg-3857}", i)
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`
            }
        }
        class ju {
            constructor(t, e) {
                this.wrap = t,
                this.canonical = e,
                this.key = Zu(t, e.z, e.z, e.x, e.y)
            }
        }
        class Vu {
            constructor(t, e, i, r, n) {
                this.overscaledZ = t,
                this.wrap = e,
                this.canonical = new Gu(i,+r,+n),
                this.key = 0 === e && t === i ? this.canonical.key : Zu(e, t, i, r, n)
            }
            equals(t) {
                return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
            }
            scaledTo(t) {
                const e = this.canonical.z - t;
                return t > this.canonical.z ? new Vu(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new Vu(t,this.wrap,t,this.canonical.x >> e,this.canonical.y >> e)
            }
            calculateScaledKey(t, e=!0) {
                if (this.overscaledZ === t && e)
                    return this.key;
                if (t > this.canonical.z)
                    return Zu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const i = this.canonical.z - t;
                    return Zu(this.wrap * +e, t, t, this.canonical.x >> i, this.canonical.y >> i)
                }
            }
            isChildOf(t) {
                if (t.wrap !== this.wrap)
                    return !1;
                const e = this.canonical.z - t.canonical.z;
                return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e
            }
            children(t) {
                if (this.overscaledZ >= t)
                    return [new Vu(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                const e = this.canonical.z + 1
                  , i = 2 * this.canonical.x
                  , r = 2 * this.canonical.y;
                return [new Vu(e,this.wrap,e,i,r), new Vu(e,this.wrap,e,i + 1,r), new Vu(e,this.wrap,e,i,r + 1), new Vu(e,this.wrap,e,i + 1,r + 1)]
            }
            isLessThan(t) {
                return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
            }
            wrapped() {
                return new Vu(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
            }
            unwrapTo(t) {
                return new Vu(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z)
            }
            toUnwrapped() {
                return new ju(this.wrap,this.canonical)
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
            }
        }
        function Zu(t, e, i, r, n) {
            const o = 1 << Math.min(i, 22);
            let s = o * (n % o) + r % o;
            return t && i < 22 && (s += o * o * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - i)))),
            16 * (32 * s + i) + (e - i)
        }
        jn(Gu, "CanonicalTileID"),
        jn(Vu, "OverscaledTileID", {
            omit: ["projMatrix"]
        });
        class Ju extends m {
            constructor(t, e, i) {
                super(t, e),
                this.z = i
            }
        }
        function Xu(t, e) {
            return t.x * e.x + t.y * e.y
        }
        function qu(t, e) {
            if (1 === t.length) {
                let i = 0;
                const r = e[i++];
                let n;
                for (; !n || r.equals(n); )
                    if (n = e[i++],
                    !n)
                        return 1 / 0;
                for (; i < e.length; i++) {
                    const o = e[i]
                      , s = t[0]
                      , a = n.sub(r)
                      , l = o.sub(r)
                      , c = s.sub(r)
                      , u = Xu(a, a)
                      , h = Xu(a, l)
                      , d = Xu(l, l)
                      , p = Xu(c, a)
                      , m = Xu(c, l)
                      , f = u * d - h * h
                      , _ = (d * p - h * m) / f
                      , g = (u * m - h * p) / f
                      , y = r.z * (1 - _ - g) + n.z * _ + o.z * g;
                    if (isFinite(y))
                        return y
                }
                return 1 / 0
            }
            {
                let t = 1 / 0;
                for (const i of e)
                    t = Math.min(t, i.z);
                return t
            }
        }
        function $u(t, e, i, r, n, o, s, a) {
            const l = s * n.getElevationAt(t, e, !0, !0)
              , c = 0 !== o[0]
              , u = c ? 0 === o[1] ? s * (o[0] / 7 - 450) : s * function(t, e, i) {
                const r = Math.floor(e[0] / 8)
                  , n = Math.floor(e[1] / 8)
                  , o = 10 * (e[0] - 8 * r)
                  , s = 10 * (e[1] - 8 * n)
                  , a = t.getElevationAt(r, n, !0, !0)
                  , l = t.getMeterToDEM(i)
                  , c = Math.floor(.5 * (o * l - 1))
                  , u = Math.floor(.5 * (s * l - 1))
                  , h = t.tileCoordToPixel(r, n)
                  , d = 2 * c + 1
                  , p = 2 * u + 1
                  , m = (v = t,
                b = h.x - c,
                w = h.y - u,
                z = d,
                T = p,
                [v.getElevationAtPixel(b, w, !0), v.getElevationAtPixel(b + T, w, !0), v.getElevationAtPixel(b, w + T, !0), v.getElevationAtPixel(b + z, w + T, !0)])
                  , f = Math.abs(m[0] - m[1])
                  , _ = Math.abs(m[2] - m[3])
                  , g = Math.abs(m[0] - m[2]) + Math.abs(m[1] - m[3])
                  , y = Math.min(.25, .5 * l * (f + _) / d)
                  , x = Math.min(.25, .5 * l * g / p);
                var v, b, w, z, T;
                return a + Math.max(y * o, x * s)
            }(n, o, a) : l;
            return {
                base: l + (0 === i) ? -1 : i,
                top: c ? Math.max(u + r, l + i + 2) : l + r
            }
        }
        const Yu = ns([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
        }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
        }, {
            name: "a_linesofar",
            components: 1,
            type: "Float32"
        }], 4)
          , {members: Wu} = Yu
          , Hu = ns([{
            name: "a_packed",
            components: 4,
            type: "Float32"
        }])
          , {members: Ku} = Hu
          , Qu = wu.types
          , th = Math.cos(Math.PI / 180 * 37.5);
        class eh {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t=>t.id)),
                this.index = t.index,
                this.projection = t.projection,
                this.hasPattern = !1,
                this.patternFeatures = [],
                this.lineClipsArray = [],
                this.gradients = {},
                this.layers.forEach((t=>{
                    this.gradients[t.id] = {}
                }
                )),
                this.layoutVertexArray = new cs,
                this.layoutVertexArray2 = new us,
                this.indexArray = new ws,
                this.programConfigurations = new pa(t.layers,t.zoom),
                this.segments = new wa,
                this.maxLineLength = 0,
                this.stateDependentLayerIds = this.layers.filter((t=>t.isStateDependent())).map((t=>t.id))
            }
            populate(t, e, i, r) {
                this.hasPattern = tu("line", this.layers, e);
                const n = this.layers[0].layout.get("line-sort-key")
                  , o = [];
                for (const {feature: e, id: s, index: a, sourceLayerIndex: l} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , c = Xa(e, t);
                    if (!this.layers[0]._featureFilter.filter(new Go(this.zoom), c, i))
                        continue;
                    const u = n ? n.evaluate(c, {}, i) : void 0
                      , h = {
                        id: s,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: a,
                        geometry: t ? c.geometry : Ja(e, i, r),
                        patterns: {},
                        sortKey: u
                    };
                    o.push(h)
                }
                n && o.sort(((t,e)=>t.sortKey - e.sortKey));
                const {lineAtlas: s, featureIndex: a} = e
                  , l = this.addConstantDashes(s);
                for (const r of o) {
                    const {geometry: n, index: o, sourceLayerIndex: c} = r;
                    if (l && this.addFeatureDashes(r, s),
                    this.hasPattern) {
                        const t = eu("line", this.layers, r, this.zoom, e);
                        this.patternFeatures.push(t)
                    } else
                        this.addFeature(r, n, o, i, s.positions, e.availableImages);
                    a.insert(t[o].feature, n, o, c, this.index)
                }
            }
            addConstantDashes(t) {
                let e = !1;
                for (const i of this.layers) {
                    const r = i.paint.get("line-dasharray").value
                      , n = i.layout.get("line-cap").value;
                    if ("constant" !== r.kind || "constant" !== n.kind)
                        e = !0;
                    else {
                        const e = n.value
                          , i = r.value;
                        if (!i)
                            continue;
                        t.addDash(i, e)
                    }
                }
                return e
            }
            addFeatureDashes(t, e) {
                const i = this.zoom;
                for (const r of this.layers) {
                    const n = r.paint.get("line-dasharray").value
                      , o = r.layout.get("line-cap").value;
                    if ("constant" === n.kind && "constant" === o.kind)
                        continue;
                    let s, a;
                    if ("constant" === n.kind) {
                        if (s = n.value,
                        !s)
                            continue
                    } else
                        s = n.evaluate({
                            zoom: i
                        }, t);
                    a = "constant" === o.kind ? o.value : o.evaluate({
                        zoom: i
                    }, t),
                    e.addDash(s, a),
                    t.patterns[r.id] = e.getKey(s, a)
                }
            }
            update(t, e, i, r) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, r)
            }
            addFeatures(t, e, i, r, n) {
                for (const t of this.patternFeatures)
                    this.addFeature(t, t.geometry, t.index, e, i, r)
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ku)),
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Wu),
                this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                this.programConfigurations.upload(t),
                this.uploaded = !0
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy())
            }
            lineFeatureClips(t) {
                if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end"))
                    return {
                        start: +t.properties.mapbox_clip_start,
                        end: +t.properties.mapbox_clip_end
                    }
            }
            addFeature(t, e, i, r, n, o) {
                const s = this.layers[0].layout
                  , a = s.get("line-join").evaluate(t, {})
                  , l = s.get("line-cap").evaluate(t, {})
                  , c = s.get("line-miter-limit")
                  , u = s.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t);
                for (const i of e)
                    this.addLine(i, t, a, l, c, u);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, o, r)
            }
            addLine(t, e, i, r, n, o) {
                if (this.distance = 0,
                this.scaledDistance = 0,
                this.totalDistance = 0,
                this.lineSoFar = 0,
                this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for (let e = 0; e < t.length - 1; e++)
                        this.totalDistance += t[e].dist(t[e + 1]);
                    this.updateScaledDistance(),
                    this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                }
                const s = "Polygon" === Qu[e.type];
                let a = t.length;
                for (; a >= 2 && t[a - 1].equals(t[a - 2]); )
                    a--;
                let l = 0;
                for (; l < a - 1 && t[l].equals(t[l + 1]); )
                    l++;
                if (a < (s ? 3 : 2))
                    return;
                "bevel" === i && (n = 1.05);
                const c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0
                  , u = this.segments.prepareSegment(10 * a, this.layoutVertexArray, this.indexArray);
                let h, d, p, m, f;
                this.e1 = this.e2 = -1,
                s && (h = t[a - 2],
                f = t[l].sub(h)._unit()._perp());
                for (let e = l; e < a; e++) {
                    if (p = e === a - 1 ? s ? t[l + 1] : void 0 : t[e + 1],
                    p && t[e].equals(p))
                        continue;
                    f && (m = f),
                    h && (d = h),
                    h = t[e],
                    f = p ? p.sub(h)._unit()._perp() : m,
                    m = m || f;
                    let _ = m.add(f);
                    0 === _.x && 0 === _.y || _._unit();
                    const g = m.x * f.x + m.y * f.y
                      , y = _.x * f.x + _.y * f.y
                      , x = 0 !== y ? 1 / y : 1 / 0
                      , v = 2 * Math.sqrt(2 - 2 * y)
                      , b = y < th && d && p
                      , w = m.x * f.y - m.y * f.x > 0;
                    if (b && e > l) {
                        const t = h.dist(d);
                        if (t > 2 * c) {
                            const e = h.sub(h.sub(d)._mult(c / t)._round());
                            this.updateDistance(d, e),
                            this.addCurrentVertex(e, m, 0, 0, u),
                            d = e
                        }
                    }
                    const z = d && p;
                    let T = z ? i : s ? "butt" : r;
                    if (z && "round" === T && (x < o ? T = "miter" : x <= 2 && (T = "fakeround")),
                    "miter" === T && x > n && (T = "bevel"),
                    "bevel" === T && (x > 2 && (T = "flipbevel"),
                    x < n && (T = "miter")),
                    d && this.updateDistance(d, h),
                    "miter" === T)
                        _._mult(x),
                        this.addCurrentVertex(h, _, 0, 0, u);
                    else if ("flipbevel" === T) {
                        if (x > 100)
                            _ = f.mult(-1);
                        else {
                            const t = x * m.add(f).mag() / m.sub(f).mag();
                            _._perp()._mult(t * (w ? -1 : 1))
                        }
                        this.addCurrentVertex(h, _, 0, 0, u),
                        this.addCurrentVertex(h, _.mult(-1), 0, 0, u)
                    } else if ("bevel" === T || "fakeround" === T) {
                        const t = -Math.sqrt(x * x - 1)
                          , e = w ? t : 0
                          , i = w ? 0 : t;
                        if (d && this.addCurrentVertex(h, m, e, i, u),
                        "fakeround" === T) {
                            const t = Math.round(180 * v / Math.PI / 20);
                            for (let e = 1; e < t; e++) {
                                let i = e / t;
                                if (.5 !== i) {
                                    const t = i - .5;
                                    i += i * t * (i - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)))
                                }
                                const r = f.sub(m)._mult(i)._add(m)._unit()._mult(w ? -1 : 1);
                                this.addHalfVertex(h, r.x, r.y, !1, w, 0, u)
                            }
                        }
                        p && this.addCurrentVertex(h, f, -e, -i, u)
                    } else if ("butt" === T)
                        this.addCurrentVertex(h, _, 0, 0, u);
                    else if ("square" === T) {
                        const t = d ? 1 : -1;
                        d || this.addCurrentVertex(h, _, t, t, u),
                        this.addCurrentVertex(h, _, 0, 0, u),
                        d && this.addCurrentVertex(h, _, t, t, u)
                    } else
                        "round" === T && (d && (this.addCurrentVertex(h, m, 0, 0, u),
                        this.addCurrentVertex(h, m, 1, 1, u, !0)),
                        p && (this.addCurrentVertex(h, f, -1, -1, u, !0),
                        this.addCurrentVertex(h, f, 0, 0, u)));
                    if (b && e < a - 1) {
                        const t = h.dist(p);
                        if (t > 2 * c) {
                            const e = h.add(p.sub(h)._mult(c / t)._round());
                            this.updateDistance(h, e),
                            this.addCurrentVertex(e, f, 0, 0, u),
                            h = e
                        }
                    }
                }
            }
            addCurrentVertex(t, e, i, r, n, o=!1) {
                const s = e.y * r - e.x
                  , a = -e.y - e.x * r;
                this.addHalfVertex(t, e.x + e.y * i, e.y - e.x * i, o, !1, i, n),
                this.addHalfVertex(t, s, a, o, !0, -r, n)
            }
            addHalfVertex({x: t, y: e}, i, r, n, o, s, a) {
                this.layoutVertexArray.emplaceBack((t << 1) + (n ? 1 : 0), (e << 1) + (o ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * r) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1), 0, this.lineSoFar),
                this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const l = a.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l),
                a.primitiveLength++),
                o ? this.e2 = l : this.e1 = l
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance,
                    this.lineSoFar = t * this.lineClips.start + this.distance
                } else
                    this.lineSoFar = this.distance
            }
            updateDistance(t, e) {
                this.distance += t.dist(e),
                this.updateScaledDistance()
            }
        }
        jn(eh, "LineBucket", {
            omit: ["layers", "patternFeatures"]
        });
        const ih = new Qo({
            "line-cap": new Ho(Wt.layout_line["line-cap"]),
            "line-join": new Ho(Wt.layout_line["line-join"]),
            "line-miter-limit": new Wo(Wt.layout_line["line-miter-limit"]),
            "line-round-limit": new Wo(Wt.layout_line["line-round-limit"]),
            "line-sort-key": new Ho(Wt.layout_line["line-sort-key"])
        });
        var rh = {
            paint: new Qo({
                "line-opacity": new Ho(Wt.paint_line["line-opacity"]),
                "line-color": new Ho(Wt.paint_line["line-color"]),
                "line-translate": new Wo(Wt.paint_line["line-translate"]),
                "line-translate-anchor": new Wo(Wt.paint_line["line-translate-anchor"]),
                "line-width": new Ho(Wt.paint_line["line-width"]),
                "line-gap-width": new Ho(Wt.paint_line["line-gap-width"]),
                "line-offset": new Ho(Wt.paint_line["line-offset"]),
                "line-blur": new Ho(Wt.paint_line["line-blur"]),
                "line-dasharray": new Ho(Wt.paint_line["line-dasharray"]),
                "line-pattern": new Ho(Wt.paint_line["line-pattern"]),
                "line-gradient": new Ko(Wt.paint_line["line-gradient"]),
                "line-trim-offset": new Wo(Wt.paint_line["line-trim-offset"])
            }),
            layout: ih
        };
        const nh = new class extends Ho {
            possiblyEvaluate(t, e) {
                return e = new Go(Math.floor(e.zoom),{
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition
                }),
                super.possiblyEvaluate(t, e)
            }
            evaluate(t, e, i, r) {
                return e = I({}, e, {
                    zoom: Math.floor(e.zoom)
                }),
                super.evaluate(t, e, i, r)
            }
        }
        (rh.paint.properties["line-width"].specification);
        function oh(t, e) {
            return e > 0 ? e + 2 * t : t
        }
        nh.useIntegerZoom = !0;
        const sh = ns([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
        }, {
            name: "a_tex_size",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
        }], 4)
          , ah = ns([{
            name: "a_globe_anchor",
            components: 3,
            type: "Int16"
        }, {
            name: "a_globe_normal",
            components: 3,
            type: "Float32"
        }], 4)
          , lh = ns([{
            name: "a_projected_pos",
            components: 4,
            type: "Float32"
        }], 4);
        ns([{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint32"
        }], 4);
        const ch = ns([{
            name: "a_placed",
            components: 2,
            type: "Uint8"
        }, {
            name: "a_shift",
            components: 2,
            type: "Float32"
        }])
          , uh = ns([{
            name: "a_size_scale",
            components: 1,
            type: "Float32"
        }, {
            name: "a_padding",
            components: 2,
            type: "Float32"
        }]);
        ns([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Int16",
            name: "tileAnchorX"
        }, {
            type: "Int16",
            name: "tileAnchorY"
        }, {
            type: "Float32",
            name: "x1"
        }, {
            type: "Float32",
            name: "y1"
        }, {
            type: "Float32",
            name: "x2"
        }, {
            type: "Float32",
            name: "y2"
        }, {
            type: "Int16",
            name: "padding"
        }, {
            type: "Uint32",
            name: "featureIndex"
        }, {
            type: "Uint16",
            name: "sourceLayerIndex"
        }, {
            type: "Uint16",
            name: "bucketIndex"
        }]);
        const hh = ns([{
            name: "a_pos",
            components: 3,
            type: "Int16"
        }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
        }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
        }], 4)
          , dh = ns([{
            name: "a_pos_2f",
            components: 2,
            type: "Float32"
        }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
        }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
        }], 4);
        ns([{
            name: "triangle",
            components: 3,
            type: "Uint16"
        }]),
        ns([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Float32",
            name: "tileAnchorX"
        }, {
            type: "Float32",
            name: "tileAnchorY"
        }, {
            type: "Uint16",
            name: "glyphStartIndex"
        }, {
            type: "Uint16",
            name: "numGlyphs"
        }, {
            type: "Uint32",
            name: "vertexStartIndex"
        }, {
            type: "Uint32",
            name: "lineStartIndex"
        }, {
            type: "Uint32",
            name: "lineLength"
        }, {
            type: "Uint16",
            name: "segment"
        }, {
            type: "Uint16",
            name: "lowerSize"
        }, {
            type: "Uint16",
            name: "upperSize"
        }, {
            type: "Float32",
            name: "lineOffsetX"
        }, {
            type: "Float32",
            name: "lineOffsetY"
        }, {
            type: "Uint8",
            name: "writingMode"
        }, {
            type: "Uint8",
            name: "placedOrientation"
        }, {
            type: "Uint8",
            name: "hidden"
        }, {
            type: "Uint32",
            name: "crossTileID"
        }, {
            type: "Int16",
            name: "associatedIconIndex"
        }, {
            type: "Uint8",
            name: "flipState"
        }]),
        ns([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Float32",
            name: "tileAnchorX"
        }, {
            type: "Float32",
            name: "tileAnchorY"
        }, {
            type: "Int16",
            name: "rightJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "centerJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "leftJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "verticalPlacedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "placedIconSymbolIndex"
        }, {
            type: "Int16",
            name: "verticalPlacedIconSymbolIndex"
        }, {
            type: "Uint16",
            name: "key"
        }, {
            type: "Uint16",
            name: "textBoxStartIndex"
        }, {
            type: "Uint16",
            name: "textBoxEndIndex"
        }, {
            type: "Uint16",
            name: "verticalTextBoxStartIndex"
        }, {
            type: "Uint16",
            name: "verticalTextBoxEndIndex"
        }, {
            type: "Uint16",
            name: "iconBoxStartIndex"
        }, {
            type: "Uint16",
            name: "iconBoxEndIndex"
        }, {
            type: "Uint16",
            name: "verticalIconBoxStartIndex"
        }, {
            type: "Uint16",
            name: "verticalIconBoxEndIndex"
        }, {
            type: "Uint16",
            name: "featureIndex"
        }, {
            type: "Uint16",
            name: "numHorizontalGlyphVertices"
        }, {
            type: "Uint16",
            name: "numVerticalGlyphVertices"
        }, {
            type: "Uint16",
            name: "numIconVertices"
        }, {
            type: "Uint16",
            name: "numVerticalIconVertices"
        }, {
            type: "Uint16",
            name: "useRuntimeCollisionCircles"
        }, {
            type: "Uint32",
            name: "crossTileID"
        }, {
            type: "Float32",
            components: 2,
            name: "textOffset"
        }, {
            type: "Float32",
            name: "collisionCircleDiameter"
        }]),
        ns([{
            type: "Float32",
            name: "offsetX"
        }]),
        ns([{
            type: "Int16",
            name: "x"
        }, {
            type: "Int16",
            name: "y"
        }]);
        var ph = 24;
        const mh = 128;
        function fh(t, e) {
            const {expression: i} = e;
            if ("constant" === i.kind)
                return {
                    kind: "constant",
                    layoutSize: i.evaluate(new Go(t + 1))
                };
            if ("source" === i.kind)
                return {
                    kind: "source"
                };
            {
                const {zoomStops: e, interpolationType: r} = i;
                let n = 0;
                for (; n < e.length && e[n] <= t; )
                    n++;
                n = Math.max(0, n - 1);
                let o = n;
                for (; o < e.length && e[o] < t + 1; )
                    o++;
                o = Math.min(e.length - 1, o);
                const s = e[n]
                  , a = e[o];
                return "composite" === i.kind ? {
                    kind: "composite",
                    minZoom: s,
                    maxZoom: a,
                    interpolationType: r
                } : {
                    kind: "camera",
                    minZoom: s,
                    maxZoom: a,
                    minSize: i.evaluate(new Go(s)),
                    maxSize: i.evaluate(new Go(a)),
                    interpolationType: r
                }
            }
        }
        function _h(t, {uSize: e, uSizeT: i}, {lowerSize: r, upperSize: n}) {
            return "source" === t.kind ? r / mh : "composite" === t.kind ? Mi(r / mh, n / mh, i) : e
        }
        function gh(t, e) {
            let i = 0
              , r = 0;
            if ("constant" === t.kind)
                r = t.layoutSize;
            else if ("source" !== t.kind) {
                const {interpolationType: n, minZoom: o, maxZoom: s} = t
                  , a = n ? T($i.interpolationFactor(n, e, o, s), 0, 1) : 0;
                "camera" === t.kind ? r = Mi(t.minSize, t.maxSize, a) : i = a
            }
            return {
                uSizeT: i,
                uSize: r
            }
        }
        var yh = Object.freeze({
            __proto__: null,
            getSizeData: fh,
            evaluateSizeForFeature: _h,
            evaluateSizeForZoom: gh,
            SIZE_PACK_FACTOR: mh
        });
        function xh(t, e, i) {
            return t.sections.forEach((t=>{
                t.text = function(t, e, i) {
                    const r = e.layout.get("text-transform").evaluate(i, {});
                    return "uppercase" === r ? t = t.toLocaleUpperCase() : "lowercase" === r && (t = t.toLocaleLowerCase()),
                    No.applyArabicShaping && (t = No.applyArabicShaping(t)),
                    t
                }(t.text, e, i)
            }
            )),
            t
        }
        const vh = {
            "!": "",
            "#": "",
            $: "",
            "%": "",
            "&": "",
            "(": "",
            ")": "",
            "*": "",
            "+": "",
            ",": "",
            "-": "",
            ".": "",
            "/": "",
            ":": "",
            ";": "",
            "<": "",
            "=": "",
            ">": "",
            "?": "",
            "@": "",
            "[": "",
            "\\": "",
            "]": "",
            "^": "",
            _: "",
            "`": "",
            "{": "",
            "|": "",
            "}": "",
            "~": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": ""
        };
        function bh(t) {
            return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t
        }
        function wh(t) {
            return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t
        }
        var zh = Sh
          , Th = function(t, e, i, r, n) {
            var o, s, a = 8 * n - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = i ? n - 1 : 0, d = i ? -1 : 1, p = t[e + h];
            for (h += d,
            o = p & (1 << -u) - 1,
            p >>= -u,
            u += a; u > 0; o = 256 * o + t[e + h],
            h += d,
            u -= 8)
                ;
            for (s = o & (1 << -u) - 1,
            o >>= -u,
            u += r; u > 0; s = 256 * s + t[e + h],
            h += d,
            u -= 8)
                ;
            if (0 === o)
                o = 1 - c;
            else {
                if (o === l)
                    return s ? NaN : 1 / 0 * (p ? -1 : 1);
                s += Math.pow(2, r),
                o -= c
            }
            return (p ? -1 : 1) * s * Math.pow(2, o - r)
        }
          , Eh = function(t, e, i, r, n, o) {
            var s, a, l, c = 8 * o - n - 1, u = (1 << c) - 1, h = u >> 1, d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : o - 1, m = r ? 1 : -1, f = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e),
            isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
            s = u) : (s = Math.floor(Math.log(e) / Math.LN2),
            e * (l = Math.pow(2, -s)) < 1 && (s--,
            l *= 2),
            (e += s + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (s++,
            l /= 2),
            s + h >= u ? (a = 0,
            s = u) : s + h >= 1 ? (a = (e * l - 1) * Math.pow(2, n),
            s += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, n),
            s = 0)); n >= 8; t[i + p] = 255 & a,
            p += m,
            a /= 256,
            n -= 8)
                ;
            for (s = s << n | a,
            c += n; c > 0; t[i + p] = 255 & s,
            p += m,
            s /= 256,
            c -= 8)
                ;
            t[i + p - m] |= 128 * f
        };
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        function Sh(t) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0),
            this.pos = 0,
            this.type = 0,
            this.length = this.buf.length
        }
        Sh.Varint = 0,
        Sh.Fixed64 = 1,
        Sh.Bytes = 2,
        Sh.Fixed32 = 5;
        var Mh = 4294967296
          , Ah = 1 / Mh
          , Ih = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Ch(t) {
            return t.type === Sh.Bytes ? t.readVarint() + t.pos : t.pos + 1
        }
        function Dh(t, e, i) {
            return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0)
        }
        function kh(t, e, i) {
            var r = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
            i.realloc(r);
            for (var n = i.pos - 1; n >= t; n--)
                i.buf[n + r] = i.buf[n]
        }
        function Ph(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeVarint(t[i])
        }
        function Lh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeSVarint(t[i])
        }
        function Oh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeFloat(t[i])
        }
        function Rh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeDouble(t[i])
        }
        function Bh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeBoolean(t[i])
        }
        function Fh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeFixed32(t[i])
        }
        function Uh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeSFixed32(t[i])
        }
        function Nh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeFixed64(t[i])
        }
        function Gh(t, e) {
            for (var i = 0; i < t.length; i++)
                e.writeSFixed64(t[i])
        }
        function jh(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3]
        }
        function Vh(t, e, i) {
            t[i] = e,
            t[i + 1] = e >>> 8,
            t[i + 2] = e >>> 16,
            t[i + 3] = e >>> 24
        }
        function Zh(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24)
        }
        function Jh(t, e, i) {
            e.glyphs = [],
            1 === t && i.readMessage(Xh, e)
        }
        function Xh(t, e, i) {
            if (3 === t) {
                const {id: t, bitmap: r, width: n, height: o, left: s, top: a, advance: l} = i.readMessage(qh, {});
                e.glyphs.push({
                    id: t,
                    bitmap: new fc({
                        width: n + 6,
                        height: o + 6
                    },r),
                    metrics: {
                        width: n,
                        height: o,
                        left: s,
                        top: a,
                        advance: l
                    }
                })
            } else
                4 === t ? e.ascender = i.readSVarint() : 5 === t && (e.descender = i.readSVarint())
        }
        function qh(t, e, i) {
            1 === t ? e.id = i.readVarint() : 2 === t ? e.bitmap = i.readBytes() : 3 === t ? e.width = i.readVarint() : 4 === t ? e.height = i.readVarint() : 5 === t ? e.left = i.readSVarint() : 6 === t ? e.top = i.readSVarint() : 7 === t && (e.advance = i.readVarint())
        }
        function $h(t) {
            let e = 0
              , i = 0;
            for (const r of t)
                e += r.w * r.h,
                i = Math.max(i, r.w);
            t.sort(((t,e)=>e.h - t.h));
            const r = [{
                x: 0,
                y: 0,
                w: Math.max(Math.ceil(Math.sqrt(e / .95)), i),
                h: 1 / 0
            }];
            let n = 0
              , o = 0;
            for (const e of t)
                for (let t = r.length - 1; t >= 0; t--) {
                    const i = r[t];
                    if (!(e.w > i.w || e.h > i.h)) {
                        if (e.x = i.x,
                        e.y = i.y,
                        o = Math.max(o, e.y + e.h),
                        n = Math.max(n, e.x + e.w),
                        e.w === i.w && e.h === i.h) {
                            const e = r.pop();
                            t < r.length && (r[t] = e)
                        } else
                            e.h === i.h ? (i.x += e.w,
                            i.w -= e.w) : e.w === i.w ? (i.y += e.h,
                            i.h -= e.h) : (r.push({
                                x: i.x + e.w,
                                y: i.y,
                                w: i.w - e.w,
                                h: e.h
                            }),
                            i.y += e.h,
                            i.h -= e.h);
                        break
                    }
                }
            return {
                w: n,
                h: o,
                fill: e / (n * o) || 0
            }
        }
        Sh.prototype = {
            destroy: function() {
                this.buf = null
            },
            readFields: function(t, e, i) {
                for (i = i || this.length; this.pos < i; ) {
                    var r = this.readVarint()
                      , n = r >> 3
                      , o = this.pos;
                    this.type = 7 & r,
                    t(n, e, this),
                    this.pos === o && this.skip(r)
                }
                return e
            },
            readMessage: function(t, e) {
                return this.readFields(t, e, this.readVarint() + this.pos)
            },
            readFixed32: function() {
                var t = jh(this.buf, this.pos);
                return this.pos += 4,
                t
            },
            readSFixed32: function() {
                var t = Zh(this.buf, this.pos);
                return this.pos += 4,
                t
            },
            readFixed64: function() {
                var t = jh(this.buf, this.pos) + jh(this.buf, this.pos + 4) * Mh;
                return this.pos += 8,
                t
            },
            readSFixed64: function() {
                var t = jh(this.buf, this.pos) + Zh(this.buf, this.pos + 4) * Mh;
                return this.pos += 8,
                t
            },
            readFloat: function() {
                var t = Th(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4,
                t
            },
            readDouble: function() {
                var t = Th(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8,
                t
            },
            readVarint: function(t) {
                var e, i, r = this.buf;
                return e = 127 & (i = r[this.pos++]),
                i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 7,
                i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 14,
                i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 21,
                i < 128 ? e : function(t, e, i) {
                    var r, n, o = i.buf;
                    if (r = (112 & (n = o[i.pos++])) >> 4,
                    n < 128)
                        return Dh(t, r, e);
                    if (r |= (127 & (n = o[i.pos++])) << 3,
                    n < 128)
                        return Dh(t, r, e);
                    if (r |= (127 & (n = o[i.pos++])) << 10,
                    n < 128)
                        return Dh(t, r, e);
                    if (r |= (127 & (n = o[i.pos++])) << 17,
                    n < 128)
                        return Dh(t, r, e);
                    if (r |= (127 & (n = o[i.pos++])) << 24,
                    n < 128)
                        return Dh(t, r, e);
                    if (r |= (1 & (n = o[i.pos++])) << 31,
                    n < 128)
                        return Dh(t, r, e);
                    throw new Error("Expected varint not more than 10 bytes")
                }(e |= (15 & (i = r[this.pos])) << 28, t, this))))
            },
            readVarint64: function() {
                return this.readVarint(!0)
            },
            readSVarint: function() {
                var t = this.readVarint();
                return t % 2 == 1 ? (t + 1) / -2 : t / 2
            },
            readBoolean: function() {
                return Boolean(this.readVarint())
            },
            readString: function() {
                var t, e, i, r = this.readVarint() + this.pos, n = this.pos;
                return this.pos = r,
                r - n >= 12 && Ih ? (t = this.buf,
                e = n,
                i = r,
                Ih.decode(t.subarray(e, i))) : function(t, e, i) {
                    for (var r = "", n = e; n < i; ) {
                        var o, s, a, l = t[n], c = null, u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (n + u > i)
                            break;
                        1 === u ? l < 128 && (c = l) : 2 === u ? 128 == (192 & (o = t[n + 1])) && (c = (31 & l) << 6 | 63 & o) <= 127 && (c = null) : 3 === u ? (s = t[n + 2],
                        128 == (192 & (o = t[n + 1])) && 128 == (192 & s) && ((c = (15 & l) << 12 | (63 & o) << 6 | 63 & s) <= 2047 || c >= 55296 && c <= 57343) && (c = null)) : 4 === u && (s = t[n + 2],
                        a = t[n + 3],
                        128 == (192 & (o = t[n + 1])) && 128 == (192 & s) && 128 == (192 & a) && ((c = (15 & l) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) <= 65535 || c >= 1114112) && (c = null)),
                        null === c ? (c = 65533,
                        u = 1) : c > 65535 && (c -= 65536,
                        r += String.fromCharCode(c >>> 10 & 1023 | 55296),
                        c = 56320 | 1023 & c),
                        r += String.fromCharCode(c),
                        n += u
                    }
                    return r
                }(this.buf, n, r)
            },
            readBytes: function() {
                var t = this.readVarint() + this.pos
                  , e = this.buf.subarray(this.pos, t);
                return this.pos = t,
                e
            },
            readPackedVarint: function(t, e) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readVarint(e));
                var i = Ch(this);
                for (t = t || []; this.pos < i; )
                    t.push(this.readVarint(e));
                return t
            },
            readPackedSVarint: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readSVarint());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSVarint());
                return t
            },
            readPackedBoolean: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readBoolean());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readBoolean());
                return t
            },
            readPackedFloat: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readFloat());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFloat());
                return t
            },
            readPackedDouble: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readDouble());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readDouble());
                return t
            },
            readPackedFixed32: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readFixed32());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFixed32());
                return t
            },
            readPackedSFixed32: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readSFixed32());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSFixed32());
                return t
            },
            readPackedFixed64: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readFixed64());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFixed64());
                return t
            },
            readPackedSFixed64: function(t) {
                if (this.type !== Sh.Bytes)
                    return t.push(this.readSFixed64());
                var e = Ch(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSFixed64());
                return t
            },
            skip: function(t) {
                var e = 7 & t;
                if (e === Sh.Varint)
                    for (; this.buf[this.pos++] > 127; )
                        ;
                else if (e === Sh.Bytes)
                    this.pos = this.readVarint() + this.pos;
                else if (e === Sh.Fixed32)
                    this.pos += 4;
                else {
                    if (e !== Sh.Fixed64)
                        throw new Error("Unimplemented type: " + e);
                    this.pos += 8
                }
            },
            writeTag: function(t, e) {
                this.writeVarint(t << 3 | e)
            },
            realloc: function(t) {
                for (var e = this.length || 16; e < this.pos + t; )
                    e *= 2;
                if (e !== this.length) {
                    var i = new Uint8Array(e);
                    i.set(this.buf),
                    this.buf = i,
                    this.length = e
                }
            },
            finish: function() {
                return this.length = this.pos,
                this.pos = 0,
                this.buf.subarray(0, this.length)
            },
            writeFixed32: function(t) {
                this.realloc(4),
                Vh(this.buf, t, this.pos),
                this.pos += 4
            },
            writeSFixed32: function(t) {
                this.realloc(4),
                Vh(this.buf, t, this.pos),
                this.pos += 4
            },
            writeFixed64: function(t) {
                this.realloc(8),
                Vh(this.buf, -1 & t, this.pos),
                Vh(this.buf, Math.floor(t * Ah), this.pos + 4),
                this.pos += 8
            },
            writeSFixed64: function(t) {
                this.realloc(8),
                Vh(this.buf, -1 & t, this.pos),
                Vh(this.buf, Math.floor(t * Ah), this.pos + 4),
                this.pos += 8
            },
            writeVarint: function(t) {
                (t = +t || 0) > 268435455 || t < 0 ? function(t, e) {
                    var i, r, n, o;
                    if (t >= 0 ? (i = t % 4294967296 | 0,
                    r = t / 4294967296 | 0) : (r = ~(-t / 4294967296),
                    4294967295 ^ (i = ~(-t % 4294967296)) ? i = i + 1 | 0 : (i = 0,
                    r = r + 1 | 0)),
                    t >= 0x10000000000000000 || t < -0x10000000000000000)
                        throw new Error("Given varint doesn't fit into 10 bytes");
                    e.realloc(10),
                    n = i,
                    (o = e).buf[o.pos++] = 127 & n | 128,
                    n >>>= 7,
                    o.buf[o.pos++] = 127 & n | 128,
                    n >>>= 7,
                    o.buf[o.pos++] = 127 & n | 128,
                    n >>>= 7,
                    o.buf[o.pos++] = 127 & n | 128,
                    o.buf[o.pos] = 127 & (n >>>= 7),
                    function(t, e) {
                        var i = (7 & t) << 4;
                        e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t)))))
                    }(r, e)
                }(t, this) : (this.realloc(4),
                this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
            },
            writeSVarint: function(t) {
                this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
            },
            writeBoolean: function(t) {
                this.writeVarint(Boolean(t))
            },
            writeString: function(t) {
                t = String(t),
                this.realloc(4 * t.length),
                this.pos++;
                var e = this.pos;
                this.pos = function(t, e, i) {
                    for (var r, n, o = 0; o < e.length; o++) {
                        if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
                            if (!n) {
                                r > 56319 || o + 1 === e.length ? (t[i++] = 239,
                                t[i++] = 191,
                                t[i++] = 189) : n = r;
                                continue
                            }
                            if (r < 56320) {
                                t[i++] = 239,
                                t[i++] = 191,
                                t[i++] = 189,
                                n = r;
                                continue
                            }
                            r = n - 55296 << 10 | r - 56320 | 65536,
                            n = null
                        } else
                            n && (t[i++] = 239,
                            t[i++] = 191,
                            t[i++] = 189,
                            n = null);
                        r < 128 ? t[i++] = r : (r < 2048 ? t[i++] = r >> 6 | 192 : (r < 65536 ? t[i++] = r >> 12 | 224 : (t[i++] = r >> 18 | 240,
                        t[i++] = r >> 12 & 63 | 128),
                        t[i++] = r >> 6 & 63 | 128),
                        t[i++] = 63 & r | 128)
                    }
                    return i
                }(this.buf, t, this.pos);
                var i = this.pos - e;
                i >= 128 && kh(e, i, this),
                this.pos = e - 1,
                this.writeVarint(i),
                this.pos += i
            },
            writeFloat: function(t) {
                this.realloc(4),
                Eh(this.buf, t, this.pos, !0, 23, 4),
                this.pos += 4
            },
            writeDouble: function(t) {
                this.realloc(8),
                Eh(this.buf, t, this.pos, !0, 52, 8),
                this.pos += 8
            },
            writeBytes: function(t) {
                var e = t.length;
                this.writeVarint(e),
                this.realloc(e);
                for (var i = 0; i < e; i++)
                    this.buf[this.pos++] = t[i]
            },
            writeRawMessage: function(t, e) {
                this.pos++;
                var i = this.pos;
                t(e, this);
                var r = this.pos - i;
                r >= 128 && kh(i, r, this),
                this.pos = i - 1,
                this.writeVarint(r),
                this.pos += r
            },
            writeMessage: function(t, e, i) {
                this.writeTag(t, Sh.Bytes),
                this.writeRawMessage(e, i)
            },
            writePackedVarint: function(t, e) {
                e.length && this.writeMessage(t, Ph, e)
            },
            writePackedSVarint: function(t, e) {
                e.length && this.writeMessage(t, Lh, e)
            },
            writePackedBoolean: function(t, e) {
                e.length && this.writeMessage(t, Bh, e)
            },
            writePackedFloat: function(t, e) {
                e.length && this.writeMessage(t, Oh, e)
            },
            writePackedDouble: function(t, e) {
                e.length && this.writeMessage(t, Rh, e)
            },
            writePackedFixed32: function(t, e) {
                e.length && this.writeMessage(t, Fh, e)
            },
            writePackedSFixed32: function(t, e) {
                e.length && this.writeMessage(t, Uh, e)
            },
            writePackedFixed64: function(t, e) {
                e.length && this.writeMessage(t, Nh, e)
            },
            writePackedSFixed64: function(t, e) {
                e.length && this.writeMessage(t, Gh, e)
            },
            writeBytesField: function(t, e) {
                this.writeTag(t, Sh.Bytes),
                this.writeBytes(e)
            },
            writeFixed32Field: function(t, e) {
                this.writeTag(t, Sh.Fixed32),
                this.writeFixed32(e)
            },
            writeSFixed32Field: function(t, e) {
                this.writeTag(t, Sh.Fixed32),
                this.writeSFixed32(e)
            },
            writeFixed64Field: function(t, e) {
                this.writeTag(t, Sh.Fixed64),
                this.writeFixed64(e)
            },
            writeSFixed64Field: function(t, e) {
                this.writeTag(t, Sh.Fixed64),
                this.writeSFixed64(e)
            },
            writeVarintField: function(t, e) {
                this.writeTag(t, Sh.Varint),
                this.writeVarint(e)
            },
            writeSVarintField: function(t, e) {
                this.writeTag(t, Sh.Varint),
                this.writeSVarint(e)
            },
            writeStringField: function(t, e) {
                this.writeTag(t, Sh.Bytes),
                this.writeString(e)
            },
            writeFloatField: function(t, e) {
                this.writeTag(t, Sh.Fixed32),
                this.writeFloat(e)
            },
            writeDoubleField: function(t, e) {
                this.writeTag(t, Sh.Fixed64),
                this.writeDouble(e)
            },
            writeBooleanField: function(t, e) {
                this.writeVarintField(t, Boolean(e))
            }
        };
        class Yh {
            constructor(t, {pixelRatio: e, version: i, stretchX: r, stretchY: n, content: o}) {
                this.paddedRect = t,
                this.pixelRatio = e,
                this.stretchX = r,
                this.stretchY = n,
                this.content = o,
                this.version = i
            }
            get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1]
            }
            get br() {
                return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
            }
            get displaySize() {
                return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
            }
        }
        class Wh {
            constructor(t, e) {
                const i = {}
                  , r = {};
                this.haveRenderCallbacks = [];
                const n = [];
                this.addImages(t, i, n),
                this.addImages(e, r, n);
                const {w: o, h: s} = $h(n)
                  , a = new _c({
                    width: o || 1,
                    height: s || 1
                });
                for (const e in t) {
                    const r = t[e]
                      , n = i[e].paddedRect;
                    _c.copy(r.data, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n.x + 1,
                        y: n.y + 1
                    }, r.data)
                }
                for (const t in e) {
                    const i = e[t]
                      , n = r[t].paddedRect
                      , o = n.x + 1
                      , s = n.y + 1
                      , l = i.data.width
                      , c = i.data.height;
                    _c.copy(i.data, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: s
                    }, i.data),
                    _c.copy(i.data, a, {
                        x: 0,
                        y: c - 1
                    }, {
                        x: o,
                        y: s - 1
                    }, {
                        width: l,
                        height: 1
                    }),
                    _c.copy(i.data, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: s + c
                    }, {
                        width: l,
                        height: 1
                    }),
                    _c.copy(i.data, a, {
                        x: l - 1,
                        y: 0
                    }, {
                        x: o - 1,
                        y: s
                    }, {
                        width: 1,
                        height: c
                    }),
                    _c.copy(i.data, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + l,
                        y: s
                    }, {
                        width: 1,
                        height: c
                    })
                }
                this.image = a,
                this.iconPositions = i,
                this.patternPositions = r
            }
            addImages(t, e, i) {
                for (const r in t) {
                    const n = t[r]
                      , o = {
                        x: 0,
                        y: 0,
                        w: n.data.width + 2,
                        h: n.data.height + 2
                    };
                    i.push(o),
                    e[r] = new Yh(o,n),
                    n.hasRenderCallback && this.haveRenderCallbacks.push(r)
                }
            }
            patchUpdatedImages(t, e) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e=>t.hasImage(e))),
                t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const i in t.updatedImages)
                    this.patchUpdatedImage(this.iconPositions[i], t.getImage(i), e),
                    this.patchUpdatedImage(this.patternPositions[i], t.getImage(i), e)
            }
            patchUpdatedImage(t, e, i) {
                if (!t || !e)
                    return;
                if (t.version === e.version)
                    return;
                t.version = e.version;
                const [r,n] = t.tl;
                i.update(e.data, void 0, {
                    x: r,
                    y: n
                })
            }
        }
        jn(Yh, "ImagePosition"),
        jn(Wh, "ImageAtlas");
        const Hh = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class Kh {
            constructor() {
                this.scale = 1,
                this.fontStack = "",
                this.imageName = null
            }
            static forText(t, e) {
                const i = new Kh;
                return i.scale = t || 1,
                i.fontStack = e,
                i
            }
            static forImage(t) {
                const e = new Kh;
                return e.imageName = t,
                e
            }
        }
        class Qh {
            constructor() {
                this.text = "",
                this.sectionIndex = [],
                this.sections = [],
                this.imageSectionID = null
            }
            static fromFeature(t, e) {
                const i = new Qh;
                for (let r = 0; r < t.sections.length; r++) {
                    const n = t.sections[r];
                    n.image ? i.addImageSection(n) : i.addTextSection(n, e)
                }
                return i
            }
            length() {
                return this.text.length
            }
            getSection(t) {
                return this.sections[this.sectionIndex[t]]
            }
            getSections() {
                return this.sections
            }
            getSectionIndex(t) {
                return this.sectionIndex[t]
            }
            getCharCode(t) {
                return this.text.charCodeAt(t)
            }
            verticalizePunctuation(t) {
                this.text = function(t, e) {
                    let i = "";
                    for (let r = 0; r < t.length; r++) {
                        const n = t.charCodeAt(r + 1) || null
                          , o = t.charCodeAt(r - 1) || null;
                        i += !e && (n && Eo(n) && !vh[t[r + 1]] || o && Eo(o) && !vh[t[r - 1]]) || !vh[t[r]] ? t[r] : vh[t[r]]
                    }
                    return i
                }(this.text, t)
            }
            trim() {
                let t = 0;
                for (let e = 0; e < this.text.length && ed[this.text.charCodeAt(e)]; e++)
                    t++;
                let e = this.text.length;
                for (let i = this.text.length - 1; i >= 0 && i >= t && ed[this.text.charCodeAt(i)]; i--)
                    e--;
                this.text = this.text.substring(t, e),
                this.sectionIndex = this.sectionIndex.slice(t, e)
            }
            substring(t, e) {
                const i = new Qh;
                return i.text = this.text.substring(t, e),
                i.sectionIndex = this.sectionIndex.slice(t, e),
                i.sections = this.sections,
                i
            }
            toString() {
                return this.text
            }
            getMaxScale() {
                return this.sectionIndex.reduce(((t,e)=>Math.max(t, this.sections[e].scale)), 0)
            }
            addTextSection(t, e) {
                this.text += t.text,
                this.sections.push(Kh.forText(t.scale, t.fontStack || e));
                const i = this.sections.length - 1;
                for (let e = 0; e < t.text.length; ++e)
                    this.sectionIndex.push(i)
            }
            addImageSection(t) {
                const e = t.image ? t.image.name : "";
                if (0 === e.length)
                    return void G("Can't add FormattedSection with an empty image.");
                const i = this.getNextImageSectionCharCode();
                i ? (this.text += String.fromCharCode(i),
                this.sections.push(Kh.forImage(e)),
                this.sectionIndex.push(this.sections.length - 1)) : G("Reached maximum number of images 6401")
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                this.imageSectionID)
            }
        }
        function td(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m) {
            const f = Qh.fromFeature(t, n);
            h === Hh.vertical && f.verticalizePunctuation(d);
            let _ = [];
            const g = function(t, e, i, r, n, o) {
                if (!t)
                    return [];
                const s = []
                  , a = function(t, e, i, r, n, o) {
                    let s = 0;
                    for (let i = 0; i < t.length(); i++) {
                        const a = t.getSection(i);
                        s += rd(t.getCharCode(i), a, r, n, e, o)
                    }
                    return s / Math.max(1, Math.ceil(s / i))
                }(t, e, i, r, n, o)
                  , l = t.text.indexOf("") >= 0;
                let c = 0;
                for (let i = 0; i < t.length(); i++) {
                    const h = t.getSection(i)
                      , d = t.getCharCode(i);
                    if (ed[d] || (c += rd(d, h, r, n, e, o)),
                    i < t.length() - 1) {
                        const e = !((u = d) < 11904 || !(ro(u) || io(u) || go(u) || mo(u) || ao(u) || Wn(u) || no(u) || Qn(u) || lo(u) || co(u) || so(u) || vo(u) || to(u) || Kn(u) || Hn(u) || oo(u) || eo(u) || _o(u) || ho(u) || uo(u)));
                        (id[d] || e || h.imageName) && s.push(sd(i + 1, c, a, s, od(d, t.getCharCode(i + 1), e && l), !1))
                    }
                }
                var u;
                return ad(sd(t.length(), c, a, s, 0, !0))
            }(f, c, o, e, r, p)
              , {processBidirectionalText: y, processStyledBidirectionalText: x} = No;
            if (y && 1 === f.sections.length) {
                const t = y(f.toString(), g);
                for (const e of t) {
                    const t = new Qh;
                    t.text = e,
                    t.sections = f.sections;
                    for (let i = 0; i < e.length; i++)
                        t.sectionIndex.push(0);
                    _.push(t)
                }
            } else if (x) {
                const t = x(f.text, f.sectionIndex, g);
                for (const e of t) {
                    const t = new Qh;
                    t.text = e[0],
                    t.sectionIndex = e[1],
                    t.sections = f.sections,
                    _.push(t)
                }
            } else
                _ = function(t, e) {
                    const i = []
                      , r = t.text;
                    let n = 0;
                    for (const r of e)
                        i.push(t.substring(n, r)),
                        n = r;
                    return n < r.length && i.push(t.substring(n, r.length)),
                    i
                }(f, g);
            const v = []
              , b = {
                positionedLines: v,
                text: f.toString(),
                top: u[1],
                bottom: u[1],
                left: u[0],
                right: u[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t, e, i, r, n, o, s, a, l, c, u, h) {
                let d = 0
                  , p = 0
                  , m = 0;
                const f = "right" === a ? 1 : "left" === a ? 0 : .5;
                let _ = !1;
                for (const t of n) {
                    const i = t.getSections();
                    for (const t of i) {
                        if (t.imageName)
                            continue;
                        const i = e[t.fontStack];
                        if (i && (_ = void 0 !== i.ascender && void 0 !== i.descender,
                        !_))
                            break
                    }
                    if (!_)
                        break
                }
                let g = 0;
                for (const s of n) {
                    s.trim();
                    const n = s.getMaxScale()
                      , a = (n - 1) * ph
                      , x = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t.positionedLines[g] = x;
                    const v = x.positionedGlyphs;
                    let b = 0;
                    if (!s.length()) {
                        p += o,
                        ++g;
                        continue
                    }
                    let w = 0
                      , z = 0;
                    for (let o = 0; o < s.length(); o++) {
                        const a = s.getSection(o)
                          , m = s.getSectionIndex(o)
                          , f = s.getCharCode(o);
                        let g = a.scale
                          , x = null
                          , T = null
                          , E = null
                          , S = ph
                          , M = 0;
                        const A = !(l === Hh.horizontal || !u && !To(f) || u && (ed[f] || (y = f,
                        qn(y) || $n(y) || Yn(y) || fo(y) || xo(y))));
                        if (a.imageName) {
                            const e = r[a.imageName];
                            if (!e)
                                continue;
                            E = a.imageName,
                            t.iconsInText = t.iconsInText || !0,
                            T = e.paddedRect;
                            const i = e.displaySize;
                            g = g * ph / h,
                            x = {
                                width: i[0],
                                height: i[1],
                                left: 1,
                                top: -3,
                                advance: A ? i[1] : i[0],
                                localGlyph: !1
                            },
                            M = _ ? -x.height * g : n * ph - 17 - i[1] * g,
                            S = x.advance;
                            const o = (A ? i[0] : i[1]) * g - ph * n;
                            o > 0 && o > b && (b = o)
                        } else {
                            const t = i[a.fontStack];
                            if (!t)
                                continue;
                            t[f] && (T = t[f]);
                            const r = e[a.fontStack];
                            if (!r)
                                continue;
                            const o = r.glyphs[f];
                            if (!o)
                                continue;
                            if (x = o.metrics,
                            S = 8203 !== f ? ph : 0,
                            _) {
                                const t = void 0 !== r.ascender ? Math.abs(r.ascender) : 0
                                  , e = void 0 !== r.descender ? Math.abs(r.descender) : 0
                                  , i = (t + e) * g;
                                w < i && (w = i,
                                z = (t - e) / 2 * g),
                                M = -t * g
                            } else
                                M = (n - g) * ph - 17
                        }
                        A ? (t.verticalizable = !0,
                        v.push({
                            glyph: f,
                            imageName: E,
                            x: d,
                            y: p + M,
                            vertical: A,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: m,
                            metrics: x,
                            rect: T
                        }),
                        d += S * g + c) : (v.push({
                            glyph: f,
                            imageName: E,
                            x: d,
                            y: p + M,
                            vertical: A,
                            scale: g,
                            localGlyph: x.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: m,
                            metrics: x,
                            rect: T
                        }),
                        d += x.advance * g + c)
                    }
                    0 !== v.length && (m = Math.max(d - c, m),
                    _ ? cd(v, f, b, z, o * n / 2) : cd(v, f, b, 0, o / 2)),
                    d = 0;
                    const T = o * n + b;
                    x.lineOffset = Math.max(b, a),
                    p += T,
                    ++g
                }
                var y;
                const x = p
                  , {horizontalAlign: v, verticalAlign: b} = ld(s);
                (function(t, e, i, r, n, o) {
                    const s = (e - i) * n
                      , a = -o * r;
                    for (const e of t)
                        for (const t of e.positionedGlyphs)
                            t.x += s,
                            t.y += a
                }
                )(t.positionedLines, f, v, b, m, x),
                t.top += -b * x,
                t.bottom = t.top + x,
                t.left += -v * m,
                t.right = t.left + m,
                t.hasBaseline = _
            }(b, e, i, r, _, s, a, l, h, c, d, m),
            !function(t) {
                for (const e of t)
                    if (0 !== e.positionedGlyphs.length)
                        return !1;
                return !0
            }(v) && b
        }
        const ed = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }
          , id = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function rd(t, e, i, r, n, o) {
            if (e.imageName) {
                const t = r[e.imageName];
                return t ? t.displaySize[0] * e.scale * ph / o + n : 0
            }
            {
                const r = i[e.fontStack]
                  , o = r && r.glyphs[t];
                return o ? o.metrics.advance * e.scale + n : 0
            }
        }
        function nd(t, e, i, r) {
            const n = Math.pow(t - e, 2);
            return r ? t < e ? n / 2 : 2 * n : n + Math.abs(i) * i
        }
        function od(t, e, i) {
            let r = 0;
            return 10 === t && (r -= 1e4),
            i && (r += 150),
            40 !== t && 65288 !== t || (r += 50),
            41 !== e && 65289 !== e || (r += 50),
            r
        }
        function sd(t, e, i, r, n, o) {
            let s = null
              , a = nd(e, i, n, o);
            for (const t of r) {
                const r = nd(e - t.x, i, n, o) + t.badness;
                r <= a && (s = t,
                a = r)
            }
            return {
                index: t,
                x: e,
                priorBreak: s,
                badness: a
            }
        }
        function ad(t) {
            return t ? ad(t.priorBreak).concat(t.index) : []
        }
        function ld(t) {
            let e = .5
              , i = .5;
            switch (t) {
            case "right":
            case "top-right":
            case "bottom-right":
                e = 1;
                break;
            case "left":
            case "top-left":
            case "bottom-left":
                e = 0
            }
            switch (t) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
                i = 1;
                break;
            case "top":
            case "top-right":
            case "top-left":
                i = 0
            }
            return {
                horizontalAlign: e,
                verticalAlign: i
            }
        }
        function cd(t, e, i, r, n) {
            if (!(e || i || r || n))
                return;
            const o = t.length - 1
              , s = t[o]
              , a = (s.x + s.metrics.advance * s.scale) * e;
            for (let e = 0; e <= o; e++)
                t[e].x -= a,
                t[e].y += i + r + n
        }
        function ud(t, e, i) {
            const {horizontalAlign: r, verticalAlign: n} = ld(i)
              , o = e[0] - t.displaySize[0] * r
              , s = e[1] - t.displaySize[1] * n;
            return {
                image: t,
                top: s,
                bottom: s + t.displaySize[1],
                left: o,
                right: o + t.displaySize[0]
            }
        }
        function hd(t, e, i, r, n, o) {
            const s = t.image;
            let a;
            if (s.content) {
                const t = s.content
                  , e = s.pixelRatio || 1;
                a = [t[0] / e, t[1] / e, s.displaySize[0] - t[2] / e, s.displaySize[1] - t[3] / e]
            }
            const l = e.left * o
              , c = e.right * o;
            let u, h, d, p;
            "width" === i || "both" === i ? (p = n[0] + l - r[3],
            h = n[0] + c + r[1]) : (p = n[0] + (l + c - s.displaySize[0]) / 2,
            h = p + s.displaySize[0]);
            const m = e.top * o
              , f = e.bottom * o;
            return "height" === i || "both" === i ? (u = n[1] + m - r[0],
            d = n[1] + f + r[2]) : (u = n[1] + (m + f - s.displaySize[1]) / 2,
            d = u + s.displaySize[1]),
            {
                image: s,
                top: u,
                right: h,
                bottom: d,
                left: p,
                collisionPadding: a
            }
        }
        class dd extends m {
            constructor(t, e, i, r, n) {
                super(t, e),
                this.angle = r,
                this.z = i,
                void 0 !== n && (this.segment = n)
            }
            clone() {
                return new dd(this.x,this.y,this.z,this.angle,this.segment)
            }
        }
        function pd(t, e, i, r, n) {
            if (void 0 === e.segment)
                return !0;
            let o = e
              , s = e.segment + 1
              , a = 0;
            for (; a > -i / 2; ) {
                if (s--,
                s < 0)
                    return !1;
                a -= t[s].dist(o),
                o = t[s]
            }
            a += t[s].dist(t[s + 1]),
            s++;
            const l = [];
            let c = 0;
            for (; a < i / 2; ) {
                const e = t[s]
                  , i = t[s + 1];
                if (!i)
                    return !1;
                let o = t[s - 1].angleTo(e) - e.angleTo(i);
                for (o = Math.abs((o + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                l.push({
                    distance: a,
                    angleDelta: o
                }),
                c += o; a - l[0].distance > r; )
                    c -= l.shift().angleDelta;
                if (c > n)
                    return !1;
                s++,
                a += e.dist(i)
            }
            return !0
        }
        function md(t) {
            let e = 0;
            for (let i = 0; i < t.length - 1; i++)
                e += t[i].dist(t[i + 1]);
            return e
        }
        function fd(t, e, i) {
            return t ? .6 * e * i : 0
        }
        function _d(t, e) {
            return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0)
        }
        function gd(t, e, i, r, n, o) {
            const s = fd(i, n, o)
              , a = _d(i, r) * o;
            let l = 0;
            const c = md(t) / 2;
            for (let i = 0; i < t.length - 1; i++) {
                const r = t[i]
                  , n = t[i + 1]
                  , o = r.dist(n);
                if (l + o > c) {
                    const u = (c - l) / o
                      , h = Mi(r.x, n.x, u)
                      , d = Mi(r.y, n.y, u)
                      , p = new dd(h,d,0,n.angleTo(r),i);
                    return !s || pd(t, p, a, s, e) ? p : void 0
                }
                l += o
            }
        }
        function yd(t, e, i, r, n, o, s, a, l) {
            const c = fd(r, o, s)
              , u = _d(r, n)
              , h = u * s
              , d = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
            return e - h < e / 4 && (e = h + e / 4),
            xd(t, d ? e / 2 * a % e : (u / 2 + 2 * o) * s * a % e, e, c, i, h, d, !1, l)
        }
        function xd(t, e, i, r, n, o, s, a, l) {
            const c = o / 2
              , u = md(t);
            let h = 0
              , d = e - i
              , p = [];
            for (let e = 0; e < t.length - 1; e++) {
                const s = t[e]
                  , a = t[e + 1]
                  , m = s.dist(a)
                  , f = a.angleTo(s);
                for (; d + i < h + m; ) {
                    d += i;
                    const _ = (d - h) / m
                      , g = Mi(s.x, a.x, _)
                      , y = Mi(s.y, a.y, _);
                    if (g >= 0 && g < l && y >= 0 && y < l && d - c >= 0 && d + c <= u) {
                        const i = new dd(g,y,0,f,e);
                        i._round(),
                        r && !pd(t, i, o, r, n) || p.push(i)
                    }
                }
                h += m
            }
            return a || p.length || s || (p = xd(t, h / 2, i, r, n, o, s, !0, l)),
            p
        }
        function vd(t, e, i, r, n) {
            const o = [];
            for (let s = 0; s < t.length; s++) {
                const a = t[s];
                let l;
                for (let t = 0; t < a.length - 1; t++) {
                    let s = a[t]
                      , c = a[t + 1];
                    s.x < e && c.x < e || (s.x < e ? s = new m(e,s.y + (e - s.x) / (c.x - s.x) * (c.y - s.y))._round() : c.x < e && (c = new m(e,s.y + (e - s.x) / (c.x - s.x) * (c.y - s.y))._round()),
                    s.y < i && c.y < i || (s.y < i ? s = new m(s.x + (i - s.y) / (c.y - s.y) * (c.x - s.x),i)._round() : c.y < i && (c = new m(s.x + (i - s.y) / (c.y - s.y) * (c.x - s.x),i)._round()),
                    s.x >= r && c.x >= r || (s.x >= r ? s = new m(r,s.y + (r - s.x) / (c.x - s.x) * (c.y - s.y))._round() : c.x >= r && (c = new m(r,s.y + (r - s.x) / (c.x - s.x) * (c.y - s.y))._round()),
                    s.y >= n && c.y >= n || (s.y >= n ? s = new m(s.x + (n - s.y) / (c.y - s.y) * (c.x - s.x),n)._round() : c.y >= n && (c = new m(s.x + (n - s.y) / (c.y - s.y) * (c.x - s.x),n)._round()),
                    l && s.equals(l[l.length - 1]) || (l = [s],
                    o.push(l)),
                    l.push(c)))))
                }
            }
            return o
        }
        jn(dd, "Anchor");
        const bd = 1e20;
        function wd(t, e, i, r, n, o, s, a, l) {
            for (let c = e; c < e + r; c++)
                zd(t, i * o + c, o, n, s, a, l);
            for (let c = i; c < i + n; c++)
                zd(t, c * o + e, 1, r, s, a, l)
        }
        function zd(t, e, i, r, n, o, s) {
            o[0] = 0,
            s[0] = -bd,
            s[1] = bd,
            n[0] = t[e];
            for (let a = 1, l = 0, c = 0; a < r; a++) {
                n[a] = t[e + a * i];
                const r = a * a;
                do {
                    const t = o[l];
                    c = (n[a] - n[t] + r - t * t) / (a - t) / 2
                } while (c <= s[l] && --l > -1);
                l++,
                o[l] = a,
                s[l] = c,
                s[l + 1] = bd
            }
            for (let a = 0, l = 0; a < r; a++) {
                for (; s[l + 1] < a; )
                    l++;
                const r = o[l]
                  , c = a - r;
                t[e + a * i] = n[r] + c * c
            }
        }
        const Td = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class Ed {
            constructor(t, e, i) {
                this.requestManager = t,
                this.localGlyphMode = e,
                this.localFontFamily = i,
                this.entries = {},
                this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                }
            }
            setURL(t) {
                this.url = t
            }
            getGlyphs(t, e) {
                const i = [];
                for (const e in t)
                    for (const r of t[e])
                        i.push({
                            stack: e,
                            id: r
                        });
                M(i, (({stack: t, id: e},i)=>{
                    let r = this.entries[t];
                    r || (r = this.entries[t] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let n = r.glyphs[e];
                    if (void 0 !== n)
                        return void i(null, {
                            stack: t,
                            id: e,
                            glyph: n
                        });
                    if (n = this._tinySDF(r, t, e),
                    n)
                        return r.glyphs[e] = n,
                        void i(null, {
                            stack: t,
                            id: e,
                            glyph: n
                        });
                    const o = Math.floor(e / 256);
                    if (256 * o > 65535)
                        return void i(new Error("glyphs > 65535 not supported"));
                    if (r.ranges[o])
                        return void i(null, {
                            stack: t,
                            id: e,
                            glyph: n
                        });
                    let s = r.requests[o];
                    s || (s = r.requests[o] = [],
                    Ed.loadGlyphRange(t, o, this.url, this.requestManager, ((t,e)=>{
                        if (e) {
                            r.ascender = e.ascender,
                            r.descender = e.descender;
                            for (const t in e.glyphs)
                                this._doesCharSupportLocalGlyph(+t) || (r.glyphs[+t] = e.glyphs[+t]);
                            r.ranges[o] = !0
                        }
                        for (const i of s)
                            i(t, e);
                        delete r.requests[o]
                    }
                    ))),
                    s.push(((r,n)=>{
                        r ? i(r) : n && i(null, {
                            stack: t,
                            id: e,
                            glyph: n.glyphs[e] || null
                        })
                    }
                    ))
                }
                ), ((t,i)=>{
                    if (t)
                        e(t);
                    else if (i) {
                        const t = {};
                        for (const {stack: e, id: r, glyph: n} of i)
                            void 0 === t[e] && (t[e] = {}),
                            void 0 === t[e].glyphs && (t[e].glyphs = {}),
                            t[e].glyphs[r] = n && {
                                id: n.id,
                                bitmap: n.bitmap.clone(),
                                metrics: n.metrics
                            },
                            t[e].ascender = this.entries[e].ascender,
                            t[e].descender = this.entries[e].descender;
                        e(null, t)
                    }
                }
                ))
            }
            _doesCharSupportLocalGlyph(t) {
                return this.localGlyphMode !== Td.none && (this.localGlyphMode === Td.all ? !!this.localFontFamily : !!this.localFontFamily && (co(t) || po(t) || to(t) || eo(t) || Qn(t)))
            }
            _tinySDF(t, e, i) {
                const r = this.localFontFamily;
                if (!r || !this._doesCharSupportLocalGlyph(i))
                    return;
                let n = t.tinySDF;
                if (!n) {
                    let i = "400";
                    /bold/i.test(e) ? i = "900" : /medium/i.test(e) ? i = "500" : /light/i.test(e) && (i = "200"),
                    n = t.tinySDF = new Ed.TinySDF({
                        fontFamily: r,
                        fontWeight: i,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16
                    }),
                    n.fontWeight = i
                }
                if (this.localGlyphs[n.fontWeight][i])
                    return this.localGlyphs[n.fontWeight][i];
                const o = String.fromCharCode(i)
                  , {data: s, width: a, height: l, glyphWidth: c, glyphHeight: u, glyphLeft: h, glyphTop: d, glyphAdvance: p} = n.draw(o);
                return this.localGlyphs[n.fontWeight][i] = {
                    id: i,
                    bitmap: new fc({
                        width: a,
                        height: l
                    },s),
                    metrics: {
                        width: c / 2,
                        height: u / 2,
                        left: h / 2,
                        top: d / 2 - 27,
                        advance: p / 2,
                        localGlyph: !0
                    }
                }
            }
        }
        function Sd(t, e, i, r) {
            const n = []
              , o = t.image
              , s = o.pixelRatio
              , a = o.paddedRect.w - 2
              , l = o.paddedRect.h - 2
              , c = t.right - t.left
              , u = t.bottom - t.top
              , h = o.stretchX || [[0, a]]
              , d = o.stretchY || [[0, l]]
              , p = (t,e)=>t + e[1] - e[0]
              , f = h.reduce(p, 0)
              , _ = d.reduce(p, 0)
              , g = a - f
              , y = l - _;
            let x = 0
              , v = f
              , b = 0
              , w = _
              , z = 0
              , T = g
              , E = 0
              , S = y;
            if (o.content && r) {
                const t = o.content;
                x = Md(h, 0, t[0]),
                b = Md(d, 0, t[1]),
                v = Md(h, t[0], t[2]),
                w = Md(d, t[1], t[3]),
                z = t[0] - x,
                E = t[1] - b,
                T = t[2] - t[0] - v,
                S = t[3] - t[1] - w
            }
            const M = (r,n,a,l)=>{
                const h = Id(r.stretch - x, v, c, t.left)
                  , d = Cd(r.fixed - z, T, r.stretch, f)
                  , p = Id(n.stretch - b, w, u, t.top)
                  , g = Cd(n.fixed - E, S, n.stretch, _)
                  , y = Id(a.stretch - x, v, c, t.left)
                  , M = Cd(a.fixed - z, T, a.stretch, f)
                  , A = Id(l.stretch - b, w, u, t.top)
                  , I = Cd(l.fixed - E, S, l.stretch, _)
                  , C = new m(h,p)
                  , D = new m(y,p)
                  , k = new m(y,A)
                  , P = new m(h,A)
                  , L = new m(d / s,g / s)
                  , O = new m(M / s,I / s)
                  , R = e * Math.PI / 180;
                if (R) {
                    const t = Math.sin(R)
                      , e = Math.cos(R)
                      , i = [e, -t, t, e];
                    C._matMult(i),
                    D._matMult(i),
                    P._matMult(i),
                    k._matMult(i)
                }
                const B = r.stretch + r.fixed
                  , F = n.stretch + n.fixed;
                return {
                    tl: C,
                    tr: D,
                    bl: P,
                    br: k,
                    tex: {
                        x: o.paddedRect.x + 1 + B,
                        y: o.paddedRect.y + 1 + F,
                        w: a.stretch + a.fixed - B,
                        h: l.stretch + l.fixed - F
                    },
                    writingMode: void 0,
                    glyphOffset: [0, 0],
                    sectionIndex: 0,
                    pixelOffsetTL: L,
                    pixelOffsetBR: O,
                    minFontScaleX: T / s / c,
                    minFontScaleY: S / s / u,
                    isSDF: i
                }
            }
            ;
            if (r && (o.stretchX || o.stretchY)) {
                const t = Ad(h, g, f)
                  , e = Ad(d, y, _);
                for (let i = 0; i < t.length - 1; i++) {
                    const r = t[i]
                      , o = t[i + 1];
                    for (let t = 0; t < e.length - 1; t++)
                        n.push(M(r, e[t], o, e[t + 1]))
                }
            } else
                n.push(M({
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: a + 1
                }, {
                    fixed: 0,
                    stretch: l + 1
                }));
            return n
        }
        function Md(t, e, i) {
            let r = 0;
            for (const n of t)
                r += Math.max(e, Math.min(i, n[1])) - Math.max(e, Math.min(i, n[0]));
            return r
        }
        function Ad(t, e, i) {
            const r = [{
                fixed: -1,
                stretch: 0
            }];
            for (const [e,i] of t) {
                const t = r[r.length - 1];
                r.push({
                    fixed: e - t.stretch,
                    stretch: t.stretch
                }),
                r.push({
                    fixed: e - t.stretch,
                    stretch: t.stretch + (i - e)
                })
            }
            return r.push({
                fixed: e + 1,
                stretch: i
            }),
            r
        }
        function Id(t, e, i, r) {
            return t / e * i + r
        }
        function Cd(t, e, i, r) {
            return t - e * i / r
        }
        function Dd(t, e, i, r) {
            const n = e + t.positionedLines[r].lineOffset;
            return 0 === r ? i + n / 2 : i + (n + (e + t.positionedLines[r - 1].lineOffset)) / 2
        }
        Ed.loadGlyphRange = function(t, e, i, r, n) {
            const o = 256 * e
              , s = o + 255
              , a = r.transformRequest(r.normalizeGlyphsURL(i).replace("{fontstack}", t).replace("{range}", `${o}-${s}`), ot.Glyphs);
            ct(a, ((t,e)=>{
                if (t)
                    n(t);
                else if (e) {
                    const t = {}
                      , i = function(t) {
                        return new zh(t).readFields(Jh, {})
                    }(e);
                    for (const e of i.glyphs)
                        t[e.id] = e;
                    n(null, {
                        glyphs: t,
                        ascender: i.ascender,
                        descender: i.descender
                    })
                }
            }
            ))
        }
        ,
        Ed.TinySDF = class {
            constructor({fontSize: t=24, buffer: e=3, radius: i=8, cutoff: r=.25, fontFamily: n="sans-serif", fontWeight: o="normal", fontStyle: s="normal"}={}) {
                this.buffer = e,
                this.cutoff = r,
                this.radius = i;
                const a = this.size = t + 4 * e
                  , l = this._createCanvas(a)
                  , c = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                c.font = `${s} ${o} ${t}px ${n}`,
                c.textBaseline = "alphabetic",
                c.textAlign = "left",
                c.fillStyle = "black",
                this.gridOuter = new Float64Array(a * a),
                this.gridInner = new Float64Array(a * a),
                this.f = new Float64Array(a),
                this.z = new Float64Array(a + 1),
                this.v = new Uint16Array(a)
            }
            _createCanvas(t) {
                const e = document.createElement("canvas");
                return e.width = e.height = t,
                e
            }
            draw(t) {
                const {width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: r, actualBoundingBoxLeft: n, actualBoundingBoxRight: o} = this.ctx.measureText(t)
                  , s = Math.ceil(i)
                  , a = Math.min(this.size - this.buffer, Math.ceil(o - n))
                  , l = Math.min(this.size - this.buffer, s + Math.ceil(r))
                  , c = a + 2 * this.buffer
                  , u = l + 2 * this.buffer
                  , h = Math.max(c * u, 0)
                  , d = new Uint8ClampedArray(h)
                  , p = {
                    data: d,
                    width: c,
                    height: u,
                    glyphWidth: a,
                    glyphHeight: l,
                    glyphTop: s,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === a || 0 === l)
                    return p;
                const {ctx: m, buffer: f, gridInner: _, gridOuter: g} = this;
                m.clearRect(f, f, a, l),
                m.fillText(t, f, f + s);
                const y = m.getImageData(f, f, a, l);
                g.fill(bd, 0, h),
                _.fill(0, 0, h);
                for (let t = 0; t < l; t++)
                    for (let e = 0; e < a; e++) {
                        const i = y.data[4 * (t * a + e) + 3] / 255;
                        if (0 === i)
                            continue;
                        const r = (t + f) * c + e + f;
                        if (1 === i)
                            g[r] = 0,
                            _[r] = bd;
                        else {
                            const t = .5 - i;
                            g[r] = t > 0 ? t * t : 0,
                            _[r] = t < 0 ? t * t : 0
                        }
                    }
                wd(g, 0, 0, c, u, c, this.f, this.v, this.z),
                wd(_, f, f, a, l, c, this.f, this.v, this.z);
                for (let t = 0; t < h; t++) {
                    const e = Math.sqrt(g[t]) - Math.sqrt(_[t]);
                    d[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff))
                }
                return p
            }
        }
        ;
        class kd {
            constructor(t=[], e=Pd) {
                if (this.data = t,
                this.length = this.data.length,
                this.compare = e,
                this.length > 0)
                    for (let t = (this.length >> 1) - 1; t >= 0; t--)
                        this._down(t)
            }
            push(t) {
                this.data.push(t),
                this.length++,
                this._up(this.length - 1)
            }
            pop() {
                if (0 === this.length)
                    return;
                const t = this.data[0]
                  , e = this.data.pop();
                return this.length--,
                this.length > 0 && (this.data[0] = e,
                this._down(0)),
                t
            }
            peek() {
                return this.data[0]
            }
            _up(t) {
                const {data: e, compare: i} = this
                  , r = e[t];
                for (; t > 0; ) {
                    const n = t - 1 >> 1
                      , o = e[n];
                    if (i(r, o) >= 0)
                        break;
                    e[t] = o,
                    t = n
                }
                e[t] = r
            }
            _down(t) {
                const {data: e, compare: i} = this
                  , r = this.length >> 1
                  , n = e[t];
                for (; t < r; ) {
                    let r = 1 + (t << 1)
                      , o = e[r];
                    const s = r + 1;
                    if (s < this.length && i(e[s], o) < 0 && (r = s,
                    o = e[s]),
                    i(o, n) >= 0)
                        break;
                    e[t] = o,
                    t = r
                }
                e[t] = n
            }
        }
        function Pd(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function Ld(t, e=1, i=!1) {
            let r = 1 / 0
              , n = 1 / 0
              , o = -1 / 0
              , s = -1 / 0;
            const a = t[0];
            for (let t = 0; t < a.length; t++) {
                const e = a[t];
                (!t || e.x < r) && (r = e.x),
                (!t || e.y < n) && (n = e.y),
                (!t || e.x > o) && (o = e.x),
                (!t || e.y > s) && (s = e.y)
            }
            const l = Math.min(o - r, s - n);
            let c = l / 2;
            const u = new kd([],Od);
            if (0 === l)
                return new m(r,n);
            for (let e = r; e < o; e += l)
                for (let i = n; i < s; i += l)
                    u.push(new Rd(e + c,i + c,c,t));
            let h = function(t) {
                let e = 0
                  , i = 0
                  , r = 0;
                const n = t[0];
                for (let t = 0, o = n.length, s = o - 1; t < o; s = t++) {
                    const o = n[t]
                      , a = n[s]
                      , l = o.x * a.y - a.x * o.y;
                    i += (o.x + a.x) * l,
                    r += (o.y + a.y) * l,
                    e += 3 * l
                }
                return new Rd(i / e,r / e,0,t)
            }(t)
              , d = u.length;
            for (; u.length; ) {
                const r = u.pop();
                (r.d > h.d || !h.d) && (h = r,
                i && console.log("found best %d after %d probes", Math.round(1e4 * r.d) / 1e4, d)),
                r.max - h.d <= e || (c = r.h / 2,
                u.push(new Rd(r.p.x - c,r.p.y - c,c,t)),
                u.push(new Rd(r.p.x + c,r.p.y - c,c,t)),
                u.push(new Rd(r.p.x - c,r.p.y + c,c,t)),
                u.push(new Rd(r.p.x + c,r.p.y + c,c,t)),
                d += 4)
            }
            return i && (console.log(`num probes: ${d}`),
            console.log(`best distance: ${h.d}`)),
            h.p
        }
        function Od(t, e) {
            return e.max - t.max
        }
        function Rd(t, e, i, r) {
            this.p = new m(t,e),
            this.h = i,
            this.d = function(t, e) {
                let i = !1
                  , r = 1 / 0;
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];
                    for (let e = 0, n = o.length, s = n - 1; e < n; s = e++) {
                        const n = o[e]
                          , a = o[s];
                        n.y > t.y != a.y > t.y && t.x < (a.x - n.x) * (t.y - n.y) / (a.y - n.y) + n.x && (i = !i),
                        r = Math.min(r, rl(t, n, a))
                    }
                }
                return (i ? 1 : -1) * Math.sqrt(r)
            }(this.p, r),
            this.max = this.d + this.h * Math.SQRT2
        }
        const Bd = Number.POSITIVE_INFINITY
          , Fd = Math.sqrt(2);
        function Ud(t, [e,i]) {
            let r = 0
              , n = 0;
            if (i === Bd) {
                e < 0 && (e = 0);
                const i = e / Fd;
                switch (t) {
                case "top-right":
                case "top-left":
                    n = i - 7;
                    break;
                case "bottom-right":
                case "bottom-left":
                    n = 7 - i;
                    break;
                case "bottom":
                    n = 7 - e;
                    break;
                case "top":
                    n = e - 7
                }
                switch (t) {
                case "top-right":
                case "bottom-right":
                    r = -i;
                    break;
                case "top-left":
                case "bottom-left":
                    r = i;
                    break;
                case "left":
                    r = e;
                    break;
                case "right":
                    r = -e
                }
            } else {
                switch (e = Math.abs(e),
                i = Math.abs(i),
                t) {
                case "top-right":
                case "top-left":
                case "top":
                    n = i - 7;
                    break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                    n = 7 - i
                }
                switch (t) {
                case "top-right":
                case "bottom-right":
                case "right":
                    r = -e;
                    break;
                case "top-left":
                case "bottom-left":
                case "left":
                    r = e
                }
            }
            return [r, n]
        }
        function Nd(t, e, i, r, n, o, s, a, l, c) {
            t.createArrays(),
            t.tilePixelRatio = za / (512 * t.overscaling),
            t.compareText = {},
            t.iconsNeedLinear = !1;
            const u = t.layers[0].layout
              , h = t.layers[0]._unevaluatedLayout._values
              , d = {};
            if ("composite" === t.textSizeData.kind) {
                const {minZoom: e, maxZoom: i} = t.textSizeData;
                d.compositeTextSizes = [h["text-size"].possiblyEvaluate(new Go(e), a), h["text-size"].possiblyEvaluate(new Go(i), a)]
            }
            if ("composite" === t.iconSizeData.kind) {
                const {minZoom: e, maxZoom: i} = t.iconSizeData;
                d.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new Go(e), a), h["icon-size"].possiblyEvaluate(new Go(i), a)]
            }
            d.layoutTextSize = h["text-size"].possiblyEvaluate(new Go(l + 1), a),
            d.layoutIconSize = h["icon-size"].possiblyEvaluate(new Go(l + 1), a),
            d.textMaxSize = h["text-size"].possiblyEvaluate(new Go(18), a);
            const p = "map" === u.get("text-rotation-alignment") && "point" !== u.get("symbol-placement")
              , m = u.get("text-size");
            for (const o of t.features) {
                const l = u.get("text-font").evaluate(o, {}, a).join(",")
                  , h = m.evaluate(o, {}, a)
                  , f = d.layoutTextSize.evaluate(o, {}, a)
                  , _ = (d.layoutIconSize.evaluate(o, {}, a),
                {
                    horizontal: {},
                    vertical: void 0
                })
                  , g = o.text;
                let y, x = [0, 0];
                if (g) {
                    const r = g.toString()
                      , s = u.get("text-letter-spacing").evaluate(o, {}, a) * ph
                      , c = u.get("text-line-height").evaluate(o, {}, a) * ph
                      , d = wo(r) ? s : 0
                      , m = u.get("text-anchor").evaluate(o, {}, a)
                      , y = u.get("text-variable-anchor");
                    if (!y) {
                        const t = u.get("text-radial-offset").evaluate(o, {}, a);
                        x = t ? Ud(m, [t * ph, Bd]) : u.get("text-offset").evaluate(o, {}, a).map((t=>t * ph))
                    }
                    let v = p ? "center" : u.get("text-justify").evaluate(o, {}, a);
                    const b = "point" === u.get("symbol-placement")
                      , w = b ? u.get("text-max-width").evaluate(o, {}, a) * ph : 1 / 0
                      , z = o=>{
                        t.allowVerticalPlacement && bo(r) && (_.vertical = td(g, e, i, n, l, w, c, m, o, d, x, Hh.vertical, !0, f, h))
                    }
                    ;
                    if (!p && y) {
                        const t = "auto" === v ? y.map((t=>Gd(t))) : [v];
                        let r = !1;
                        for (let o = 0; o < t.length; o++) {
                            const s = t[o];
                            if (!_.horizontal[s])
                                if (r)
                                    _.horizontal[s] = _.horizontal[0];
                                else {
                                    const t = td(g, e, i, n, l, w, c, "center", s, d, x, Hh.horizontal, !1, f, h);
                                    t && (_.horizontal[s] = t,
                                    r = 1 === t.positionedLines.length)
                                }
                        }
                        z("left")
                    } else {
                        if ("auto" === v && (v = Gd(m)),
                        b || u.get("text-writing-mode").indexOf("horizontal") >= 0 || !bo(r)) {
                            const t = td(g, e, i, n, l, w, c, m, v, d, x, Hh.horizontal, !1, f, h);
                            t && (_.horizontal[v] = t)
                        }
                        z(b ? "left" : v)
                    }
                }
                let v = !1;
                if (o.icon && o.icon.name) {
                    const e = r[o.icon.name];
                    e && (y = ud(n[o.icon.name], u.get("icon-offset").evaluate(o, {}, a), u.get("icon-anchor").evaluate(o, {}, a)),
                    v = e.sdf,
                    void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && G("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                    (e.pixelRatio !== t.pixelRatio || 0 !== u.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0))
                }
                const b = Jd(_.horizontal) || _.vertical;
                t.iconsInText || (t.iconsInText = !!b && b.iconsInText),
                (b || y) && jd(t, o, _, y, r, d, f, 0, x, v, s, a, c)
            }
            o && t.generateCollisionDebugBuffers(l, t.collisionBoxArray)
        }
        function Gd(t) {
            switch (t) {
            case "right":
            case "top-right":
            case "bottom-right":
                return "right";
            case "left":
            case "top-left":
            case "bottom-left":
                return "left"
            }
            return "center"
        }
        function jd(t, e, i, r, n, o, s, a, l, c, u, h, d) {
            let p = o.textMaxSize.evaluate(e, {}, h);
            void 0 === p && (p = s);
            const m = t.layers[0].layout
              , f = m.get("icon-offset").evaluate(e, {}, h)
              , _ = Jd(i.horizontal) || i.vertical
              , g = "globe" === d.name
              , x = s / 24
              , v = t.tilePixelRatio * p / 24
              , b = (I = t.overscaling,
            t.zoom > 18 && I > 2 && (I >>= 1),
            Math.max(za / (512 * I), 1) * m.get("symbol-spacing"))
              , w = m.get("text-padding") * t.tilePixelRatio
              , z = m.get("icon-padding") * t.tilePixelRatio
              , T = y(m.get("text-max-angle"))
              , E = "map" === m.get("text-rotation-alignment") && "point" !== m.get("symbol-placement")
              , S = "map" === m.get("icon-rotation-alignment") && "point" !== m.get("symbol-placement")
              , M = m.get("symbol-placement")
              , A = b / 2;
            var I;
            const C = m.get("icon-text-fit");
            let D;
            r && "none" !== C && (t.allowVerticalPlacement && i.vertical && (D = hd(r, i.vertical, C, m.get("icon-text-fit-padding"), f, x)),
            _ && (r = hd(r, _, C, m.get("icon-text-fit-padding"), f, x)));
            const k = (s,a,p)=>{
                if (a.x < 0 || a.x >= za || a.y < 0 || a.y >= za)
                    return;
                let m = null;
                if (g) {
                    const {x: t, y: e, z: i} = d.projectTilePoint(a.x, a.y, p);
                    m = {
                        anchor: new dd(t,e,i,0,void 0),
                        up: d.upVector(p, a.x, a.y)
                    }
                }
                !function(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x, v, b, w, z, T) {
                    const E = t.addToLineVertexArray(e, r);
                    let S, M, A, I, C, D, k, P = 0, L = 0, O = 0, R = 0, B = -1, F = -1;
                    const U = {};
                    let N = Zs.exports("");
                    const j = i ? i.anchor : e;
                    let V = 0
                      , Z = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [V,Z] = l.layout.get("text-offset").evaluate(v, {}, T).map((t=>t * ph)) : (V = l.layout.get("text-radial-offset").evaluate(v, {}, T) * ph,
                    Z = Bd),
                    t.allowVerticalPlacement && n.vertical) {
                        const t = n.vertical;
                        if (m)
                            D = qd(t),
                            a && (k = qd(a));
                        else {
                            const i = l.layout.get("text-rotate").evaluate(v, {}, T) + 90;
                            A = Xd(c, j, e, u, h, d, t, p, i, f),
                            a && (I = Xd(c, j, e, u, h, d, a, g, i))
                        }
                    }
                    if (o) {
                        const r = l.layout.get("icon-rotate").evaluate(v, {}, T)
                          , n = "none" !== l.layout.get("icon-text-fit")
                          , s = Sd(o, r, w, n)
                          , p = a ? Sd(a, r, w, n) : void 0;
                        M = Xd(c, j, e, u, h, d, o, g, r),
                        P = 4 * s.length;
                        const m = t.iconSizeData;
                        let f = null;
                        "source" === m.kind ? (f = [mh * l.layout.get("icon-size").evaluate(v, {}, T)],
                        f[0] > Vd && G(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === m.kind && (f = [mh * b.compositeIconSizes[0].evaluate(v, {}, T), mh * b.compositeIconSizes[1].evaluate(v, {}, T)],
                        (f[0] > Vd || f[1] > Vd) && G(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                        t.addSymbols(t.icon, s, f, x, y, v, !1, i, e, E.lineStartIndex, E.lineLength, -1, z, T),
                        B = t.icon.placedSymbolArray.length - 1,
                        p && (L = 4 * p.length,
                        t.addSymbols(t.icon, p, f, x, y, v, Hh.vertical, i, e, E.lineStartIndex, E.lineLength, -1, z, T),
                        F = t.icon.placedSymbolArray.length - 1)
                    }
                    for (const r in n.horizontal) {
                        const o = n.horizontal[r];
                        S || (N = Zs.exports(o.text),
                        m ? C = qd(o) : S = Xd(c, j, e, u, h, d, o, p, l.layout.get("text-rotate").evaluate(v, {}, T), f));
                        const a = 1 === o.positionedLines.length;
                        if (O += Zd(t, i, e, o, s, l, m, v, f, E, n.vertical ? Hh.horizontal : Hh.horizontalOnly, a ? Object.keys(n.horizontal) : [r], U, B, b, z, T),
                        a)
                            break
                    }
                    n.vertical && (R += Zd(t, i, e, n.vertical, s, l, m, v, f, E, Hh.vertical, ["vertical"], U, F, b, z, T));
                    let J = -1;
                    const X = (t,e)=>t ? Math.max(t, e) : e;
                    J = X(C, J),
                    J = X(D, J),
                    J = X(k, J);
                    const q = J > -1 ? 1 : 0;
                    t.glyphOffsetArray.length >= sm.MAX_GLYPHS && G("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                    void 0 !== v.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, v.sortKey),
                    t.symbolInstances.emplaceBack(j.x, j.y, j.z, e.x, e.y, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, B, F, N, void 0 !== S ? S : t.collisionBoxArray.length, void 0 !== S ? S + 1 : t.collisionBoxArray.length, void 0 !== A ? A : t.collisionBoxArray.length, void 0 !== A ? A + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, I || t.collisionBoxArray.length, I ? I + 1 : t.collisionBoxArray.length, u, O, R, P, L, q, 0, V, Z, J)
                }(t, a, m, s, i, r, n, D, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, w, E, l, 0, z, S, f, e, o, c, u, h)
            }
            ;
            if ("line" === M)
                for (const n of vd(e.geometry, 0, 0, za, za)) {
                    const e = yd(n, b, T, i.vertical || _, r, 24, v, t.overscaling, za);
                    for (const i of e) {
                        const e = _;
                        e && $d(t, e.text, A, i) || k(n, i, h)
                    }
                }
            else if ("line-center" === M) {
                for (const t of e.geometry)
                    if (t.length > 1) {
                        const e = gd(t, T, i.vertical || _, r, 24, v);
                        e && k(t, e, h)
                    }
            } else if ("Polygon" === e.type)
                for (const t of Kc(e.geometry, 0)) {
                    const e = Ld(t, 16);
                    k(t[0], new dd(e.x,e.y,0,0,void 0), h)
                }
            else if ("LineString" === e.type)
                for (const t of e.geometry)
                    k(t, new dd(t[0].x,t[0].y,0,0,void 0), h);
            else if ("Point" === e.type)
                for (const t of e.geometry)
                    for (const e of t)
                        k([e], new dd(e.x,e.y,0,0,void 0), h)
        }
        const Vd = 32640;
        function Zd(t, e, i, r, n, o, s, a, l, c, u, h, d, p, f, _, g) {
            const y = function(t, e, i, r, n, o, s, a) {
                const l = [];
                if (0 === e.positionedLines.length)
                    return l;
                const c = r.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180
                  , u = function(t) {
                    const e = t[0]
                      , i = t[1]
                      , r = e * i;
                    return r > 0 ? [e, -i] : r < 0 ? [-e, i] : 0 === e ? [i, e] : [i, -e]
                }(i);
                let h = Math.abs(e.top - e.bottom);
                for (const t of e.positionedLines)
                    h -= t.lineOffset;
                const d = e.positionedLines.length
                  , p = h / d;
                let f = e.top - i[1];
                for (let t = 0; t < d; ++t) {
                    const r = e.positionedLines[t];
                    f = Dd(e, p, f, t);
                    for (const t of r.positionedGlyphs) {
                        if (!t.rect)
                            continue;
                        const r = t.rect || {};
                        let o = 4
                          , h = !0
                          , d = 1
                          , p = 0;
                        if (t.imageName) {
                            const e = s[t.imageName];
                            if (!e)
                                continue;
                            if (e.sdf) {
                                G("SDF images are not supported in formatted text and will be ignored.");
                                continue
                            }
                            h = !1,
                            d = e.pixelRatio,
                            o = 1 / d
                        }
                        const _ = (n || a) && t.vertical
                          , g = t.metrics.advance * t.scale / 2
                          , y = t.metrics
                          , x = t.rect;
                        if (null === x)
                            continue;
                        a && e.verticalizable && (p = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);
                        const v = n ? [t.x + g, t.y] : [0, 0];
                        let b = [0, 0]
                          , w = [0, 0]
                          , z = !1;
                        n || (_ ? (w = [t.x + g + u[0], t.y + u[1] - p],
                        z = !0) : b = [t.x + g + i[0], t.y + i[1] - p]);
                        const T = x.w * t.scale / (d * (t.localGlyph ? 2 : 1))
                          , E = x.h * t.scale / (d * (t.localGlyph ? 2 : 1));
                        let S, M, A, I;
                        if (_) {
                            const e = t.y - f
                              , i = new m(-g,g - e)
                              , r = -Math.PI / 2
                              , n = new m(...w);
                            S = new m(-g + b[0],b[1]),
                            S._rotateAround(r, i)._add(n),
                            S.x += -e + g,
                            S.y -= (y.left - o) * t.scale;
                            const s = t.imageName ? y.advance * t.scale : ph * t.scale
                              , a = String.fromCharCode(t.glyph);
                            bh(a) ? S.x += (1 - o) * t.scale : wh(a) ? S.x += s - y.height * t.scale + (-o - 1) * t.scale : S.x += t.imageName || y.width + 2 * o === x.w && y.height + 2 * o === x.h ? (s - E) / 2 : (s - (y.height + 2 * o) * t.scale) / 2,
                            M = new m(S.x,S.y - T),
                            A = new m(S.x + E,S.y),
                            I = new m(S.x + E,S.y - T)
                        } else {
                            const e = (y.left - o) * t.scale - g + b[0]
                              , i = (-y.top - o) * t.scale + b[1]
                              , r = e + T
                              , n = i + E;
                            S = new m(e,i),
                            M = new m(r,i),
                            A = new m(e,n),
                            I = new m(r,n)
                        }
                        if (c) {
                            let t;
                            t = n ? new m(0,0) : z ? new m(u[0],u[1]) : new m(i[0],i[1]),
                            S._rotateAround(c, t),
                            M._rotateAround(c, t),
                            A._rotateAround(c, t),
                            I._rotateAround(c, t)
                        }
                        const C = new m(0,0)
                          , D = new m(0,0);
                        l.push({
                            tl: S,
                            tr: M,
                            bl: A,
                            br: I,
                            tex: r,
                            writingMode: e.writingMode,
                            glyphOffset: v,
                            sectionIndex: t.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: C,
                            pixelOffsetBR: D,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        })
                    }
                }
                return l
            }(0, r, l, o, s, a, n, t.allowVerticalPlacement)
              , x = t.textSizeData;
            let v = null;
            "source" === x.kind ? (v = [mh * o.layout.get("text-size").evaluate(a, {}, g)],
            v[0] > Vd && G(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === x.kind && (v = [mh * f.compositeTextSizes[0].evaluate(a, {}, g), mh * f.compositeTextSizes[1].evaluate(a, {}, g)],
            (v[0] > Vd || v[1] > Vd) && G(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
            t.addSymbols(t.text, y, v, l, s, a, u, e, i, c.lineStartIndex, c.lineLength, p, _, g);
            for (const e of h)
                d[e] = t.text.placedSymbolArray.length - 1;
            return 4 * y.length
        }
        function Jd(t) {
            for (const e in t)
                return t[e];
            return null
        }
        function Xd(t, e, i, r, n, o, s, a, l, c) {
            let u = s.top
              , h = s.bottom
              , d = s.left
              , p = s.right;
            const f = s.collisionPadding;
            if (f && (d -= f[0],
            u -= f[1],
            p += f[2],
            h += f[3]),
            l) {
                const t = new m(d,u)
                  , e = new m(p,u)
                  , i = new m(d,h)
                  , r = new m(p,h)
                  , n = y(l);
                let o = new m(0,0);
                c && (o = new m(c[0],c[1])),
                t._rotateAround(n, o),
                e._rotateAround(n, o),
                i._rotateAround(n, o),
                r._rotateAround(n, o),
                d = Math.min(t.x, e.x, i.x, r.x),
                p = Math.max(t.x, e.x, i.x, r.x),
                u = Math.min(t.y, e.y, i.y, r.y),
                h = Math.max(t.y, e.y, i.y, r.y)
            }
            return t.emplaceBack(e.x, e.y, e.z, i.x, i.y, d, u, p, h, a, r, n, o),
            t.length - 1
        }
        function qd(t) {
            t.collisionPadding && (t.top -= t.collisionPadding[1],
            t.bottom += t.collisionPadding[3]);
            const e = t.bottom - t.top;
            return e > 0 ? Math.max(10, e) : null
        }
        function $d(t, e, i, r) {
            const n = t.compareText;
            if (e in n) {
                const t = n[e];
                for (let e = t.length - 1; e >= 0; e--)
                    if (r.dist(t[e]) < i)
                        return !0
            } else
                n[e] = [];
            return n[e].push(r),
            !1
        }
        const Yd = ns([{
            type: "Float32",
            name: "a_globe_pos",
            components: 3
        }, {
            type: "Float32",
            name: "a_uv",
            components: 2
        }])
          , {members: Wd} = Yd
          , Hd = ns([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }]);
        var Kd = ns([{
            name: "a_pos",
            type: "Int16",
            components: 2
        }]);
        const Qd = za / Math.PI / 2
          , tp = 2 * Da(1, 0) * Qd * Math.PI
          , ep = 64
          , ip = [ep, 32, 16]
          , rp = -Qd
          , np = Qd
          , op = [new oc([rp, rp, rp],[np, np, np]), new oc([rp, rp, rp],[0, 0, np]), new oc([0, rp, rp],[np, 0, np]), new oc([rp, 0, rp],[0, np, np]), new oc([0, 0, rp],[np, np, np])];
        function sp(t, e, i, r=!0) {
            const n = Bl([], t._camera.position, t.worldSize)
              , o = [e, i, 1, 1];
            Wl(o, o, t.pixelMatrixInverse),
            $l(o, o, 1 / o[3]);
            const s = Ul([], Jl([], o, n))
              , a = t.globeMatrix
              , l = [a[12], a[13], a[14]]
              , c = Jl([], l, n)
              , u = Cl(c)
              , h = Ul([], c)
              , d = t.worldSize / (2 * Math.PI)
              , p = Nl(h, s)
              , m = Math.asin(d / u);
            if (m < Math.acos(p)) {
                if (!r)
                    return null;
                const t = []
                  , e = [];
                Bl(t, s, u / p),
                Ul(e, Jl(e, t, c)),
                Ul(s, kl(s, c, Bl(s, e, Math.tan(m) * u)))
            }
            const f = [];
            new ic(n,s).closestPointOnSphere(l, d, f);
            const _ = Ul([], Y(a, 0))
              , g = Ul([], Y(a, 1))
              , y = Ul([], Y(a, 2))
              , v = Nl(_, f)
              , b = Nl(g, f)
              , w = Nl(y, f)
              , z = x(Math.asin(-b / d));
            let E = x(Math.atan2(v, w));
            E = t.center.lng + function(t, e) {
                const i = (e - t + 180) % 360 - 180;
                return i < -180 ? i + 360 : i
            }(t.center.lng, E);
            const S = Ia(E)
              , M = T(Ca(z), 0, 1);
            return new Ba(S,M)
        }
        class ap {
            constructor(t, e, i) {
                this.a = Jl([], t, i),
                this.b = Jl([], e, i),
                this.center = i;
                const r = Ul([], this.a)
                  , n = Ul([], this.b);
                this.angle = Math.acos(Nl(r, n))
            }
        }
        function lp(t, e) {
            if (0 === t.angle)
                return null;
            let i;
            return i = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)),
            i < 0 || i > 1 ? null : function(t, e, i, r) {
                const n = Math.sin(i);
                return t * (Math.sin((1 - r) * i) / n) + e * (Math.sin(r * i) / n)
            }(t.a[e], t.b[e], t.angle, T(i, 0, 1)) + t.center[e]
        }
        function cp(t) {
            if (t.z <= 1)
                return op[t.z + 2 * t.y + t.x];
            const e = mp(pp(t));
            return oc.fromPoints(e)
        }
        function up(t, e, i) {
            return Bl(t, t, 1 - i),
            Fl(t, t, e, i)
        }
        function hp(t, e) {
            const i = zp(e.zoom);
            if (0 === i)
                return cp(t);
            const r = pp(t)
              , n = mp(r)
              , o = Ia(r.getWest()) * e.worldSize
              , s = Ia(r.getEast()) * e.worldSize
              , a = Ca(r.getNorth()) * e.worldSize
              , l = Ca(r.getSouth()) * e.worldSize
              , c = [o, a, 0]
              , u = [s, a, 0]
              , h = [o, l, 0]
              , d = [s, l, 0]
              , p = xl([], e.globeMatrix);
            return jl(c, c, p),
            jl(u, u, p),
            jl(h, h, p),
            jl(d, d, p),
            n[0] = up(n[0], h, i),
            n[1] = up(n[1], d, i),
            n[2] = up(n[2], u, i),
            n[3] = up(n[3], c, i),
            oc.fromPoints(n)
        }
        function dp(t, e, i) {
            for (const r of t)
                jl(r, r, e),
                Bl(r, r, i)
        }
        function pp({x: t, y: e, z: i}) {
            const r = 1 / (1 << i)
              , n = new Sa(ka(t * r),Pa((e + 1) * r))
              , o = new Sa(ka((t + 1) * r),Pa(e * r));
            return new Ta(n,o)
        }
        function mp(t) {
            const e = y(t.getNorth())
              , i = y(t.getSouth())
              , r = Math.cos(e)
              , n = Math.cos(i)
              , o = Math.sin(e)
              , s = Math.sin(i)
              , a = t.getWest()
              , l = t.getEast();
            return [fp(n, s, a), fp(n, s, l), fp(r, o, l), fp(r, o, a)]
        }
        function fp(t, e, i, r=Qd) {
            return i = y(i),
            [t * Math.sin(i) * r, -e * r, t * Math.cos(i) * r]
        }
        function _p(t, e, i) {
            return fp(Math.cos(y(t)), Math.sin(y(t)), e, i)
        }
        function gp(t, e, i, r) {
            const n = 1 << i.z
              , o = (t / za + i.x) / n;
            return _p(Pa((e / za + i.y) / n), ka(o), r)
        }
        function yp({min: t, max: e}) {
            return 16383 / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2])
        }
        const xp = new Float64Array(16);
        function vp(t) {
            const e = yp(t)
              , i = El(xp, [e, e, e]);
            var r, n;
            return bl(i, i, ((r = [])[0] = -(n = t.min)[0],
            r[1] = -n[1],
            r[2] = -n[2],
            r))
        }
        function bp(t) {
            const e = (r = t.min,
            (i = xp)[0] = 1,
            i[1] = 0,
            i[2] = 0,
            i[3] = 0,
            i[4] = 0,
            i[5] = 1,
            i[6] = 0,
            i[7] = 0,
            i[8] = 0,
            i[9] = 0,
            i[10] = 1,
            i[11] = 0,
            i[12] = r[0],
            i[13] = r[1],
            i[14] = r[2],
            i[15] = 1,
            i);
            var i, r;
            const n = 1 / yp(t);
            return wl(e, e, [n, n, n])
        }
        function wp(t, e, i, r, n) {
            const o = function(t) {
                const e = za / (2 * Math.PI);
                return t / (2 * Math.PI) / e
            }(i)
              , s = [t, e, -i / (2 * Math.PI)]
              , a = yl(new Float64Array(16));
            return bl(a, a, s),
            wl(a, a, [o, o, o]),
            zl(a, a, y(-n)),
            Tl(a, a, y(-r)),
            a
        }
        function zp(t) {
            return E(5, 6, t)
        }
        function Tp(t, e) {
            const i = _p(e.lat, e.lng);
            var r, n, o, s, a, l, c, u, h, d;
            return o = (r = Pl([], function(t) {
                const e = _p(t._center.lat, t._center.lng);
                let i = Gl([], Dl(0, 1, 0), e);
                const r = Sl([], -t.angle, e);
                i = jl(i, i, r),
                Sl(r, -t._pitch, i);
                const n = Ul([], e);
                return Bl(n, n, t.cameraToCenterDistance / t.pixelsPerMeter * tp),
                jl(n, n, r),
                kl([], e, n)
            }(t), i))[0],
            s = r[1],
            a = r[2],
            l = (n = i)[0],
            c = n[1],
            u = n[2],
            d = (h = Math.sqrt(o * o + s * s + a * a) * Math.sqrt(l * l + c * c + u * u)) && Nl(r, n) / h,
            Math.acos(Math.min(Math.max(d, -1), 1))
        }
        function Ep(t, e) {
            return Tp(t, e) > Math.PI / 2 * 1.01
        }
        const Sp = y(85)
          , Mp = Math.cos(Sp)
          , Ap = Math.sin(Sp);
        function Ip(t, e) {
            const i = t.fovAboveCenter
              , r = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0
              , n = (t._camera.position[2] * t.worldSize - r) / Math.cos(t._pitch)
              , o = Math.sin(i) * n / Math.sin(Math.max(Math.PI / 2 - t._pitch - i, .01))
              , s = Math.sin(t._pitch) * o + n;
            return Math.min(1.01 * s, n * (1 / t._horizonShift))
        }
        function Cp(t, e) {
            if (!e.isReprojectedInTileSpace)
                return {
                    scale: 1 << t.z,
                    x: t.x,
                    y: t.y,
                    x2: t.x + 1,
                    y2: t.y + 1,
                    projection: e
                };
            const i = Math.pow(2, -t.z)
              , r = t.x * i
              , n = (t.x + 1) * i
              , o = t.y * i
              , s = (t.y + 1) * i
              , a = ka(r)
              , l = ka(n)
              , c = Pa(o)
              , u = Pa(s)
              , h = e.project(a, c)
              , d = e.project(l, c)
              , p = e.project(l, u)
              , m = e.project(a, u);
            let f = Math.min(h.x, d.x, p.x, m.x)
              , _ = Math.min(h.y, d.y, p.y, m.y)
              , g = Math.max(h.x, d.x, p.x, m.x)
              , y = Math.max(h.y, d.y, p.y, m.y);
            const x = i / 16;
            function v(t, i, r, n, o, s) {
                const a = (r + o) / 2
                  , l = (n + s) / 2
                  , c = e.project(ka(a), Pa(l))
                  , u = Math.max(0, f - c.x, _ - c.y, c.x - g, c.y - y);
                f = Math.min(f, c.x),
                g = Math.max(g, c.x),
                _ = Math.min(_, c.y),
                y = Math.max(y, c.y),
                u > x && (v(t, c, r, n, a, l),
                v(c, i, a, l, o, s))
            }
            v(h, d, r, o, n, o),
            v(d, p, n, o, n, s),
            v(p, m, n, s, r, s),
            v(m, h, r, s, r, o),
            f -= x,
            _ -= x,
            g += x,
            y += x;
            const b = 1 / Math.max(g - f, y - _);
            return {
                scale: b,
                x: f * b,
                y: _ * b,
                x2: g * b,
                y2: y * b,
                projection: e
            }
        }
        const Dp = yl(new Float32Array(16));
        class kp {
            constructor(t) {
                this.spec = t,
                this.name = t.name,
                this.wrap = !1,
                this.requiresDraping = !1,
                this.supportsWorldCopies = !1,
                this.supportsTerrain = !1,
                this.supportsFog = !1,
                this.supportsFreeCamera = !1,
                this.zAxisUnit = "meters",
                this.isReprojectedInTileSpace = !0,
                this.unsupportedLayers = ["custom"],
                this.center = [0, 0],
                this.range = [3.5, 7]
            }
            project(t, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                }
            }
            unproject(t, e) {
                return new Sa(0,0)
            }
            projectTilePoint(t, e, i) {
                return {
                    x: t,
                    y: e,
                    z: 0
                }
            }
            locationPoint(t, e, i=!0) {
                return t._coordinatePoint(t.locationCoordinate(e), i)
            }
            pixelsPerMeter(t, e) {
                return Da(1, t) * e
            }
            pixelSpaceConversion(t, e, i) {
                return 1
            }
            farthestPixelDistance(t) {
                return Ip(t, t.pixelsPerMeter)
            }
            pointCoordinate(t, e, i, r) {
                const n = t.horizonLineFromTop(!1)
                  , o = new m(e,Math.max(n, i));
                return t.rayIntersectionCoordinate(t.pointRayIntersection(o, r))
            }
            pointCoordinate3D(t, e, i) {
                const r = new m(e,i);
                if (t.elevation)
                    return t.elevation.pointCoordinate(r);
                {
                    const e = this.pointCoordinate(t, r.x, r.y, 0);
                    return [e.x, e.y, e.z]
                }
            }
            isPointAboveHorizon(t, e) {
                if (t.elevation)
                    return !this.pointCoordinate3D(t, e.x, e.y);
                const i = t.horizonLineFromTop();
                return e.y < i
            }
            createInversionMatrix(t, e) {
                return Dp
            }
            createTileMatrix(t, e, i) {
                let r, n, o;
                const s = i.canonical
                  , a = yl(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = Cp(s, this);
                    r = 1,
                    n = l.x + i.wrap * l.scale,
                    o = l.y,
                    wl(a, a, [r / l.scale, r / l.scale, t.pixelsPerMeter / e])
                } else
                    r = e / t.zoomScale(s.z),
                    n = (s.x + Math.pow(2, s.z) * i.wrap) * r,
                    o = s.y * r;
                return bl(a, a, [n, o, 0]),
                wl(a, a, [r / za, r / za, 1]),
                a
            }
            upVector(t, e, i) {
                return [0, 0, 1]
            }
            upVectorScale(t, e, i) {
                return {
                    metersToTile: 1
                }
            }
        }
        class Pp extends kp {
            constructor(t) {
                super(t),
                this.range = [4, 7],
                this.center = t.center || [-96, 37.5];
                const [e,i] = this.parallels = t.parallels || [29.5, 45.5]
                  , r = Math.sin(y(e));
                this.n = (r + Math.sin(y(i))) / 2,
                this.c = 1 + r * (2 * this.n - r),
                this.r0 = Math.sqrt(this.c) / this.n
            }
            project(t, e) {
                const {n: i, c: r, r0: n} = this
                  , o = y(t - this.center[0])
                  , s = y(e)
                  , a = Math.sqrt(r - 2 * i * Math.sin(s)) / i;
                return {
                    x: a * Math.sin(o * i),
                    y: a * Math.cos(o * i) - n,
                    z: 0
                }
            }
            unproject(t, e) {
                const {n: i, c: r, r0: n} = this
                  , o = n + e;
                let s = Math.atan2(t, Math.abs(o)) * Math.sign(o);
                o * i < 0 && (s -= Math.PI * Math.sign(t) * Math.sign(o));
                const a = y(this.center[0]) * i;
                s = S(s, -Math.PI - a, Math.PI - a);
                const l = T(x(s / i) + this.center[0], -180, 180)
                  , c = Math.asin(T((r - (t * t + o * o) * i * i) / (2 * i), -1, 1))
                  , u = T(x(c), -85.051129, Oa);
                return new Sa(l,u)
            }
        }
        const Lp = 1.340264
          , Op = -.081106
          , Rp = 893e-6
          , Bp = .003796
          , Fp = Math.sqrt(3) / 2;
        class Up extends kp {
            project(t, e) {
                e = e / 180 * Math.PI,
                t = t / 180 * Math.PI;
                const i = Math.asin(Fp * Math.sin(e))
                  , r = i * i
                  , n = r * r * r;
                return {
                    x: .5 * (t * Math.cos(i) / (Fp * (Lp + 3 * Op * r + n * (7 * Rp + 9 * Bp * r))) / Math.PI + .5),
                    y: 1 - .5 * (i * (Lp + Op * r + n * (Rp + Bp * r)) / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI;
                let i = e = (2 * (1 - e) - 1) * Math.PI
                  , r = i * i
                  , n = r * r * r;
                for (let t, o, s, a = 0; a < 12 && (o = i * (Lp + Op * r + n * (Rp + Bp * r)) - e,
                s = Lp + 3 * Op * r + n * (7 * Rp + 9 * Bp * r),
                t = o / s,
                i = T(i - t, -Math.PI / 3, Math.PI / 3),
                r = i * i,
                n = r * r * r,
                !(Math.abs(t) < 1e-12)); ++a)
                    ;
                const o = Fp * t * (Lp + 3 * Op * r + n * (7 * Rp + 9 * Bp * r)) / Math.cos(i)
                  , s = Math.asin(Math.sin(i) / Fp)
                  , a = T(180 * o / Math.PI, -180, 180)
                  , l = T(180 * s / Math.PI, -85.051129, Oa);
                return new Sa(a,l)
            }
        }
        class Np extends kp {
            constructor(t) {
                super(t),
                this.wrap = !0,
                this.supportsWorldCopies = !0
            }
            project(t, e) {
                return {
                    x: .5 + t / 360,
                    y: .5 - e / 360,
                    z: 0
                }
            }
            unproject(t, e) {
                const i = 360 * (t - .5)
                  , r = T(360 * (.5 - e), -85.051129, Oa);
                return new Sa(i,r)
            }
        }
        const Gp = Math.PI / 2;
        function jp(t) {
            return Math.tan((Gp + t) / 2)
        }
        class Vp extends kp {
            constructor(t) {
                super(t),
                this.center = t.center || [0, 30];
                const [e,i] = this.parallels = t.parallels || [30, 30];
                let r = y(e)
                  , n = y(i);
                this.southernCenter = r + n < 0,
                this.southernCenter && (r = -r,
                n = -n);
                const o = Math.cos(r)
                  , s = jp(r);
                this.n = r === n ? Math.sin(r) : Math.log(o / Math.cos(n)) / Math.log(jp(n) / s),
                this.f = o * Math.pow(jp(r), this.n) / this.n
            }
            project(t, e) {
                e = y(e),
                this.southernCenter && (e = -e),
                t = y(t - this.center[0]);
                const i = 1e-6
                  , {n: r, f: n} = this;
                n > 0 ? e < -Gp + i && (e = -Gp + i) : e > Gp - i && (e = Gp - i);
                const o = n / Math.pow(jp(e), r);
                let s = o * Math.sin(r * t)
                  , a = n - o * Math.cos(r * t);
                return s = .5 * (s / Math.PI + .5),
                a = .5 * (a / Math.PI + .5),
                {
                    x: s,
                    y: this.southernCenter ? a : 1 - a,
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI,
                this.southernCenter && (e = 1 - e),
                e = (2 * (1 - e) - .5) * Math.PI;
                const {n: i, f: r} = this
                  , n = r - e
                  , o = Math.sign(n)
                  , s = Math.sign(i) * Math.sqrt(t * t + n * n);
                let a = Math.atan2(t, Math.abs(n)) * o;
                n * i < 0 && (a -= Math.PI * Math.sign(t) * o);
                const l = T(x(a / i) + this.center[0], -180, 180)
                  , c = T(x(2 * Math.atan(Math.pow(r / s, 1 / i)) - Gp), -85.051129, Oa);
                return new Sa(l,this.southernCenter ? -c : c)
            }
        }
        class Zp extends kp {
            constructor(t) {
                super(t),
                this.wrap = !0,
                this.supportsWorldCopies = !0,
                this.supportsTerrain = !0,
                this.supportsFog = !0,
                this.supportsFreeCamera = !0,
                this.isReprojectedInTileSpace = !1,
                this.unsupportedLayers = [],
                this.range = null
            }
            project(t, e) {
                return {
                    x: Ia(t),
                    y: Ca(e),
                    z: 0
                }
            }
            unproject(t, e) {
                const i = ka(t)
                  , r = Pa(e);
                return new Sa(i,r)
            }
        }
        const Jp = y(Oa);
        class Xp extends kp {
            project(t, e) {
                const i = (e = y(e)) * e
                  , r = i * i;
                return {
                    x: .5 * ((t = y(t)) * (.8707 - .131979 * i + r * (r * (.003971 * i - .001529 * r) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + i * (.015085 + r * (.028874 * i - .044475 - .005916 * r))) / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI;
                let i = e = (2 * (1 - e) - 1) * Math.PI
                  , r = 25
                  , n = 0
                  , o = i * i;
                do {
                    o = i * i;
                    const t = o * o;
                    n = (i * (1.007226 + o * (.015085 + t * (.028874 * o - .044475 - .005916 * t))) - e) / (1.007226 + o * (.045255 + t * (.259866 * o - .311325 - .005916 * 11 * t))),
                    i = T(i - n, -Jp, Jp)
                } while (Math.abs(n) > 1e-6 && --r > 0);
                o = i * i;
                const s = T(x(t / (.8707 + o * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979))), -180, 180)
                  , a = x(i);
                return new Sa(s,a)
            }
        }
        const qp = y(Oa);
        class $p extends kp {
            project(t, e) {
                e = y(e),
                t = y(t);
                const i = Math.cos(e)
                  , r = 2 / Math.PI
                  , n = Math.acos(i * Math.cos(t / 2))
                  , o = Math.sin(n) / n
                  , s = .5 * (t * r + 2 * i * Math.sin(t / 2) / o) || 0
                  , a = .5 * (e + Math.sin(e) / o) || 0;
                return {
                    x: .5 * (s / Math.PI + .5),
                    y: 1 - .5 * (a / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                let i = t = (2 * t - .5) * Math.PI
                  , r = e = (2 * (1 - e) - 1) * Math.PI
                  , n = 25;
                const o = 1e-6;
                let s = 0
                  , a = 0;
                do {
                    const n = Math.cos(r)
                      , o = Math.sin(r)
                      , l = 2 * o * n
                      , c = o * o
                      , u = n * n
                      , h = Math.cos(i / 2)
                      , d = Math.sin(i / 2)
                      , p = 2 * h * d
                      , m = d * d
                      , f = 1 - u * h * h
                      , _ = f ? 1 / f : 0
                      , g = f ? Math.acos(n * h) * Math.sqrt(1 / f) : 0
                      , y = .5 * (2 * g * n * d + 2 * i / Math.PI) - t
                      , x = .5 * (g * o + r) - e
                      , v = .5 * _ * (u * m + g * n * h * c) + 1 / Math.PI
                      , b = _ * (p * l / 4 - g * o * d)
                      , w = .125 * _ * (l * d - g * o * u * p)
                      , z = .5 * _ * (c * h + g * m * n) + .5
                      , E = b * w - z * v;
                    s = (x * b - y * z) / E,
                    a = (y * w - x * v) / E,
                    i = T(i - s, -Math.PI, Math.PI),
                    r = T(r - a, -qp, qp)
                } while ((Math.abs(s) > o || Math.abs(a) > o) && --n > 0);
                return new Sa(x(i),x(r))
            }
        }
        class Yp extends kp {
            constructor(t) {
                super(t),
                this.center = t.center || [0, 0],
                this.parallels = t.parallels || [0, 0],
                this.cosPhi = Math.max(.01, Math.cos(y(this.parallels[0]))),
                this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)),
                this.wrap = !0,
                this.supportsWorldCopies = !0
            }
            project(t, e) {
                const {scale: i, cosPhi: r} = this;
                return {
                    x: y(t) * r * i + .5,
                    y: -Math.sin(y(e)) / r * i + .5,
                    z: 0
                }
            }
            unproject(t, e) {
                const {scale: i, cosPhi: r} = this
                  , n = -(e - .5) / i
                  , o = T(x((t - .5) / i) / r, -180, 180)
                  , s = Math.asin(T(n * r, -1, 1))
                  , a = T(x(s), -85.051129, Oa);
                return new Sa(o,a)
            }
        }
        class Wp extends Zp {
            constructor(t) {
                super(t),
                this.requiresDraping = !0,
                this.supportsWorldCopies = !1,
                this.supportsFog = !0,
                this.zAxisUnit = "pixels",
                this.unsupportedLayers = ["debug", "custom"],
                this.range = [3, 5]
            }
            projectTilePoint(t, e, i) {
                const r = gp(t, e, i);
                return jl(r, r, vp(cp(i))),
                {
                    x: r[0],
                    y: r[1],
                    z: r[2]
                }
            }
            locationPoint(t, e) {
                const i = _p(e.lat, e.lng)
                  , r = Ul([], i)
                  , n = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;
                Fl(i, i, r, Da(1, 0) * za * n);
                const o = yl(new Float64Array(16));
                return vl(o, t.pixelMatrix, t.globeMatrix),
                jl(i, i, o),
                new m(i[0],i[1])
            }
            pixelsPerMeter(t, e) {
                return Da(1, 0) * e
            }
            pixelSpaceConversion(t, e, i) {
                const r = Da(1, t) * e
                  , n = Mi(Da(1, 45) * e, r, i);
                return this.pixelsPerMeter(t, e) / n
            }
            createTileMatrix(t, e, i) {
                const r = bp(cp(i.canonical));
                return vl(new Float64Array(16), t.globeMatrix, r)
            }
            createInversionMatrix(t, e) {
                const {center: i} = t
                  , r = vp(cp(e));
                return Tl(r, r, y(i.lng)),
                zl(r, r, y(i.lat)),
                wl(r, r, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]),
                Float32Array.from(r)
            }
            pointCoordinate(t, e, i, r) {
                return sp(t, e, i, !0) || new Ba(0,0)
            }
            pointCoordinate3D(t, e, i) {
                const r = this.pointCoordinate(t, e, i, 0);
                return [r.x, r.y, r.z]
            }
            isPointAboveHorizon(t, e) {
                return !sp(t, e.x, e.y, !1)
            }
            farthestPixelDistance(t) {
                const e = function(t, e) {
                    const i = t.cameraToCenterDistance
                      , r = t._centerAltitude * e
                      , n = t._camera
                      , o = t._camera.forward()
                      , s = kl([], Bl([], o, -i), [0, 0, r])
                      , a = t.worldSize / (2 * Math.PI)
                      , l = [0, 0, -a]
                      , c = t.width / t.height
                      , u = Math.tan(t.fovAboveCenter)
                      , h = Bl([], n.up(), u)
                      , d = Bl([], n.right(), u * c)
                      , p = Ul([], kl([], kl([], o, h), d))
                      , m = [];
                    let f;
                    if (new ic(s,p).closestPointOnSphere(l, a, m)) {
                        const e = kl([], m, l)
                          , i = Jl([], e, s);
                        f = Math.cos(t.fovAboveCenter) * Cl(i)
                    } else {
                        const t = Jl([], s, l)
                          , e = Jl([], l, s);
                        Ul(e, e);
                        const i = Cl(t) - a;
                        f = Math.sqrt(i * (i + 2 * a));
                        const r = Math.acos(f / (a + i)) - Math.acos(Nl(o, e));
                        f *= Math.cos(r)
                    }
                    return 1.01 * f
                }(t, this.pixelsPerMeter(t.center.lat, t.worldSize))
                  , i = zp(t.zoom);
                if (i > 0) {
                    const r = Ip(t, Da(1, t.center.lat) * t.worldSize)
                      , n = t.worldSize / (2 * Math.PI)
                      , o = Math.max(t.width, t.height) / t.worldSize * Math.PI;
                    return Mi(e, r + n * (1 - Math.cos(o)), Math.pow(i, 10))
                }
                return e
            }
            upVector(t, e, i) {
                return gp(e, i, t, 1)
            }
            upVectorScale(t) {
                return {
                    metersToTile: tp * yp(cp(t))
                }
            }
        }
        function Hp(t) {
            const e = t.parallels
              , i = !!e && Math.abs(e[0] + e[1]) < .01;
            switch (t.name) {
            case "mercator":
                return new Zp(t);
            case "equirectangular":
                return new Np(t);
            case "naturalEarth":
                return new Xp(t);
            case "equalEarth":
                return new Up(t);
            case "winkelTripel":
                return new $p(t);
            case "albers":
                return i ? new Yp(t) : new Pp(t);
            case "lambertConformalConic":
                return i ? new Yp(t) : new Vp(t);
            case "globe":
                return new Wp(t)
            }
            throw new Error(`Invalid projection name: ${t.name}`)
        }
        const Kp = wu.types
          , Qp = [{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint8",
            offset: 0
        }];
        function tm(t, e, i, r, n, o, s, a, l, c, u, h, d) {
            const p = a ? Math.min(Vd, Math.round(a[0])) : 0
              , m = a ? Math.min(Vd, Math.round(a[1])) : 0;
            t.emplaceBack(e, i, Math.round(32 * r), Math.round(32 * n), o, s, (p << 1) + (l ? 1 : 0), m, 16 * c, 16 * u, 256 * h, 256 * d)
        }
        function em(t, e, i, r, n, o, s) {
            t.emplaceBack(e, i, r, n, o, s)
        }
        function im(t, e, i, r, n) {
            t.emplaceBack(e, i, r, n),
            t.emplaceBack(e, i, r, n),
            t.emplaceBack(e, i, r, n),
            t.emplaceBack(e, i, r, n)
        }
        function rm(t) {
            for (const e of t.sections)
                if (Ao(e.text))
                    return !0;
            return !1
        }
        class nm {
            constructor(t) {
                this.layoutVertexArray = new ms,
                this.indexArray = new ws,
                this.programConfigurations = t,
                this.segments = new wa,
                this.dynamicLayoutVertexArray = new us,
                this.opacityVertexArray = new _s,
                this.placedSymbolArray = new Ls,
                this.globeExtVertexArray = new fs
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length
            }
            upload(t, e, i, r) {
                this.isEmpty() || (i && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sh.members),
                this.indexBuffer = t.createIndexBuffer(this.indexArray, e),
                this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, lh.members, !0),
                this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Qp, !0),
                this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, ah.members, !0)),
                this.opacityVertexBuffer.itemSize = 1),
                (i || r) && this.programConfigurations.upload(t))
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.dynamicLayoutVertexBuffer.destroy(),
                this.opacityVertexBuffer.destroy(),
                this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
            }
        }
        jn(nm, "SymbolBuffers");
        class om {
            constructor(t, e, i) {
                this.layoutVertexArray = new t,
                this.layoutAttributes = e,
                this.indexArray = new i,
                this.segments = new wa,
                this.collisionVertexArray = new vs,
                this.collisionVertexArrayExt = new bs
            }
            upload(t) {
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ch.members, !0),
                this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, uh.members, !0)
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.segments.destroy(),
                this.collisionVertexBuffer.destroy(),
                this.collisionVertexBufferExt.destroy())
            }
        }
        jn(om, "CollisionBuffers");
        class sm {
            constructor(t) {
                this.collisionBoxArray = t.collisionBoxArray,
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t=>t.id)),
                this.index = t.index,
                this.pixelRatio = t.pixelRatio,
                this.sourceLayerIndex = t.sourceLayerIndex,
                this.hasPattern = !1,
                this.hasRTLText = !1,
                this.fullyClipped = !1,
                this.sortKeyRanges = [],
                this.collisionCircleArray = [],
                this.placementInvProjMatrix = yl([]),
                this.placementViewportMatrix = yl([]);
                const e = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = fh(this.zoom, e["text-size"]),
                this.iconSizeData = fh(this.zoom, e["icon-size"]);
                const i = this.layers[0].layout
                  , r = i.get("symbol-sort-key")
                  , n = i.get("symbol-z-order");
                this.canOverlap = i.get("text-allow-overlap") || i.get("icon-allow-overlap") || i.get("text-ignore-placement") || i.get("icon-ignore-placement"),
                this.sortFeaturesByKey = "viewport-y" !== n && void 0 !== r.constantOr(1),
                this.sortFeaturesByY = ("viewport-y" === n || "auto" === n && !this.sortFeaturesByKey) && this.canOverlap,
                this.writingModes = i.get("text-writing-mode").map((t=>Hh[t])),
                this.stateDependentLayerIds = this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),
                this.sourceID = t.sourceID,
                this.projection = t.projection
            }
            createArrays() {
                this.text = new nm(new pa(this.layers,this.zoom,(t=>/^text/.test(t)))),
                this.icon = new nm(new pa(this.layers,this.zoom,(t=>/^icon/.test(t)))),
                this.glyphOffsetArray = new Bs,
                this.lineVertexArray = new Fs,
                this.symbolInstances = new Rs
            }
            calculateGlyphDependencies(t, e, i, r, n) {
                for (let i = 0; i < t.length; i++)
                    if (e[t.charCodeAt(i)] = !0,
                    r && n) {
                        const r = vh[t.charAt(i)];
                        r && (e[r.charCodeAt(0)] = !0)
                    }
            }
            populate(t, e, i, r) {
                const n = this.layers[0]
                  , o = n.layout
                  , s = "globe" === this.projection.name
                  , a = o.get("text-font")
                  , l = o.get("text-field")
                  , c = o.get("icon-image")
                  , u = ("constant" !== l.value.kind || l.value.value instanceof Ce && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0)
                  , h = "constant" !== c.value.kind || !!c.value.value || Object.keys(c.parameters).length > 0
                  , d = o.get("symbol-sort-key");
                if (this.features = [],
                !u && !h)
                    return;
                const p = e.iconDependencies
                  , m = e.glyphDependencies
                  , f = e.availableImages
                  , _ = new Go(this.zoom);
                for (const {feature: e, id: l, index: c, sourceLayerIndex: g} of t) {
                    const t = n._featureFilter.needGeometry
                      , y = Xa(e, t);
                    if (!n._featureFilter.filter(_, y, i))
                        continue;
                    if (t || (y.geometry = Ja(e, i, r)),
                    s && 1 !== e.type && i.z <= 5) {
                        const t = y.geometry
                          , e = .98078528056
                          , r = (t,r)=>Nl(gp(t.x, t.y, i, 1), gp(r.x, r.y, i, 1)) < e;
                        for (let e = 0; e < t.length; e++)
                            t[e] = Ga(t[e], r)
                    }
                    let x, v;
                    if (u) {
                        const t = n.getValueAndResolveTokens("text-field", y, i, f)
                          , e = Ce.factory(t);
                        rm(e) && (this.hasRTLText = !0),
                        (!this.hasRTLText || "unavailable" === Fo() || this.hasRTLText && No.isParsed()) && (x = xh(e, n, y))
                    }
                    if (h) {
                        const t = n.getValueAndResolveTokens("icon-image", y, i, f);
                        v = t instanceof De ? t : De.fromString(t)
                    }
                    if (!x && !v)
                        continue;
                    const b = this.sortFeaturesByKey ? d.evaluate(y, {}, i) : void 0;
                    if (this.features.push({
                        id: l,
                        text: x,
                        icon: v,
                        index: c,
                        sourceLayerIndex: g,
                        geometry: y.geometry,
                        properties: e.properties,
                        type: Kp[e.type],
                        sortKey: b
                    }),
                    v && (p[v.name] = !0),
                    x) {
                        const t = a.evaluate(y, {}, i).join(",")
                          , e = "map" === o.get("text-rotation-alignment") && "point" !== o.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Hh.vertical) >= 0;
                        for (const i of x.sections)
                            if (i.image)
                                p[i.image.name] = !0;
                            else {
                                const r = bo(x.toString())
                                  , n = i.fontStack || t
                                  , o = m[n] = m[n] || {};
                                this.calculateGlyphDependencies(i.text, o, e, this.allowVerticalPlacement, r)
                            }
                    }
                }
                "line" === o.get("symbol-placement") && (this.features = function(t) {
                    const e = {}
                      , i = {}
                      , r = [];
                    let n = 0;
                    function o(e) {
                        r.push(t[e]),
                        n++
                    }
                    function s(t, e, n) {
                        const o = i[t];
                        return delete i[t],
                        i[e] = o,
                        r[o].geometry[0].pop(),
                        r[o].geometry[0] = r[o].geometry[0].concat(n[0]),
                        o
                    }
                    function a(t, i, n) {
                        const o = e[i];
                        return delete e[i],
                        e[t] = o,
                        r[o].geometry[0].shift(),
                        r[o].geometry[0] = n[0].concat(r[o].geometry[0]),
                        o
                    }
                    function l(t, e, i) {
                        const r = i ? e[0][e[0].length - 1] : e[0][0];
                        return `${t}:${r.x}:${r.y}`
                    }
                    for (let c = 0; c < t.length; c++) {
                        const u = t[c]
                          , h = u.geometry
                          , d = u.text ? u.text.toString() : null;
                        if (!d) {
                            o(c);
                            continue
                        }
                        const p = l(d, h)
                          , m = l(d, h, !0);
                        if (p in i && m in e && i[p] !== e[m]) {
                            const t = a(p, m, h)
                              , n = s(p, m, r[t].geometry);
                            delete e[p],
                            delete i[m],
                            i[l(d, r[n].geometry, !0)] = n,
                            r[t].geometry = null
                        } else
                            p in i ? s(p, m, h) : m in e ? a(p, m, h) : (o(c),
                            e[p] = n - 1,
                            i[m] = n - 1)
                    }
                    return r.filter((t=>t.geometry))
                }(this.features)),
                this.sortFeaturesByKey && this.features.sort(((t,e)=>t.sortKey - e.sortKey))
            }
            update(t, e, i, r) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, i, r),
                this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, i, r))
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
            }
            upload(t) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                this.iconCollisionBox.upload(t)),
                this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                this.uploaded = !0
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(),
                this.iconCollisionBox.destroy()
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = Hp(this.projection)),
                this.projectionInstance
            }
            destroy() {
                this.text.destroy(),
                this.icon.destroy(),
                this.hasDebugData() && this.destroyDebugData()
            }
            addToLineVertexArray(t, e) {
                const i = this.lineVertexArray.length;
                if (void 0 !== t.segment)
                    for (const {x: t, y: i} of e)
                        this.lineVertexArray.emplaceBack(t, i);
                return {
                    lineStartIndex: i,
                    lineLength: this.lineVertexArray.length - i
                }
            }
            addSymbols(t, e, i, r, n, o, s, a, l, c, u, h, d, p) {
                const m = t.indexArray
                  , f = t.layoutVertexArray
                  , _ = t.globeExtVertexArray
                  , g = t.segments.prepareSegment(4 * e.length, f, m, this.canOverlap ? o.sortKey : void 0)
                  , y = this.glyphOffsetArray.length
                  , x = g.vertexLength
                  , v = this.allowVerticalPlacement && s === Hh.vertical ? Math.PI / 2 : 0
                  , b = o.text && o.text.sections;
                for (let r = 0; r < e.length; r++) {
                    const {tl: n, tr: s, bl: c, br: u, tex: h, pixelOffsetTL: y, pixelOffsetBR: x, minFontScaleX: w, minFontScaleY: z, glyphOffset: T, isSDF: E, sectionIndex: S} = e[r]
                      , M = g.vertexLength
                      , A = T[1];
                    if (tm(f, l.x, l.y, n.x, A + n.y, h.x, h.y, i, E, y.x, y.y, w, z),
                    tm(f, l.x, l.y, s.x, A + s.y, h.x + h.w, h.y, i, E, x.x, y.y, w, z),
                    tm(f, l.x, l.y, c.x, A + c.y, h.x, h.y + h.h, i, E, y.x, x.y, w, z),
                    tm(f, l.x, l.y, u.x, A + u.y, h.x + h.w, h.y + h.h, i, E, x.x, x.y, w, z),
                    a) {
                        const {x: e, y: i, z: r} = a.anchor
                          , [n,o,s] = a.up;
                        em(_, e, i, r, n, o, s),
                        em(_, e, i, r, n, o, s),
                        em(_, e, i, r, n, o, s),
                        em(_, e, i, r, n, o, s),
                        im(t.dynamicLayoutVertexArray, e, i, r, v)
                    } else
                        im(t.dynamicLayoutVertexArray, l.x, l.y, l.z, v);
                    m.emplaceBack(M, M + 1, M + 2),
                    m.emplaceBack(M + 1, M + 2, M + 3),
                    g.vertexLength += 4,
                    g.primitiveLength += 2,
                    this.glyphOffsetArray.emplaceBack(T[0]),
                    r !== e.length - 1 && S === e[r + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, o, o.index, {}, d, p, b && b[S])
                }
                const w = a ? a.anchor : l;
                t.placedSymbolArray.emplaceBack(w.x, w.y, w.z, l.x, l.y, y, this.glyphOffsetArray.length - y, x, c, u, l.segment, i ? i[0] : 0, i ? i[1] : 0, r[0], r[1], s, 0, !1, 0, h, 0)
            }
            _commitLayoutVertex(t, e, i, r, n, o, s) {
                t.emplaceBack(e, i, r, n, o, Math.round(s.x), Math.round(s.y))
            }
            _addCollisionDebugVertices(t, e, i, r, n, o, s) {
                const a = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray)
                  , l = a.vertexLength
                  , c = s.tileAnchorX
                  , u = s.tileAnchorY;
                for (let t = 0; t < 4; t++)
                    i.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                i.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding),
                i.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding),
                i.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding),
                i.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding),
                this._commitLayoutVertex(i.layoutVertexArray, r, n, o, c, u, new m(t.x1,t.y1)),
                this._commitLayoutVertex(i.layoutVertexArray, r, n, o, c, u, new m(t.x2,t.y1)),
                this._commitLayoutVertex(i.layoutVertexArray, r, n, o, c, u, new m(t.x2,t.y2)),
                this._commitLayoutVertex(i.layoutVertexArray, r, n, o, c, u, new m(t.x1,t.y2)),
                a.vertexLength += 4;
                const h = i.indexArray;
                h.emplaceBack(l, l + 1),
                h.emplaceBack(l + 1, l + 2),
                h.emplaceBack(l + 2, l + 3),
                h.emplaceBack(l + 3, l),
                a.primitiveLength += 4
            }
            _addTextDebugCollisionBoxes(t, e, i, r, n, o) {
                for (let s = r; s < n; s++) {
                    const r = i.get(s)
                      , n = this.getSymbolInstanceTextSize(t, o, e, s);
                    this._addCollisionDebugVertices(r, n, this.textCollisionBox, r.projectedAnchorX, r.projectedAnchorY, r.projectedAnchorZ, o)
                }
            }
            _addIconDebugCollisionBoxes(t, e, i, r, n, o) {
                for (let s = r; s < n; s++) {
                    const r = i.get(s)
                      , n = this.getSymbolInstanceIconSize(t, e, o.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(r, n, this.iconCollisionBox, r.projectedAnchorX, r.projectedAnchorY, r.projectedAnchorZ, o)
                }
            }
            generateCollisionDebugBuffers(t, e) {
                this.hasDebugData() && this.destroyDebugData(),
                this.textCollisionBox = new om(ys,hh.members,As),
                this.iconCollisionBox = new om(ys,hh.members,As);
                const i = gh(this.iconSizeData, t)
                  , r = gh(this.textSizeData, t);
                for (let n = 0; n < this.symbolInstances.length; n++) {
                    const o = this.symbolInstances.get(n);
                    this._addTextDebugCollisionBoxes(r, t, e, o.textBoxStartIndex, o.textBoxEndIndex, o),
                    this._addTextDebugCollisionBoxes(r, t, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o),
                    this._addIconDebugCollisionBoxes(i, t, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o),
                    this._addIconDebugCollisionBoxes(i, t, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o)
                }
            }
            getSymbolInstanceTextSize(t, e, i, r) {
                const n = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : r)
                  , o = _h(this.textSizeData, t, n) / ph;
                return this.tilePixelRatio * o
            }
            getSymbolInstanceIconSize(t, e, i) {
                const r = this.icon.placedSymbolArray.get(i)
                  , n = _h(this.iconSizeData, t, r);
                return this.tilePixelRatio * n
            }
            _commitDebugCollisionVertexUpdate(t, e, i) {
                t.emplaceBack(e, -i, -i),
                t.emplaceBack(e, i, -i),
                t.emplaceBack(e, i, i),
                t.emplaceBack(e, -i, i)
            }
            _updateTextDebugCollisionBoxes(t, e, i, r, n, o) {
                for (let s = r; s < n; s++) {
                    const r = i.get(s)
                      , n = this.getSymbolInstanceTextSize(t, o, e, s);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, n, r.padding)
                }
            }
            _updateIconDebugCollisionBoxes(t, e, i, r, n, o) {
                for (let s = r; s < n; s++) {
                    const r = i.get(s)
                      , n = this.getSymbolInstanceIconSize(t, e, o);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, n, r.padding)
                }
            }
            updateCollisionDebugBuffers(t, e) {
                if (!this.hasDebugData())
                    return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(),
                this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const i = gh(this.iconSizeData, t)
                  , r = gh(this.textSizeData, t);
                for (let n = 0; n < this.symbolInstances.length; n++) {
                    const o = this.symbolInstances.get(n);
                    this._updateTextDebugCollisionBoxes(r, t, e, o.textBoxStartIndex, o.textBoxEndIndex, o),
                    this._updateTextDebugCollisionBoxes(r, t, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o),
                    this._updateIconDebugCollisionBoxes(i, t, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o.placedIconSymbolIndex),
                    this._updateIconDebugCollisionBoxes(i, t, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o.placedIconSymbolIndex)
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),
                this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
            }
            _deserializeCollisionBoxesForSymbol(t, e, i, r, n, o, s, a, l) {
                const c = {};
                if (e < i) {
                    const {x1: i, y1: r, x2: n, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p} = t.get(e);
                    c.textBox = {
                        x1: i,
                        y1: r,
                        x2: n,
                        y2: o,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: u,
                        tileAnchorX: h,
                        tileAnchorY: d
                    },
                    c.textFeatureIndex = p
                }
                if (r < n) {
                    const {x1: e, y1: i, x2: n, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p} = t.get(r);
                    c.verticalTextBox = {
                        x1: e,
                        y1: i,
                        x2: n,
                        y2: o,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: u,
                        tileAnchorX: h,
                        tileAnchorY: d
                    },
                    c.verticalTextFeatureIndex = p
                }
                if (o < s) {
                    const {x1: e, y1: i, x2: r, y2: n, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p} = t.get(o);
                    c.iconBox = {
                        x1: e,
                        y1: i,
                        x2: r,
                        y2: n,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: u,
                        tileAnchorX: h,
                        tileAnchorY: d
                    },
                    c.iconFeatureIndex = p
                }
                if (a < l) {
                    const {x1: e, y1: i, x2: r, y2: n, padding: o, projectedAnchorX: s, projectedAnchorY: l, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p} = t.get(a);
                    c.verticalIconBox = {
                        x1: e,
                        y1: i,
                        x2: r,
                        y2: n,
                        padding: o,
                        projectedAnchorX: s,
                        projectedAnchorY: l,
                        projectedAnchorZ: u,
                        tileAnchorX: h,
                        tileAnchorY: d
                    },
                    c.verticalIconFeatureIndex = p
                }
                return c
            }
            deserializeCollisionBoxes(t) {
                this.collisionArrays = [];
                for (let e = 0; e < this.symbolInstances.length; e++) {
                    const i = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex))
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0
            }
            hasIconData() {
                return this.icon.segments.get().length > 0
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
            }
            addIndicesForPlacedSymbol(t, e) {
                const i = t.placedSymbolArray.get(e)
                  , r = i.vertexStartIndex + 4 * i.numGlyphs;
                for (let e = i.vertexStartIndex; e < r; e += 4)
                    t.indexArray.emplaceBack(e, e + 1, e + 2),
                    t.indexArray.emplaceBack(e + 1, e + 2, e + 3)
            }
            getSortedSymbolIndexes(t) {
                if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes)
                    return this.symbolInstanceIndexes;
                const e = Math.sin(t)
                  , i = Math.cos(t)
                  , r = []
                  , n = []
                  , o = [];
                for (let t = 0; t < this.symbolInstances.length; ++t) {
                    o.push(t);
                    const s = this.symbolInstances.get(t);
                    r.push(0 | Math.round(e * s.tileAnchorX + i * s.tileAnchorY)),
                    n.push(s.featureIndex)
                }
                return o.sort(((t,e)=>r[t] - r[e] || n[e] - n[t])),
                o
            }
            addToSortKeyRanges(t, e) {
                const i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                i && i.sortKey === e ? i.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t,
                    symbolInstanceEnd: t + 1
                })
            }
            sortFeatures(t) {
                if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                    this.sortedAngle = t,
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    this.featureSortOrder = [];
                    for (const t of this.symbolInstanceIndexes) {
                        const e = this.symbolInstances.get(t);
                        this.featureSortOrder.push(e.featureIndex);
                        const {rightJustifiedTextSymbolIndex: i, centerJustifiedTextSymbolIndex: r, leftJustifiedTextSymbolIndex: n, verticalPlacedTextSymbolIndex: o, placedIconSymbolIndex: s, verticalPlacedIconSymbolIndex: a} = e;
                        i >= 0 && this.addIndicesForPlacedSymbol(this.text, i),
                        r >= 0 && r !== i && this.addIndicesForPlacedSymbol(this.text, r),
                        n >= 0 && n !== r && n !== i && this.addIndicesForPlacedSymbol(this.text, n),
                        o >= 0 && this.addIndicesForPlacedSymbol(this.text, o),
                        s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s),
                        a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a)
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                }
            }
        }
        jn(sm, "SymbolBucket", {
            omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }),
        sm.MAX_GLYPHS = 65535,
        sm.addDynamicAttributes = im;
        const am = new Qo({
            "symbol-placement": new Wo(Wt.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Wo(Wt.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Wo(Wt.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new Ho(Wt.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Wo(Wt.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Wo(Wt.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new Wo(Wt.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Wo(Wt.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Wo(Wt.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new Ho(Wt.layout_symbol["icon-size"]),
            "icon-text-fit": new Wo(Wt.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Wo(Wt.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new Ho(Wt.layout_symbol["icon-image"]),
            "icon-rotate": new Ho(Wt.layout_symbol["icon-rotate"]),
            "icon-padding": new Wo(Wt.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Wo(Wt.layout_symbol["icon-keep-upright"]),
            "icon-offset": new Ho(Wt.layout_symbol["icon-offset"]),
            "icon-anchor": new Ho(Wt.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Wo(Wt.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Wo(Wt.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Wo(Wt.layout_symbol["text-rotation-alignment"]),
            "text-field": new Ho(Wt.layout_symbol["text-field"]),
            "text-font": new Ho(Wt.layout_symbol["text-font"]),
            "text-size": new Ho(Wt.layout_symbol["text-size"]),
            "text-max-width": new Ho(Wt.layout_symbol["text-max-width"]),
            "text-line-height": new Ho(Wt.layout_symbol["text-line-height"]),
            "text-letter-spacing": new Ho(Wt.layout_symbol["text-letter-spacing"]),
            "text-justify": new Ho(Wt.layout_symbol["text-justify"]),
            "text-radial-offset": new Ho(Wt.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Wo(Wt.layout_symbol["text-variable-anchor"]),
            "text-anchor": new Ho(Wt.layout_symbol["text-anchor"]),
            "text-max-angle": new Wo(Wt.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Wo(Wt.layout_symbol["text-writing-mode"]),
            "text-rotate": new Ho(Wt.layout_symbol["text-rotate"]),
            "text-padding": new Wo(Wt.layout_symbol["text-padding"]),
            "text-keep-upright": new Wo(Wt.layout_symbol["text-keep-upright"]),
            "text-transform": new Ho(Wt.layout_symbol["text-transform"]),
            "text-offset": new Ho(Wt.layout_symbol["text-offset"]),
            "text-allow-overlap": new Wo(Wt.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new Wo(Wt.layout_symbol["text-ignore-placement"]),
            "text-optional": new Wo(Wt.layout_symbol["text-optional"])
        });
        var lm = {
            paint: new Qo({
                "icon-opacity": new Ho(Wt.paint_symbol["icon-opacity"]),
                "icon-color": new Ho(Wt.paint_symbol["icon-color"]),
                "icon-halo-color": new Ho(Wt.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new Ho(Wt.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new Ho(Wt.paint_symbol["icon-halo-blur"]),
                "icon-translate": new Wo(Wt.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new Wo(Wt.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new Ho(Wt.paint_symbol["text-opacity"]),
                "text-color": new Ho(Wt.paint_symbol["text-color"],{
                    runtimeType: le,
                    getOverride: t=>t.textColor,
                    hasOverride: t=>!!t.textColor
                }),
                "text-halo-color": new Ho(Wt.paint_symbol["text-halo-color"]),
                "text-halo-width": new Ho(Wt.paint_symbol["text-halo-width"]),
                "text-halo-blur": new Ho(Wt.paint_symbol["text-halo-blur"]),
                "text-translate": new Wo(Wt.paint_symbol["text-translate"]),
                "text-translate-anchor": new Wo(Wt.paint_symbol["text-translate-anchor"])
            }),
            layout: am
        };
        class cm {
            constructor(t) {
                this.type = t.property.overrides ? t.property.overrides.runtimeType : ne,
                this.defaultValue = t
            }
            evaluate(t) {
                if (t.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t.formattedSection))
                        return e.getOverride(t.formattedSection)
                }
                return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
            }
            eachChild(t) {
                this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return null
            }
        }
        jn(cm, "FormatSectionOverride", {
            omit: ["defaultValue"]
        });
        class um extends xa {
            constructor(t) {
                super(t, lm)
            }
            recalculate(t, e) {
                super.recalculate(t, e),
                "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")),
                "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const i = this.layout.get("text-writing-mode");
                if (i) {
                    const t = [];
                    for (const e of i)
                        t.indexOf(e) < 0 && t.push(e);
                    this.layout._values["text-writing-mode"] = t
                } else
                    this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                this._setPaintOverrides()
            }
            getValueAndResolveTokens(t, e, i, r) {
                const n = this.layout.get(t).evaluate(e, {}, i, r)
                  , o = this._unevaluatedLayout._values[t];
                return o.isDataDriven() || Vr(o.value) || !n ? n : (s = e.properties,
                n.replace(/{([^{}]+)}/g, ((t,e)=>e in s ? String(s[e]) : "")));
                var s
            }
            createBucket(t) {
                return new sm(t)
            }
            queryRadius() {
                return 0
            }
            queryIntersectsFeature() {
                return !1
            }
            _setPaintOverrides() {
                for (const t of lm.paint.overridableProperties) {
                    if (!um.hasPaintOverride(this.layout, t))
                        continue;
                    const e = this.paint.get(t)
                      , i = new cm(e)
                      , r = new jr(i,e.property.specification);
                    let n = null;
                    n = "constant" === e.value.kind || "source" === e.value.kind ? new Jr("source",r) : new Xr("composite",r,e.value.zoomStops,e.value._interpolationType),
                    this.paint._values[t] = new $o(e.property,n,e.parameters)
                }
            }
            _handleOverridablePaintPropertyUpdate(t, e, i) {
                return !(!this.layout || e.isDataDriven() || i.isDataDriven()) && um.hasPaintOverride(this.layout, t)
            }
            static hasPaintOverride(t, e) {
                const i = t.get("text-field")
                  , r = lm.paint.properties[e];
                let n = !1;
                const o = t=>{
                    for (const e of t)
                        if (r.overrides && r.overrides.hasOverride(e))
                            return void (n = !0)
                }
                ;
                if ("constant" === i.value.kind && i.value.value instanceof Ce)
                    o(i.value.value.sections);
                else if ("source" === i.value.kind) {
                    const t = e=>{
                        n || (e instanceof Be && Le(e.value) === de ? o(e.value.sections) : e instanceof je ? o(e.sections) : e.eachChild(t))
                    }
                      , e = i.value;
                    e._styleExpression && t(e._styleExpression.expression)
                }
                return n
            }
            getProgramConfiguration(t) {
                return new da(this,t)
            }
        }
        var hm = {
            paint: new Qo({
                "background-color": new Wo(Wt.paint_background["background-color"]),
                "background-pattern": new Wo(Wt.paint_background["background-pattern"]),
                "background-opacity": new Wo(Wt.paint_background["background-opacity"])
            })
        }
          , dm = {
            paint: new Qo({
                "raster-opacity": new Wo(Wt.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new Wo(Wt.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new Wo(Wt.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new Wo(Wt.paint_raster["raster-brightness-max"]),
                "raster-saturation": new Wo(Wt.paint_raster["raster-saturation"]),
                "raster-contrast": new Wo(Wt.paint_raster["raster-contrast"]),
                "raster-resampling": new Wo(Wt.paint_raster["raster-resampling"]),
                "raster-fade-duration": new Wo(Wt.paint_raster["raster-fade-duration"])
            })
        };
        class pm extends xa {
            constructor(t) {
                super(t, {}),
                this.implementation = t
            }
            is3D() {
                return "3d" === this.implementation.renderingMode
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1
            }
            serialize() {}
            onAdd(t) {
                this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl)
            }
            onRemove(t) {
                this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl)
            }
        }
        var mm = {
            paint: new Qo({
                "sky-type": new Wo(Wt.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new Wo(Wt.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new Wo(Wt.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new Wo(Wt.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new Wo(Wt.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new Ko(Wt.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new Wo(Wt.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new Wo(Wt.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new Wo(Wt.paint_sky["sky-opacity"])
            })
        };
        function fm(t, e, i) {
            const r = [0, 0, 1]
              , n = Kl([]);
            return tc(n, n, i ? -y(t) + Math.PI : y(t)),
            Ql(n, n, -y(e)),
            Vl(r, r, n),
            Ul(r, r)
        }
        const _m = {
            circle: class extends xa {
                constructor(t) {
                    super(t, pl)
                }
                createBucket(t) {
                    return new Ya(t)
                }
                queryRadius(t) {
                    const e = t;
                    return ll("circle-radius", this, e) + ll("circle-stroke-width", this, e) + cl(this.paint.get("circle-translate"))
                }
                queryIntersectsFeature(t, e, i, r, n, o, s, a) {
                    const l = hl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                      , c = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i);
                    return sc(t, r, o, s, a, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, c)
                }
                getProgramIds() {
                    return ["circle"]
                }
                getProgramConfiguration(t) {
                    return new da(this,t)
                }
            }
            ,
            heatmap: class extends xa {
                createBucket(t) {
                    return new hc(t)
                }
                constructor(t) {
                    super(t, gc),
                    this._updateColorRamp()
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "heatmap-color" === t && this._updateColorRamp()
                }
                _updateColorRamp() {
                    this.colorRamp = yc({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }),
                    this.colorRampTexture = null
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(),
                    this.heatmapFbo = null)
                }
                queryRadius(t) {
                    return ll("heatmap-radius", this, t)
                }
                queryIntersectsFeature(t, e, i, r, n, o, s, a) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, i);
                    return sc(t, r, o, s, a, !0, !0, new m(0,0), l)
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility
                }
                getProgramIds() {
                    return ["heatmap", "heatmapTexture"]
                }
                getProgramConfiguration(t) {
                    return new da(this,t)
                }
            }
            ,
            hillshade: class extends xa {
                constructor(t) {
                    super(t, xc)
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility
                }
                getProgramIds() {
                    return ["hillshade", "hillshadePrepare"]
                }
            }
            ,
            fill: class extends xa {
                constructor(t) {
                    super(t, nu)
                }
                getProgramIds() {
                    const t = this.paint.get("fill-pattern")
                      , e = t && t.constantOr(1)
                      , i = [e ? "fillPattern" : "fill"];
                    return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"),
                    i
                }
                getProgramConfiguration(t) {
                    return new da(this,t)
                }
                recalculate(t, e) {
                    super.recalculate(t, e);
                    const i = this.paint._values["fill-outline-color"];
                    "constant" === i.value.kind && void 0 === i.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                }
                createBucket(t) {
                    return new iu(t)
                }
                queryRadius() {
                    return cl(this.paint.get("fill-translate"))
                }
                queryIntersectsFeature(t, e, i, r, n, o) {
                    return !t.queryGeometry.isAboveHorizon && Ka(ul(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, t.pixelToTileUnitsFactor), r)
                }
                isTileClipped() {
                    return !0
                }
            }
            ,
            "fill-extrusion": class extends xa {
                constructor(t) {
                    super(t, Uu)
                }
                createBucket(t) {
                    return new Iu(t)
                }
                queryRadius() {
                    return cl(this.paint.get("fill-extrusion-translate"))
                }
                is3D() {
                    return !0
                }
                getProgramIds() {
                    return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                }
                getProgramConfiguration(t) {
                    return new da(this,t)
                }
                queryIntersectsFeature(t, e, i, r, n, o, s, a, l) {
                    const c = hl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                      , u = this.paint.get("fill-extrusion-height").evaluate(e, i)
                      , h = this.paint.get("fill-extrusion-base").evaluate(e, i)
                      , d = [0, 0]
                      , p = a && o.elevation
                      , f = o.elevation ? o.elevation.exaggeration() : 1
                      , _ = t.tile.getBucket(this);
                    if (p && _ instanceof Iu) {
                        const t = _.centroidVertexArray
                          , e = l + 1;
                        e < t.length && (d[0] = t.geta_centroid_pos0(e),
                        d[1] = t.geta_centroid_pos1(e))
                    }
                    if (0 === d[0] && 1 === d[1])
                        return !1;
                    "globe" === o.projection.name && (r = Bu([r], [new m(0,0), new m(za,za)], t.tileID.canonical).map((t=>t.polygon)).flat());
                    const g = p ? a : null
                      , [y,x] = (b = o,
                    w = r,
                    z = h,
                    T = u,
                    E = c,
                    S = s,
                    M = g,
                    A = d,
                    I = f,
                    C = o.center.lat,
                    D = t.tileID.canonical,
                    "globe" === b.projection.name ? function(t, e, i, r, n, o, s, a, l, c, u) {
                        const h = []
                          , d = []
                          , p = t.projection.upVectorScale(u, t.center.lat, t.worldSize).metersToTile
                          , m = [0, 0, 0, 1]
                          , f = [0, 0, 0, 1]
                          , _ = (t,e,i,r)=>{
                            t[0] = e,
                            t[1] = i,
                            t[2] = r,
                            t[3] = 1
                        }
                          , g = Ru();
                        i > 0 && (i += g),
                        r += g;
                        for (const g of e) {
                            const e = []
                              , y = [];
                            for (const h of g) {
                                const d = h.x + n.x
                                  , g = h.y + n.y
                                  , x = t.projection.projectTilePoint(d, g, u)
                                  , v = t.projection.upVector(u, h.x, h.y);
                                let b = i
                                  , w = r;
                                if (s) {
                                    const t = $u(d, g, i, r, s, a, l, c);
                                    b += t.base,
                                    w += t.top
                                }
                                0 !== i ? _(m, x.x + v[0] * p * b, x.y + v[1] * p * b, x.z + v[2] * p * b) : _(m, x.x, x.y, x.z),
                                _(f, x.x + v[0] * p * w, x.y + v[1] * p * w, x.z + v[2] * p * w),
                                jl(m, m, o),
                                jl(f, f, o),
                                e.push(new Ju(m[0],m[1],m[2])),
                                y.push(new Ju(f[0],f[1],f[2]))
                            }
                            h.push(e),
                            d.push(y)
                        }
                        return [h, d]
                    }(b, w, z, T, E, S, M, A, I, C, D) : M ? function(t, e, i, r, n, o, s, a, l) {
                        const c = []
                          , u = []
                          , h = [0, 0, 0, 1];
                        for (const d of t) {
                            const t = []
                              , p = [];
                            for (const c of d) {
                                const u = c.x + r.x
                                  , d = c.y + r.y
                                  , m = $u(u, d, e, i, o, s, a, l);
                                h[0] = u,
                                h[1] = d,
                                h[2] = m.base,
                                h[3] = 1,
                                Wl(h, h, n),
                                h[3] = Math.max(h[3], 1e-5);
                                const f = new Ju(h[0] / h[3],h[1] / h[3],h[2] / h[3]);
                                h[0] = u,
                                h[1] = d,
                                h[2] = m.top,
                                h[3] = 1,
                                Wl(h, h, n),
                                h[3] = Math.max(h[3], 1e-5);
                                const _ = new Ju(h[0] / h[3],h[1] / h[3],h[2] / h[3]);
                                t.push(f),
                                p.push(_)
                            }
                            c.push(t),
                            u.push(p)
                        }
                        return [c, u]
                    }(w, z, T, E, S, M, A, I, C) : function(t, e, i, r, n) {
                        const o = []
                          , s = []
                          , a = n[8] * e
                          , l = n[9] * e
                          , c = n[10] * e
                          , u = n[11] * e
                          , h = n[8] * i
                          , d = n[9] * i
                          , p = n[10] * i
                          , m = n[11] * i;
                        for (const e of t) {
                            const t = []
                              , i = [];
                            for (const o of e) {
                                const e = o.x + r.x
                                  , s = o.y + r.y
                                  , f = n[0] * e + n[4] * s + n[12]
                                  , _ = n[1] * e + n[5] * s + n[13]
                                  , g = n[2] * e + n[6] * s + n[14]
                                  , y = n[3] * e + n[7] * s + n[15]
                                  , x = f + a
                                  , v = _ + l
                                  , b = g + c
                                  , w = Math.max(y + u, 1e-5)
                                  , z = f + h
                                  , T = _ + d
                                  , E = g + p
                                  , S = Math.max(y + m, 1e-5);
                                t.push(new Ju(x / w,v / w,b / w)),
                                i.push(new Ju(z / S,T / S,E / S))
                            }
                            o.push(t),
                            s.push(i)
                        }
                        return [o, s]
                    }(w, z, T, E, S))
                      , v = t.queryGeometry;
                    var b, w, z, T, E, S, M, A, I, C, D;
                    return function(t, e, i) {
                        let r = 1 / 0;
                        Ka(i, e) && (r = qu(i, e[0]));
                        for (let n = 0; n < e.length; n++) {
                            const o = e[n]
                              , s = t[n];
                            for (let t = 0; t < o.length - 1; t++) {
                                const e = o[t]
                                  , n = [e, o[t + 1], s[t + 1], s[t], e];
                                Wa(i, n) && (r = Math.min(r, qu(i, n)))
                            }
                        }
                        return r !== 1 / 0 && r
                    }(y, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry)
                }
            }
            ,
            line: class extends xa {
                constructor(t) {
                    super(t, rh),
                    this.gradientVersion = 0
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    if ("line-gradient" === t) {
                        const t = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Si,
                        this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression
                }
                recalculate(t, e) {
                    super.recalculate(t, e),
                    this.paint._values["line-floorwidth"] = nh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                }
                createBucket(t) {
                    return new eh(t)
                }
                getProgramIds() {
                    return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                }
                getProgramConfiguration(t) {
                    return new da(this,t)
                }
                queryRadius(t) {
                    const e = t
                      , i = oh(ll("line-width", this, e), ll("line-gap-width", this, e))
                      , r = ll("line-offset", this, e);
                    return i / 2 + Math.abs(r) + cl(this.paint.get("line-translate"))
                }
                queryIntersectsFeature(t, e, i, r, n, o) {
                    if (t.queryGeometry.isAboveHorizon)
                        return !1;
                    const s = ul(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                      , a = t.pixelToTileUnitsFactor / 2 * oh(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i))
                      , l = this.paint.get("line-offset").evaluate(e, i);
                    return l && (r = function(t, e) {
                        const i = []
                          , r = new m(0,0);
                        for (let n = 0; n < t.length; n++) {
                            const o = t[n]
                              , s = [];
                            for (let t = 0; t < o.length; t++) {
                                const i = o[t - 1]
                                  , n = o[t]
                                  , a = o[t + 1]
                                  , l = 0 === t ? r : n.sub(i)._unit()._perp()
                                  , c = t === o.length - 1 ? r : a.sub(n)._unit()._perp()
                                  , u = l._add(c)._unit();
                                u._mult(1 / (u.x * c.x + u.y * c.y)),
                                s.push(u._mult(e)._add(n))
                            }
                            i.push(s)
                        }
                        return i
                    }(r, l * t.pixelToTileUnitsFactor)),
                    function(t, e, i) {
                        for (let r = 0; r < e.length; r++) {
                            const n = e[r];
                            if (t.length >= 3)
                                for (let e = 0; e < n.length; e++)
                                    if (ol(t, n[e]))
                                        return !0;
                            if (Qa(t, n, i))
                                return !0
                        }
                        return !1
                    }(s, r, a)
                }
                isTileClipped() {
                    return !0
                }
            }
            ,
            symbol: um,
            background: class extends xa {
                constructor(t) {
                    super(t, hm)
                }
                getProgramIds() {
                    return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                }
            }
            ,
            raster: class extends xa {
                constructor(t) {
                    super(t, dm)
                }
                getProgramIds() {
                    return ["raster"]
                }
            }
            ,
            sky: class extends xa {
                constructor(t) {
                    super(t, mm),
                    this._updateColorRamp()
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0)
                }
                _updateColorRamp() {
                    this.colorRamp = yc({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }),
                    this.colorRampTexture && (this.colorRampTexture.destroy(),
                    this.colorRampTexture = null)
                }
                needsSkyboxCapture(t) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                        return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar
                    }
                    return !1
                }
                getCenter(t, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const i = this.paint.get("sky-atmosphere-sun")
                          , r = !i
                          , n = t.style.light
                          , o = n.properties.get("position");
                        return r && "viewport" === n.properties.get("anchor") && G("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),
                        r ? fm(o.azimuthal, 90 - o.polar, e) : fm(i[0], 90 - i[1], e)
                    }
                    const i = this.paint.get("sky-gradient-center");
                    return fm(i[0], 90 - i[1], e)
                }
                is3D() {
                    return !1
                }
                isSky() {
                    return !0
                }
                markSkyboxValid(t) {
                    this._skyboxInvalidated = !1,
                    this._lightPosition = t.style.light.properties.get("position")
                }
                hasOffscreenPass() {
                    return !0
                }
                getProgramIds() {
                    const t = this.paint.get("sky-type");
                    return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null
                }
            }
        };
        class gm {
            constructor(t, e, i, r) {
                this.context = t,
                this.format = i,
                this.texture = t.gl.createTexture(),
                this.update(e, r)
            }
            update(t, i, r) {
                const {width: n, height: o} = t
                  , {context: s} = this
                  , {gl: a} = s
                  , {HTMLImageElement: l, HTMLCanvasElement: c, HTMLVideoElement: u, ImageData: h, ImageBitmap: d} = e;
                if (a.bindTexture(a.TEXTURE_2D, this.texture),
                s.pixelStoreUnpackFlipY.set(!1),
                s.pixelStoreUnpack.set(1),
                s.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!i || !1 !== i.premultiply)),
                r || this.size && this.size[0] === n && this.size[1] === o) {
                    const {x: e, y: i} = r || {
                        x: 0,
                        y: 0
                    };
                    t instanceof l || t instanceof c || t instanceof u || t instanceof h || d && t instanceof d ? a.texSubImage2D(a.TEXTURE_2D, 0, e, i, a.RGBA, a.UNSIGNED_BYTE, t) : a.texSubImage2D(a.TEXTURE_2D, 0, e, i, n, o, a.RGBA, a.UNSIGNED_BYTE, t.data)
                } else
                    this.size = [n, o],
                    t instanceof l || t instanceof c || t instanceof u || t instanceof h || d && t instanceof d ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, t) : a.texImage2D(a.TEXTURE_2D, 0, this.format, n, o, 0, this.format, a.UNSIGNED_BYTE, t.data);
                this.useMipmap = Boolean(i && i.useMipmap && this.isSizePowerOfTwo()),
                this.useMipmap && a.generateMipmap(a.TEXTURE_2D)
            }
            bind(t, e) {
                const {context: i} = this
                  , {gl: r} = i;
                r.bindTexture(r.TEXTURE_2D, this.texture),
                t !== this.filter && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, this.useMipmap ? t === r.NEAREST ? r.NEAREST_MIPMAP_NEAREST : r.LINEAR_MIPMAP_NEAREST : t),
                this.filter = t),
                e !== this.wrap && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, e),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, e),
                this.wrap = e)
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
            }
            destroy() {
                const {gl: t} = this.context;
                t.deleteTexture(this.texture),
                this.texture = null
            }
        }
        class ym {
            constructor(t) {
                this._callback = t,
                this._triggered = !1,
                "undefined" != typeof MessageChannel && (this._channel = new MessageChannel,
                this._channel.port2.onmessage = ()=>{
                    this._triggered = !1,
                    this._callback()
                }
                )
            }
            trigger() {
                this._triggered || (this._triggered = !0,
                this._channel ? this._channel.port1.postMessage(!0) : setTimeout((()=>{
                    this._triggered = !1,
                    this._callback()
                }
                ), 0))
            }
            remove() {
                this._channel = void 0,
                this._callback = ()=>{}
            }
        }
        class xm {
            constructor() {
                this.tasks = {},
                this.taskQueue = [],
                O(["process"], this),
                this.invoker = new ym(this.process),
                this.nextId = 0
            }
            add(t, e) {
                const i = this.nextId++
                  , r = function({type: t, isSymbolTile: e, zoom: i}) {
                    return i = i || 0,
                    "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - i : "maybePrepare" === t && e ? 400 - i : 500 : 200 - i : 100 - i
                }(e);
                return 0 === r ? (Z(),
                t(),
                {
                    cancel: ()=>{}
                }) : (this.tasks[i] = {
                    fn: t,
                    metadata: e,
                    priority: r,
                    id: i
                },
                this.taskQueue.push(i),
                this.invoker.trigger(),
                {
                    cancel: ()=>{
                        delete this.tasks[i]
                    }
                })
            }
            process() {
                Z();
                {
                    if (this.taskQueue = this.taskQueue.filter((t=>!!this.tasks[t])),
                    !this.taskQueue.length)
                        return;
                    const t = this.pick();
                    if (null === t)
                        return;
                    const e = this.tasks[t];
                    if (delete this.tasks[t],
                    this.taskQueue.length && this.invoker.trigger(),
                    !e)
                        return;
                    e.fn()
                }
            }
            pick() {
                let t = null
                  , e = 1 / 0;
                for (let i = 0; i < this.taskQueue.length; i++) {
                    const r = this.tasks[this.taskQueue[i]];
                    r.priority < e && (e = r.priority,
                    t = i)
                }
                if (null === t)
                    return null;
                const i = this.taskQueue[t];
                return this.taskQueue.splice(t, 1),
                i
            }
            remove() {
                this.invoker.remove()
            }
        }
        class vm {
            constructor(t) {
                this._stringToNumber = {},
                this._numberToString = [];
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    this._stringToNumber[i] = e,
                    this._numberToString[e] = i
                }
            }
            encode(t) {
                return this._stringToNumber[t]
            }
            decode(t) {
                return this._numberToString[t]
            }
        }
        const bm = ["tile", "layer", "source", "sourceLayer", "state"];
        class wm {
            constructor(t, e, i, r, n) {
                this.type = "Feature",
                this._vectorTileFeature = t,
                this._z = e,
                this._x = i,
                this._y = r,
                this.properties = t.properties,
                this.id = n
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry),
                this._geometry
            }
            set geometry(t) {
                this._geometry = t
            }
            toJSON() {
                const t = {
                    type: "Feature",
                    geometry: this.geometry,
                    properties: this.properties
                };
                void 0 !== this.id && (t.id = this.id);
                for (const e of bm)
                    void 0 !== this[e] && (t[e] = this[e]);
                return t
            }
        }
        const zm = 32
          , Tm = 33
          , Em = new Uint16Array(8184);
        for (let t = 0; t < 2046; t++) {
            let e = t + 2
              , i = 0
              , r = 0
              , n = 0
              , o = 0
              , s = 0
              , a = 0;
            for (1 & e ? n = o = s = zm : i = r = a = zm; (e >>= 1) > 1; ) {
                const t = i + n >> 1
                  , l = r + o >> 1;
                1 & e ? (n = i,
                o = r,
                i = s,
                r = a) : (i = n,
                r = o,
                n = s,
                o = a),
                s = t,
                a = l
            }
            const l = 4 * t;
            Em[l + 0] = i,
            Em[l + 1] = r,
            Em[l + 2] = n,
            Em[l + 3] = o
        }
        const Sm = new Uint16Array(2178)
          , Mm = new Uint8Array(1089)
          , Am = new Uint16Array(1089);
        function Im(t) {
            return 0 === t ? -.03125 : 32 === t ? .03125 : 0
        }
        var Cm = ns([{
            name: "a_pos",
            type: "Int16",
            components: 2
        }, {
            name: "a_texture_pos",
            type: "Int16",
            components: 2
        }]);
        const Dm = {
            type: 2,
            extent: za,
            loadGeometry: ()=>[[new m(0,0), new m(8193,0), new m(8193,8193), new m(0,8193), new m(0,0)]]
        };
        class km {
            constructor(t, e, i, r, n) {
                this.tileID = t,
                this.uid = D(),
                this.uses = 0,
                this.tileSize = e,
                this.tileZoom = i,
                this.buckets = {},
                this.expirationTime = null,
                this.queryPadding = 0,
                this.hasSymbolBuckets = !1,
                this.hasRTLText = !1,
                this.dependencies = {},
                this.isRaster = n,
                this.expiredRequestCount = 0,
                this.state = "loading",
                r && r.transform && (this.projection = r.transform.projection)
            }
            registerFadeDuration(t) {
                const e = t + this.timeAdded;
                e < Zt.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e)
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = Cp(this.tileID.canonical, this.projection)),
                this._tileTransform
            }
            loadVectorData(t, e, i) {
                if (this.unloadVectorData(),
                this.state = "loaded",
                t) {
                    t.featureIndex && (this.latestFeatureIndex = t.featureIndex,
                    t.rawTileData ? (this.latestRawTileData = t.rawTileData,
                    this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                    this.collisionBoxArray = t.collisionBoxArray,
                    this.buckets = function(t, e) {
                        const i = {};
                        if (!e)
                            return i;
                        for (const r of t) {
                            const t = r.layerIds.map((t=>e.getLayer(t))).filter(Boolean);
                            if (0 !== t.length) {
                                r.layers = t,
                                r.stateDependentLayerIds && (r.stateDependentLayers = r.stateDependentLayerIds.map((e=>t.filter((t=>t.id === e))[0])));
                                for (const e of t)
                                    i[e.id] = r
                            }
                        }
                        return i
                    }(t.buckets, e.style),
                    this.hasSymbolBuckets = !1;
                    for (const t in this.buckets) {
                        const e = this.buckets[t];
                        if (e instanceof sm) {
                            if (this.hasSymbolBuckets = !0,
                            !i)
                                break;
                            e.justReloaded = !0
                        }
                    }
                    if (this.hasRTLText = !1,
                    this.hasSymbolBuckets)
                        for (const t in this.buckets) {
                            const e = this.buckets[t];
                            if (e instanceof sm && e.hasRTLText) {
                                this.hasRTLText = !0,
                                No.isLoading() || No.isLoaded() || "deferred" !== Fo() || Uo();
                                break
                            }
                        }
                    this.queryPadding = 0;
                    for (const t in this.buckets) {
                        const i = this.buckets[t];
                        this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(i))
                    }
                    t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                    t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
                    t.lineAtlas && (this.lineAtlas = t.lineAtlas)
                } else
                    this.collisionBoxArray = new ks
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for (const t in this.buckets)
                        this.buckets[t].destroy();
                    this.buckets = {},
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                    this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                    this._tileBoundsIndexBuffer.destroy(),
                    this._tileBoundsSegments.destroy(),
                    this._tileBoundsBuffer = null),
                    this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                    this._tileDebugSegments.destroy(),
                    this._tileDebugBuffer = null),
                    this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                    this._tileDebugIndexBuffer = null),
                    this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                    this._globeTileDebugBorderBuffer = null),
                    this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                    this._tileDebugTextSegments.destroy(),
                    this._tileDebugTextIndexBuffer.destroy(),
                    this._tileDebugTextBuffer = null),
                    this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                    this._globeTileDebugTextBuffer = null),
                    this.latestFeatureIndex = null,
                    this.state = "unloaded"
                }
            }
            getBucket(t) {
                return this.buckets[t.id]
            }
            upload(t) {
                for (const e in this.buckets) {
                    const i = this.buckets[e];
                    i.uploadPending() && i.upload(t)
                }
                const e = t.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new gm(t,this.imageAtlas.image,e.RGBA),
                this.imageAtlas.uploaded = !0),
                this.glyphAtlasImage && (this.glyphAtlasTexture = new gm(t,this.glyphAtlasImage,e.ALPHA),
                this.glyphAtlasImage = null),
                this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new gm(t,this.lineAtlas.image,e.ALPHA),
                this.lineAtlas.uploaded = !0)
            }
            prepare(t) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture)
            }
            queryRenderedFeatures(t, e, i, r, n, o, s, a) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    tileResult: r,
                    pixelPosMatrix: s,
                    transform: o,
                    params: n,
                    tileTransform: this.tileTransform
                }, t, e, i) : {}
            }
            querySourceFeatures(t, e) {
                const i = this.latestFeatureIndex;
                if (!i || !i.rawTileData)
                    return;
                const r = i.loadVTLayers()
                  , n = e ? e.sourceLayer : ""
                  , o = r._geojsonTileLayer || r[n];
                if (!o)
                    return;
                const s = sn(e && e.filter)
                  , {z: a, x: l, y: c} = this.tileID.canonical
                  , u = {
                    z: a,
                    x: l,
                    y: c
                };
                for (let e = 0; e < o.length; e++) {
                    const r = o.feature(e);
                    if (s.needGeometry) {
                        const t = Xa(r, !0);
                        if (!s.filter(new Go(this.tileID.overscaledZ), t, this.tileID.canonical))
                            continue
                    } else if (!s.filter(new Go(this.tileID.overscaledZ), r))
                        continue;
                    const h = i.getId(r, n)
                      , d = new wm(r,a,l,c,h);
                    d.tile = u,
                    t.push(d)
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
            }
            setExpiryData(t) {
                const e = this.expirationTime;
                if (t.cacheControl) {
                    const e = J(t.cacheControl);
                    e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"])
                } else
                    t.expires && (this.expirationTime = new Date(t.expires).getTime());
                if (this.expirationTime) {
                    const t = Date.now();
                    let i = !1;
                    if (this.expirationTime > t)
                        i = !1;
                    else if (e)
                        if (this.expirationTime < e)
                            i = !0;
                        else {
                            const r = this.expirationTime - e;
                            r ? this.expirationTime = t + Math.max(r, 3e4) : i = !0
                        }
                    else
                        i = !0;
                    i ? (this.expiredRequestCount++,
                    this.state = "expired") : this.expiredRequestCount = 0
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime)
                    return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1)
            }
            setFeatureState(t, e) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e)
                    return;
                const i = this.latestFeatureIndex.loadVTLayers()
                  , r = e.style.listImages();
                for (const n in this.buckets) {
                    if (!e.style.hasLayer(n))
                        continue;
                    const o = this.buckets[n]
                      , s = o.layers[0].sourceLayer || "_geojsonTileLayer"
                      , a = i[s]
                      , l = t[s];
                    if (!a || !l || 0 === Object.keys(l).length)
                        continue;
                    if (o.update(l, a, r, this.imageAtlas && this.imageAtlas.patternPositions || {}),
                    o instanceof eh || o instanceof iu) {
                        const t = e.style._getSourceCache(o.layers[0].source);
                        e._terrain && e._terrain.enabled && t && o.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID)
                    }
                    const c = e && e.style && e.style.getLayer(n);
                    c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(o)))
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Zt.now()
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0
            }
            setHoldDuration(t) {
                this.symbolFadeHoldUntil = Zt.now() + t
            }
            setTexture(t, e) {
                const i = e.context
                  , r = i.gl;
                this.texture = this.texture || e.getTileTexture(t.width),
                this.texture ? this.texture.update(t, {
                    useMipmap: !0
                }) : (this.texture = new gm(i,t,r.RGBA,{
                    useMipmap: !0
                }),
                this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE),
                i.extTextureFilterAnisotropic && r.texParameterf(r.TEXTURE_2D, i.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i.extTextureFilterAnisotropicMax))
            }
            setDependencies(t, e) {
                const i = {};
                for (const t of e)
                    i[t] = !0;
                this.dependencies[t] = i
            }
            hasDependency(t, e) {
                for (const i of t) {
                    const t = this.dependencies[i];
                    if (t)
                        for (const i of e)
                            if (t[i])
                                return !0
                }
                return !1
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t, e) {
                if (!e || "mercator" === e.name || this._tileDebugBuffer)
                    return;
                const i = Ja(Dm, this.tileID.canonical, this.tileTransform)[0]
                  , r = new ss
                  , n = new Is;
                for (let t = 0; t < i.length; t++) {
                    const {x: e, y: o} = i[t];
                    r.emplaceBack(e, o),
                    n.emplaceBack(t)
                }
                n.emplaceBack(0),
                this._tileDebugIndexBuffer = t.createIndexBuffer(n),
                this._tileDebugBuffer = t.createVertexBuffer(r, Kd.members),
                this._tileDebugSegments = wa.simpleSegment(0, 0, r.length, n.length)
            }
            _makeTileBoundsBuffers(t, e) {
                if (this._tileBoundsBuffer || !e || "mercator" === e.name)
                    return;
                const i = Ja(Dm, this.tileID.canonical, this.tileTransform)[0];
                let r, n;
                if (this.isRaster) {
                    const t = function(t, e) {
                        const i = Cp(t, e)
                          , r = Math.pow(2, t.z);
                        for (let n = 0; n < Tm; n++)
                            for (let o = 0; o < Tm; o++) {
                                const s = ka((t.x + (o + Im(o)) / zm) / r)
                                  , a = Pa((t.y + (n + Im(n)) / zm) / r)
                                  , l = e.project(s, a)
                                  , c = n * Tm + o;
                                Sm[2 * c + 0] = Math.round((l.x * i.scale - i.x) * za),
                                Sm[2 * c + 1] = Math.round((l.y * i.scale - i.y) * za)
                            }
                        Mm.fill(0),
                        Am.fill(0);
                        for (let t = 2045; t >= 0; t--) {
                            const e = 4 * t
                              , i = Em[e + 0]
                              , r = Em[e + 1]
                              , n = Em[e + 2]
                              , o = Em[e + 3]
                              , s = i + n >> 1
                              , a = r + o >> 1
                              , l = s + a - r
                              , c = a + i - s
                              , u = r * Tm + i
                              , h = o * Tm + n
                              , d = a * Tm + s
                              , p = Math.hypot((Sm[2 * u + 0] + Sm[2 * h + 0]) / 2 - Sm[2 * d + 0], (Sm[2 * u + 1] + Sm[2 * h + 1]) / 2 - Sm[2 * d + 1]) >= 16;
                            if (Mm[d] = Mm[d] || (p ? 1 : 0),
                            t < 1022) {
                                const t = (r + c >> 1) * Tm + (i + l >> 1)
                                  , e = (o + c >> 1) * Tm + (n + l >> 1);
                                Mm[d] = Mm[d] || Mm[t] || Mm[e]
                            }
                        }
                        const n = new ls
                          , o = new ws;
                        let s = 0;
                        function a(t, e) {
                            const i = e * Tm + t;
                            return 0 === Am[i] && (n.emplaceBack(Sm[2 * i + 0], Sm[2 * i + 1], t * za / zm, e * za / zm),
                            Am[i] = ++s),
                            Am[i] - 1
                        }
                        function l(t, e, i, r, n, s) {
                            const c = t + i >> 1
                              , u = e + r >> 1;
                            if (Math.abs(t - n) + Math.abs(e - s) > 1 && Mm[u * Tm + c])
                                l(n, s, t, e, c, u),
                                l(i, r, n, s, c, u);
                            else {
                                const l = a(t, e)
                                  , c = a(i, r)
                                  , u = a(n, s);
                                o.emplaceBack(l, c, u)
                            }
                        }
                        return l(0, 0, zm, zm, zm, 0),
                        l(zm, zm, 0, 0, 0, zm),
                        {
                            vertices: n,
                            indices: o
                        }
                    }(this.tileID.canonical, e);
                    r = t.vertices,
                    n = t.indices
                } else {
                    r = new ls,
                    n = new ws;
                    for (const {x: t, y: e} of i)
                        r.emplaceBack(t, e, 0, 0);
                    const t = wc.exports(r.int16, void 0, 4);
                    for (let e = 0; e < t.length; e += 3)
                        n.emplaceBack(t[e], t[e + 1], t[e + 2])
                }
                this._tileBoundsBuffer = t.createVertexBuffer(r, Cm.members),
                this._tileBoundsIndexBuffer = t.createIndexBuffer(n),
                this._tileBoundsSegments = wa.simpleSegment(0, 0, r.length, n.length)
            }
            _makeGlobeTileDebugBuffers(t, e) {
                const i = e.projection;
                if (!i || "globe" !== i.name || e.freezeTileCoverage)
                    return;
                const r = this.tileID.canonical
                  , n = vp(hp(r, e))
                  , o = zp(e.zoom);
                let s;
                o > 0 && (s = xl(new Float64Array(16), e.globeMatrix)),
                this._makeGlobeTileDebugBorderBuffer(t, r, e, n, s, o),
                this._makeGlobeTileDebugTextBuffer(t, r, e, n, s, o)
            }
            _globePoint(t, e, i, r, n, o, s) {
                let a = gp(t, e, i);
                if (o) {
                    const n = 1 << i.z
                      , l = Ia(r.center.lng)
                      , c = Ca(r.center.lat)
                      , u = (i.x + .5) / n - l;
                    let h = 0;
                    u > .5 ? h = -1 : u < -.5 && (h = 1);
                    let d = (t / za + i.x) / n + h
                      , p = (e / za + i.y) / n;
                    d = (d - l) * r._pixelsPerMercatorPixel + l,
                    p = (p - c) * r._pixelsPerMercatorPixel + c;
                    const m = [d * r.worldSize, p * r.worldSize, 0];
                    jl(m, m, o),
                    a = up(a, m, s)
                }
                return jl(a, a, n)
            }
            _makeGlobeTileDebugBorderBuffer(t, e, i, r, n, o) {
                const s = new ss
                  , a = new Is
                  , l = new as
                  , c = (t,c,u,h,d)=>{
                    const p = (u - t) / (d - 1)
                      , m = (h - c) / (d - 1)
                      , f = s.length;
                    for (let u = 0; u < d; u++) {
                        const h = t + u * p
                          , d = c + u * m;
                        s.emplaceBack(h, d);
                        const _ = this._globePoint(h, d, e, i, r, n, o);
                        l.emplaceBack(_[0], _[1], _[2]),
                        a.emplaceBack(f + u)
                    }
                }
                  , u = za;
                c(0, 0, u, 0, 16),
                c(u, 0, u, u, 16),
                c(u, u, 0, u, 16),
                c(0, u, 0, 0, 16),
                this._tileDebugIndexBuffer = t.createIndexBuffer(a),
                this._tileDebugBuffer = t.createVertexBuffer(s, Kd.members),
                this._globeTileDebugBorderBuffer = t.createVertexBuffer(l, Hd.members),
                this._tileDebugSegments = wa.simpleSegment(0, 0, s.length, a.length)
            }
            _makeGlobeTileDebugTextBuffer(t, e, i, r, n, o) {
                const s = new ss
                  , a = new ws
                  , l = new as
                  , c = 25;
                a.reserve(32),
                s.reserve(c),
                l.reserve(c);
                const u = (t,e)=>c * t + e;
                for (let t = 0; t < c; t++) {
                    const a = 2048 * t;
                    for (let t = 0; t < c; t++) {
                        const c = 2048 * t;
                        s.emplaceBack(c, a);
                        const u = this._globePoint(c, a, e, i, r, n, o);
                        l.emplaceBack(u[0], u[1], u[2])
                    }
                }
                for (let t = 0; t < 4; t++)
                    for (let e = 0; e < 4; e++) {
                        const i = u(t, e)
                          , r = u(t, e + 1)
                          , n = u(t + 1, e)
                          , o = u(t + 1, e + 1);
                        a.emplaceBack(i, r, n),
                        a.emplaceBack(n, r, o)
                    }
                this._tileDebugTextIndexBuffer = t.createIndexBuffer(a),
                this._tileDebugTextBuffer = t.createVertexBuffer(s, Kd.members),
                this._globeTileDebugTextBuffer = t.createVertexBuffer(l, Hd.members),
                this._tileDebugTextSegments = wa.simpleSegment(0, 0, c, 32)
            }
        }
        class Pm {
            constructor() {
                this.state = {},
                this.stateChanges = {},
                this.deletedStates = {}
            }
            updateState(t, e, i) {
                const r = String(e);
                if (this.stateChanges[t] = this.stateChanges[t] || {},
                this.stateChanges[t][r] = this.stateChanges[t][r] || {},
                I(this.stateChanges[t][r], i),
                null === this.deletedStates[t]) {
                    this.deletedStates[t] = {};
                    for (const e in this.state[t])
                        e !== r && (this.deletedStates[t][e] = null)
                } else if (this.deletedStates[t] && null === this.deletedStates[t][r]) {
                    this.deletedStates[t][r] = {};
                    for (const e in this.state[t][r])
                        i[e] || (this.deletedStates[t][r][e] = null)
                } else
                    for (const e in i)
                        this.deletedStates[t] && this.deletedStates[t][r] && null === this.deletedStates[t][r][e] && delete this.deletedStates[t][r][e]
            }
            removeFeatureState(t, e, i) {
                if (null === this.deletedStates[t])
                    return;
                const r = String(e);
                if (this.deletedStates[t] = this.deletedStates[t] || {},
                i && void 0 !== e)
                    null !== this.deletedStates[t][r] && (this.deletedStates[t][r] = this.deletedStates[t][r] || {},
                    this.deletedStates[t][r][i] = null);
                else if (void 0 !== e)
                    if (this.stateChanges[t] && this.stateChanges[t][r])
                        for (i in this.deletedStates[t][r] = {},
                        this.stateChanges[t][r])
                            this.deletedStates[t][r][i] = null;
                    else
                        this.deletedStates[t][r] = null;
                else
                    this.deletedStates[t] = null
            }
            getState(t, e) {
                const i = String(e)
                  , r = I({}, (this.state[t] || {})[i], (this.stateChanges[t] || {})[i]);
                if (null === this.deletedStates[t])
                    return {};
                if (this.deletedStates[t]) {
                    const i = this.deletedStates[t][e];
                    if (null === i)
                        return {};
                    for (const t in i)
                        delete r[t]
                }
                return r
            }
            initializeTileState(t, e) {
                t.setFeatureState(this.state, e)
            }
            coalesceChanges(t, e) {
                const i = {};
                for (const t in this.stateChanges) {
                    this.state[t] = this.state[t] || {};
                    const e = {};
                    for (const i in this.stateChanges[t])
                        this.state[t][i] || (this.state[t][i] = {}),
                        I(this.state[t][i], this.stateChanges[t][i]),
                        e[i] = this.state[t][i];
                    i[t] = e
                }
                for (const t in this.deletedStates) {
                    this.state[t] = this.state[t] || {};
                    const e = {};
                    if (null === this.deletedStates[t])
                        for (const i in this.state[t])
                            e[i] = {},
                            this.state[t][i] = {};
                    else
                        for (const i in this.deletedStates[t]) {
                            if (null === this.deletedStates[t][i])
                                this.state[t][i] = {};
                            else
                                for (const e of Object.keys(this.deletedStates[t][i]))
                                    delete this.state[t][i][e];
                            e[i] = this.state[t][i]
                        }
                    i[t] = i[t] || {},
                    I(i[t], e)
                }
                if (this.stateChanges = {},
                this.deletedStates = {},
                0 !== Object.keys(i).length)
                    for (const r in t)
                        t[r].setFeatureState(i, e)
            }
        }
        class Lm {
            constructor(t) {
                this.size = t,
                this.minimums = [],
                this.maximums = [],
                this.leaves = []
            }
            getElevation(t, e) {
                const i = this.toIdx(t, e);
                return {
                    min: this.minimums[i],
                    max: this.maximums[i]
                }
            }
            isLeaf(t, e) {
                return this.leaves[this.toIdx(t, e)]
            }
            toIdx(t, e) {
                return e * this.size + t
            }
        }
        function Om(t, e, i, r) {
            let n = 0
              , o = Number.MAX_VALUE;
            for (let s = 0; s < 3; s++)
                if (Math.abs(r[s]) < 1e-15) {
                    if (i[s] < t[s] || i[s] > e[s])
                        return null
                } else {
                    const a = 1 / r[s];
                    let l = (t[s] - i[s]) * a
                      , c = (e[s] - i[s]) * a;
                    if (l > c) {
                        const t = l;
                        l = c,
                        c = t
                    }
                    if (l > n && (n = l),
                    c < o && (o = c),
                    n > o)
                        return null
                }
            return n
        }
        function Rm(t, e, i, r, n, o, s, a, l, c, u) {
            const h = r - t
              , d = n - e
              , p = o - i
              , m = s - t
              , f = a - e
              , _ = l - i
              , g = u[1] * _ - u[2] * f
              , y = u[2] * m - u[0] * _
              , x = u[0] * f - u[1] * m
              , v = h * g + d * y + p * x;
            if (Math.abs(v) < 1e-15)
                return null;
            const b = 1 / v
              , w = c[0] - t
              , z = c[1] - e
              , T = c[2] - i
              , E = (w * g + z * y + T * x) * b;
            if (E < 0 || E > 1)
                return null;
            const S = z * p - T * d
              , M = T * h - w * p
              , A = w * d - z * h
              , I = (u[0] * S + u[1] * M + u[2] * A) * b;
            return I < 0 || E + I > 1 ? null : (m * S + f * M + _ * A) * b
        }
        function Bm(t, e, i) {
            return (t - e) / (i - e)
        }
        function Fm(t, e, i, r, n, o, s, a, l) {
            const c = 1 << i
              , u = o - r
              , h = s - n
              , d = (t + 1) / c * u + r
              , p = (e + 0) / c * h + n
              , m = (e + 1) / c * h + n;
            a[0] = (t + 0) / c * u + r,
            a[1] = p,
            l[0] = d,
            l[1] = m
        }
        class Um {
            constructor(t) {
                if (this.maximums = [],
                this.minimums = [],
                this.leaves = [],
                this.childOffsets = [],
                this.nodeCount = 0,
                this.dem = t,
                this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]],
                !this.dem)
                    return;
                const e = function(t) {
                    const e = Math.ceil(Math.log2(t.dim / 8))
                      , i = [];
                    let r = Math.ceil(Math.pow(2, e));
                    const n = 1 / r
                      , o = (t,e,i,r,n)=>{
                        const o = r ? 1 : 0
                          , s = (t + 1) * i - o
                          , a = e * i
                          , l = (e + 1) * i - o;
                        n[0] = t * i,
                        n[1] = a,
                        n[2] = s,
                        n[3] = l
                    }
                    ;
                    let s = new Lm(r);
                    const a = [];
                    for (let e = 0; e < r * r; e++) {
                        o(e % r, Math.floor(e / r), n, !1, a);
                        const i = Gm(a[0], a[1], t)
                          , l = Gm(a[2], a[1], t)
                          , c = Gm(a[2], a[3], t)
                          , u = Gm(a[0], a[3], t);
                        s.minimums.push(Math.min(i, l, c, u)),
                        s.maximums.push(Math.max(i, l, c, u)),
                        s.leaves.push(1)
                    }
                    for (i.push(s),
                    r /= 2; r >= 1; r /= 2) {
                        const t = i[i.length - 1];
                        s = new Lm(r);
                        for (let e = 0; e < r * r; e++) {
                            o(e % r, Math.floor(e / r), 2, !0, a);
                            const i = t.getElevation(a[0], a[1])
                              , n = t.getElevation(a[2], a[1])
                              , l = t.getElevation(a[2], a[3])
                              , c = t.getElevation(a[0], a[3])
                              , u = t.isLeaf(a[0], a[1])
                              , h = t.isLeaf(a[2], a[1])
                              , d = t.isLeaf(a[2], a[3])
                              , p = t.isLeaf(a[0], a[3])
                              , m = Math.min(i.min, n.min, l.min, c.min)
                              , f = Math.max(i.max, n.max, l.max, c.max)
                              , _ = u && h && d && p;
                            s.maximums.push(f),
                            s.minimums.push(m),
                            s.leaves.push(f - m <= 5 && _ ? 1 : 0)
                        }
                        i.push(s)
                    }
                    return i
                }(this.dem)
                  , i = e.length - 1
                  , r = e[i];
                this._addNode(r.minimums[0], r.maximums[0], r.leaves[0]),
                this._construct(e, 0, 0, i, 0)
            }
            raycastRoot(t, e, i, r, n, o, s=1) {
                return Om([t, e, -100], [i, r, this.maximums[0] * s], n, o)
            }
            raycast(t, e, i, r, n, o, s=1) {
                if (!this.nodeCount)
                    return null;
                const a = this.raycastRoot(t, e, i, r, n, o, s);
                if (null == a)
                    return null;
                const l = []
                  , c = []
                  , u = []
                  , h = []
                  , d = [{
                    idx: 0,
                    t: a,
                    nodex: 0,
                    nodey: 0,
                    depth: 0
                }];
                for (; d.length > 0; ) {
                    const {idx: a, t: p, nodex: m, nodey: f, depth: _} = d.pop();
                    if (this.leaves[a]) {
                        Fm(m, f, _, t, e, i, r, u, h);
                        const a = 1 << _
                          , l = (m + 0) / a
                          , c = (m + 1) / a
                          , d = (f + 0) / a
                          , g = (f + 1) / a
                          , y = Gm(l, d, this.dem) * s
                          , x = Gm(c, d, this.dem) * s
                          , v = Gm(c, g, this.dem) * s
                          , b = Gm(l, g, this.dem) * s
                          , w = Rm(u[0], u[1], y, h[0], u[1], x, h[0], h[1], v, n, o)
                          , z = Rm(h[0], h[1], v, u[0], h[1], b, u[0], u[1], y, n, o)
                          , T = Math.min(null !== w ? w : Number.MAX_VALUE, null !== z ? z : Number.MAX_VALUE);
                        if (T !== Number.MAX_VALUE)
                            return T;
                        {
                            const t = Fl([], n, o, p);
                            if (Nm(y, x, b, v, Bm(t[0], u[0], h[0]), Bm(t[1], u[1], h[1])) >= t[2])
                                return p
                        }
                        continue
                    }
                    let g = 0;
                    for (let d = 0; d < this._siblingOffset.length; d++) {
                        Fm((m << 1) + this._siblingOffset[d][0], (f << 1) + this._siblingOffset[d][1], _ + 1, t, e, i, r, u, h),
                        u[2] = -100,
                        h[2] = this.maximums[this.childOffsets[a] + d] * s;
                        const p = Om(u, h, n, o);
                        if (null != p) {
                            const t = p;
                            l[d] = t;
                            let e = !1;
                            for (let i = 0; i < g && !e; i++)
                                t >= l[c[i]] && (c.splice(i, 0, d),
                                e = !0);
                            e || (c[g] = d),
                            g++
                        }
                    }
                    for (let t = 0; t < g; t++) {
                        const e = c[t];
                        d.push({
                            idx: this.childOffsets[a] + e,
                            t: l[e],
                            nodex: (m << 1) + this._siblingOffset[e][0],
                            nodey: (f << 1) + this._siblingOffset[e][1],
                            depth: _ + 1
                        })
                    }
                }
                return null
            }
            _addNode(t, e, i) {
                return this.minimums.push(t),
                this.maximums.push(e),
                this.leaves.push(i),
                this.childOffsets.push(0),
                this.nodeCount++
            }
            _construct(t, e, i, r, n) {
                if (1 === t[r].isLeaf(e, i))
                    return;
                this.childOffsets[n] || (this.childOffsets[n] = this.nodeCount);
                const o = r - 1
                  , s = t[o];
                let a = 0
                  , l = 0;
                for (let t = 0; t < this._siblingOffset.length; t++) {
                    const r = 2 * e + this._siblingOffset[t][0]
                      , n = 2 * i + this._siblingOffset[t][1]
                      , o = s.getElevation(r, n)
                      , c = s.isLeaf(r, n)
                      , u = this._addNode(o.min, o.max, c);
                    c && (a |= 1 << t),
                    l || (l = u)
                }
                for (let r = 0; r < this._siblingOffset.length; r++)
                    a & 1 << r || this._construct(t, 2 * e + this._siblingOffset[r][0], 2 * i + this._siblingOffset[r][1], o, l + r)
            }
        }
        function Nm(t, e, i, r, n, o) {
            return Mi(Mi(t, i, o), Mi(e, r, o), n)
        }
        function Gm(t, e, i) {
            const r = i.dim
              , n = T(t * r - .5, 0, r - 1)
              , o = T(e * r - .5, 0, r - 1)
              , s = Math.floor(n)
              , a = Math.floor(o)
              , l = Math.min(s + 1, r - 1)
              , c = Math.min(a + 1, r - 1);
            return Nm(i.get(s, a), i.get(l, a), i.get(s, c), i.get(l, c), n - s, o - a)
        }
        const jm = {
            mapbox: [6553.6, 25.6, .1, 1e4],
            terrarium: [256, 1, 1 / 256, 32768]
        };
        class Vm {
            get tree() {
                return this._tree || this._buildQuadTree(),
                this._tree
            }
            constructor(t, e, i, r=!1, n=!1) {
                if (this.uid = t,
                e.height !== e.width)
                    throw new RangeError("DEM tiles must be square");
                if (i && "mapbox" !== i && "terrarium" !== i)
                    return G(`"${i}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e.height;
                const o = this.dim = e.height - 2
                  , s = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer),
                this.encoding = i || "mapbox",
                this.borderReady = r,
                !r) {
                    for (let t = 0; t < o; t++)
                        s[this._idx(-1, t)] = s[this._idx(0, t)],
                        s[this._idx(o, t)] = s[this._idx(o - 1, t)],
                        s[this._idx(t, -1)] = s[this._idx(t, 0)],
                        s[this._idx(t, o)] = s[this._idx(t, o - 1)];
                    s[this._idx(-1, -1)] = s[this._idx(0, 0)],
                    s[this._idx(o, -1)] = s[this._idx(o - 1, 0)],
                    s[this._idx(-1, o)] = s[this._idx(0, o - 1)],
                    s[this._idx(o, o)] = s[this._idx(o - 1, o - 1)],
                    n && this._buildQuadTree()
                }
            }
            _buildQuadTree() {
                this._tree = new Um(this)
            }
            get(t, e, i=!1) {
                i && (t = T(t, -1, this.dim),
                e = T(e, -1, this.dim));
                const r = 4 * this._idx(t, e);
                return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[r], this.pixels[r + 1], this.pixels[r + 2])
            }
            static getUnpackVector(t) {
                return jm[t]
            }
            get unpackVector() {
                return jm[this.encoding]
            }
            _idx(t, e) {
                if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
                    throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t + 1)
            }
            _unpackMapbox(t, e, i) {
                return (256 * t * 256 + 256 * e + i) / 10 - 1e4
            }
            _unpackTerrarium(t, e, i) {
                return 256 * t + e + i / 256 - 32768
            }
            static pack(t, e) {
                const i = [0, 0, 0, 0]
                  , r = Vm.getUnpackVector(e);
                let n = Math.floor((t + r[3]) / r[2]);
                return i[2] = n % 256,
                n = Math.floor(n / 256),
                i[1] = n % 256,
                n = Math.floor(n / 256),
                i[0] = n,
                i
            }
            getPixels() {
                return new _c({
                    width: this.stride,
                    height: this.stride
                },this.pixels)
            }
            backfillBorder(t, e, i) {
                if (this.dim !== t.dim)
                    throw new Error("dem dimension mismatch");
                let r = e * this.dim
                  , n = e * this.dim + this.dim
                  , o = i * this.dim
                  , s = i * this.dim + this.dim;
                switch (e) {
                case -1:
                    r = n - 1;
                    break;
                case 1:
                    n = r + 1
                }
                switch (i) {
                case -1:
                    o = s - 1;
                    break;
                case 1:
                    s = o + 1
                }
                const a = -e * this.dim
                  , l = -i * this.dim;
                for (let e = o; e < s; e++)
                    for (let i = r; i < n; i++) {
                        const r = 4 * this._idx(i, e)
                          , n = 4 * this._idx(i + a, e + l);
                        this.pixels[r + 0] = t.pixels[n + 0],
                        this.pixels[r + 1] = t.pixels[n + 1],
                        this.pixels[r + 2] = t.pixels[n + 2],
                        this.pixels[r + 3] = t.pixels[n + 3]
                    }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this)
            }
        }
        jn(Vm, "DEMData"),
        jn(Um, "DemMinMaxQuadTree", {
            omit: ["dem"]
        });
        class Zm {
            constructor(t, e) {
                this.max = t,
                this.onRemove = e,
                this.reset()
            }
            reset() {
                for (const t in this.data)
                    for (const e of this.data[t])
                        e.timeout && clearTimeout(e.timeout),
                        this.onRemove(e.value);
                return this.data = {},
                this.order = [],
                this
            }
            add(t, e, i) {
                const r = t.wrapped().key;
                void 0 === this.data[r] && (this.data[r] = []);
                const n = {
                    value: e,
                    timeout: void 0
                };
                if (void 0 !== i && (n.timeout = setTimeout((()=>{
                    this.remove(t, n)
                }
                ), i)),
                this.data[r].push(n),
                this.order.push(r),
                this.order.length > this.max) {
                    const t = this._getAndRemoveByKey(this.order[0]);
                    t && this.onRemove(t)
                }
                return this
            }
            has(t) {
                return t.wrapped().key in this.data
            }
            getAndRemove(t) {
                return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null
            }
            _getAndRemoveByKey(t) {
                const e = this.data[t].shift();
                return e.timeout && clearTimeout(e.timeout),
                0 === this.data[t].length && delete this.data[t],
                this.order.splice(this.order.indexOf(t), 1),
                e.value
            }
            getByKey(t) {
                const e = this.data[t];
                return e ? e[0].value : null
            }
            get(t) {
                return this.has(t) ? this.data[t.wrapped().key][0].value : null
            }
            remove(t, e) {
                if (!this.has(t))
                    return this;
                const i = t.wrapped().key
                  , r = void 0 === e ? 0 : this.data[i].indexOf(e)
                  , n = this.data[i][r];
                return this.data[i].splice(r, 1),
                n.timeout && clearTimeout(n.timeout),
                0 === this.data[i].length && delete this.data[i],
                this.onRemove(n.value),
                this.order.splice(this.order.indexOf(i), 1),
                this
            }
            setMaxSize(t) {
                for (this.max = t; this.order.length > this.max; ) {
                    const t = this._getAndRemoveByKey(this.order[0]);
                    t && this.onRemove(t)
                }
                return this
            }
            filter(t) {
                const e = [];
                for (const i in this.data)
                    for (const r of this.data[i])
                        t(r.value) || e.push(r);
                for (const t of e)
                    this.remove(t.value.tileID, t)
            }
        }
        class Jm {
            constructor(t, e, i) {
                this.func = t,
                this.mask = e,
                this.range = i
            }
        }
        Jm.ReadOnly = !1,
        Jm.ReadWrite = !0,
        Jm.disabled = new Jm(519,Jm.ReadOnly,[0, 1]);
        const Xm = 7680;
        class qm {
            constructor(t, e, i, r, n, o) {
                this.test = t,
                this.ref = e,
                this.mask = i,
                this.fail = r,
                this.depthFail = n,
                this.pass = o
            }
        }
        qm.disabled = new qm({
            func: 519,
            mask: 0
        },0,0,Xm,Xm,Xm);
        class $m {
            constructor(t, e, i) {
                this.blendFunction = t,
                this.blendColor = e,
                this.mask = i
            }
        }
        $m.Replace = [1, 0],
        $m.disabled = new $m($m.Replace,Me.transparent,[!1, !1, !1, !1]),
        $m.unblended = new $m($m.Replace,Me.transparent,[!0, !0, !0, !0]),
        $m.alphaBlended = new $m([1, 771],Me.transparent,[!0, !0, !0, !0]);
        const Ym = 1029
          , Wm = 2305;
        class Hm {
            constructor(t, e, i) {
                this.enable = t,
                this.mode = e,
                this.frontFace = i
            }
        }
        Hm.disabled = new Hm(!1,Ym,Wm),
        Hm.backCCW = new Hm(!0,Ym,Wm),
        Hm.backCW = new Hm(!0,Ym,2304),
        Hm.frontCW = new Hm(!0,1028,2304),
        Hm.frontCCW = new Hm(!0,1028,Wm);
        class Km extends Yt {
            constructor(t, e, i) {
                super(),
                this.id = t,
                this._onlySymbols = i,
                e.on("data", (t=>{
                    "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0),
                    this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(),
                    this.transform && this.update(this.transform))
                }
                )),
                e.on("error", (()=>{
                    this._sourceErrored = !0
                }
                )),
                this._source = e,
                this._tiles = {},
                this._cache = new Zm(0,this._unloadTile.bind(this)),
                this._timers = {},
                this._cacheTimers = {},
                this._minTileCacheSize = e.minTileCacheSize,
                this._maxTileCacheSize = e.maxTileCacheSize,
                this._loadedParentTiles = {},
                this._coveredTiles = {},
                this._state = new Pm,
                this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType
            }
            onAdd(t) {
                this.map = t,
                this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize,
                this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize
            }
            loaded() {
                if (this._sourceErrored)
                    return !0;
                if (!this._sourceLoaded)
                    return !1;
                if (!this._source.loaded())
                    return !1;
                for (const t in this._tiles) {
                    const e = this._tiles[t];
                    if ("loaded" !== e.state && "errored" !== e.state)
                        return !1
                }
                return !0
            }
            getSource() {
                return this._source
            }
            pause() {
                this._paused = !0
            }
            resume() {
                if (!this._paused)
                    return;
                const t = this._shouldReloadOnResume;
                this._paused = !1,
                this._shouldReloadOnResume = !1,
                t && this.reload(),
                this.transform && this.update(this.transform)
            }
            _loadTile(t, e) {
                return t.isSymbolTile = this._onlySymbols,
                this._source.loadTile(t, e)
            }
            _unloadTile(t) {
                if (this._source.unloadTile)
                    return this._source.unloadTile(t, (()=>{}
                    ))
            }
            _abortTile(t) {
                if (this._source.abortTile)
                    return this._source.abortTile(t, (()=>{}
                    ))
            }
            serialize() {
                return this._source.serialize()
            }
            prepare(t) {
                this._source.prepare && this._source.prepare(),
                this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for (const e in this._tiles) {
                    const i = this._tiles[e];
                    i.upload(t),
                    i.prepare(this.map.style.imageManager)
                }
            }
            getIds() {
                return A(this._tiles).map((t=>t.tileID)).sort(Qm).map((t=>t.key))
            }
            getRenderableIds(t) {
                const e = [];
                for (const i in this._tiles)
                    this._isIdRenderable(+i, t) && e.push(this._tiles[i]);
                return t ? e.sort(((t,e)=>{
                    const i = t.tileID
                      , r = e.tileID
                      , n = new m(i.canonical.x,i.canonical.y)._rotate(this.transform.angle)
                      , o = new m(r.canonical.x,r.canonical.y)._rotate(this.transform.angle);
                    return i.overscaledZ - r.overscaledZ || o.y - n.y || o.x - n.x
                }
                )).map((t=>t.tileID.key)) : e.map((t=>t.tileID)).sort(Qm).map((t=>t.key))
            }
            hasRenderableParent(t) {
                const e = this.findLoadedParent(t, 0);
                return !!e && this._isIdRenderable(e.tileID.key)
            }
            _isIdRenderable(t, e) {
                return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade())
            }
            reload() {
                if (this._paused)
                    this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for (const t in this._tiles)
                        "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading")
                }
            }
            _reloadTile(t, e) {
                const i = this._tiles[t];
                i && ("loading" !== i.state && (i.state = e),
                this._loadTile(i, this._tileLoaded.bind(this, i, t, e)))
            }
            _tileLoaded(t, e, i, r) {
                if (r)
                    if (t.state = "errored",
                    404 !== r.status)
                        this._source.fire(new $t(r,{
                            tile: t
                        }));
                    else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t = this.map.painter.terrain;
                        this.update(this.transform, t.getScaledDemTileSize(), !0),
                        t.resetTileLookupCache(this.id)
                    } else
                        this.update(this.transform);
                else
                    t.timeAdded = Zt.now(),
                    "expired" === i && (t.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(e, t),
                    "raster-dem" === this._source.type && t.dem && this._backfillDEM(t),
                    this._state.initializeTileState(t, this.map ? this.map.painter : null),
                    this._source.fire(new qt("data",{
                        dataType: "source",
                        tile: t,
                        coord: t.tileID,
                        sourceCacheId: this.id
                    }))
            }
            _backfillDEM(t) {
                const e = this.getRenderableIds();
                for (let r = 0; r < e.length; r++) {
                    const n = e[r];
                    if (t.neighboringTiles && t.neighboringTiles[n]) {
                        const e = this.getTileByID(n);
                        i(t, e),
                        i(e, t)
                    }
                }
                function i(t, e) {
                    if (!t.dem || t.dem.borderReady)
                        return;
                    t.needsHillshadePrepare = !0,
                    t.needsDEMTextureUpload = !0;
                    let i = e.tileID.canonical.x - t.tileID.canonical.x;
                    const r = e.tileID.canonical.y - t.tileID.canonical.y
                      , n = Math.pow(2, t.tileID.canonical.z)
                      , o = e.tileID.key;
                    0 === i && 0 === r || Math.abs(r) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + n) ? i += n : 1 === Math.abs(i - n) && (i -= n)),
                    e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, r),
                    t.neighboringTiles && t.neighboringTiles[o] && (t.neighboringTiles[o].backfilled = !0)))
                }
            }
            getTile(t) {
                return this.getTileByID(t.key)
            }
            getTileByID(t) {
                return this._tiles[t]
            }
            _retainLoadedChildren(t, e, i, r) {
                for (const n in this._tiles) {
                    let o = this._tiles[n];
                    if (r[n] || !o.hasData() || o.tileID.overscaledZ <= e || o.tileID.overscaledZ > i)
                        continue;
                    let s = o.tileID;
                    for (; o && o.tileID.overscaledZ > e + 1; ) {
                        const t = o.tileID.scaledTo(o.tileID.overscaledZ - 1);
                        o = this._tiles[t.key],
                        o && o.hasData() && (s = t)
                    }
                    let a = s;
                    for (; a.overscaledZ > e; )
                        if (a = a.scaledTo(a.overscaledZ - 1),
                        t[a.key]) {
                            r[s.key] = s;
                            break
                        }
                }
            }
            findLoadedParent(t, e) {
                if (t.key in this._loadedParentTiles) {
                    const i = this._loadedParentTiles[t.key];
                    return i && i.tileID.overscaledZ >= e ? i : null
                }
                for (let i = t.overscaledZ - 1; i >= e; i--) {
                    const e = t.scaledTo(i)
                      , r = this._getLoadedTile(e);
                    if (r)
                        return r
                }
            }
            _getLoadedTile(t) {
                const e = this._tiles[t.key];
                return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key)
            }
            updateCacheSize(t, e) {
                e = e || this._source.tileSize;
                const i = Math.ceil(t.width / e) + 1
                  , r = Math.ceil(t.height / e) + 1
                  , n = Math.floor(i * r * 5)
                  , o = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, n) : n
                  , s = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;
                this._cache.setMaxSize(s)
            }
            handleWrapJump(t) {
                const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);
                if (this._prevLng = t,
                e) {
                    const t = {};
                    for (const i in this._tiles) {
                        const r = this._tiles[i];
                        r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e),
                        t[r.tileID.key] = r
                    }
                    this._tiles = t;
                    for (const t in this._timers)
                        clearTimeout(this._timers[t]),
                        delete this._timers[t];
                    for (const t in this._tiles)
                        this._setTileReloadTimer(+t, this._tiles[t])
                }
            }
            update(t, e, i) {
                if (this.transform = t,
                !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                    return;
                if (this.usedForTerrain && !i)
                    return;
                let r;
                this.updateCacheSize(t, e),
                "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng),
                this._coveredTiles = {},
                this.used || this.usedForTerrain ? this._source.tileID ? r = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t=>new Vu(t.canonical.z,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y))) : (r = t.coveringTiles({
                    tileSize: e || this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !i,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain
                }),
                this._source.hasTile && (r = r.filter((t=>this._source.hasTile(t))))) : r = [];
                const n = this._updateRetainedTiles(r);
                if (tf(this._source.type) && 0 !== r.length) {
                    const t = {}
                      , e = {}
                      , i = Object.keys(n);
                    for (const r of i) {
                        const i = n[r]
                          , o = this._tiles[r];
                        if (!o || o.fadeEndTime && o.fadeEndTime <= Zt.now())
                            continue;
                        const s = this.findLoadedParent(i, Math.max(i.overscaledZ - Km.maxOverzooming, this._source.minzoom));
                        s && (this._addTile(s.tileID),
                        t[s.tileID.key] = s.tileID),
                        e[r] = i
                    }
                    const o = r[r.length - 1].overscaledZ;
                    for (const t in this._tiles) {
                        const i = this._tiles[t];
                        if (n[t] || !i.hasData())
                            continue;
                        let r = i.tileID;
                        for (; r.overscaledZ > o; ) {
                            r = r.scaledTo(r.overscaledZ - 1);
                            const o = this._tiles[r.key];
                            if (o && o.hasData() && e[r.key]) {
                                n[t] = i.tileID;
                                break
                            }
                        }
                    }
                    for (const e in t)
                        n[e] || (this._coveredTiles[e] = !0,
                        n[e] = t[e])
                }
                for (const t in n)
                    this._tiles[t].clearFadeHold();
                const o = function(t, e) {
                    const i = [];
                    for (const r in t)
                        r in e || i.push(r);
                    return i
                }(this._tiles, n);
                for (const t of o) {
                    const e = this._tiles[t];
                    e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t)
                }
                this._updateLoadedParentTileCache(),
                this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
            }
            releaseSymbolFadeTiles() {
                for (const t in this._tiles)
                    this._tiles[t].holdingForFade() && this._removeTile(+t)
            }
            _updateRetainedTiles(t) {
                const e = {};
                if (0 === t.length)
                    return e;
                const i = {}
                  , r = t.reduce(((t,e)=>Math.min(t, e.overscaledZ)), 1 / 0)
                  , n = t[0].overscaledZ
                  , o = Math.max(n - Km.maxOverzooming, this._source.minzoom)
                  , s = Math.max(n + Km.maxUnderzooming, this._source.minzoom)
                  , a = {};
                for (const i of t) {
                    const t = this._addTile(i);
                    e[i.key] = i,
                    t.hasData() || r < this._source.maxzoom && (a[i.key] = i)
                }
                this._retainLoadedChildren(a, r, s, e);
                for (const r of t) {
                    let t = this._tiles[r.key];
                    if (t.hasData())
                        continue;
                    if (r.canonical.z >= this._source.maxzoom) {
                        const t = r.children(this._source.maxzoom)[0]
                          , i = this.getTile(t);
                        if (i && i.hasData()) {
                            e[t.key] = t;
                            continue
                        }
                    } else {
                        const t = r.children(this._source.maxzoom);
                        if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key])
                            continue
                    }
                    let n = t.wasRequested();
                    for (let s = r.overscaledZ - 1; s >= o; --s) {
                        const o = r.scaledTo(s);
                        if (i[o.key])
                            break;
                        if (i[o.key] = !0,
                        t = this.getTile(o),
                        !t && n && (t = this._addTile(o)),
                        t && (e[o.key] = o,
                        n = t.wasRequested(),
                        t.hasData()))
                            break
                    }
                }
                return e
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const t in this._tiles) {
                    const e = [];
                    let i, r = this._tiles[t].tileID;
                    for (; r.overscaledZ > 0; ) {
                        if (r.key in this._loadedParentTiles) {
                            i = this._loadedParentTiles[r.key];
                            break
                        }
                        e.push(r.key);
                        const t = r.scaledTo(r.overscaledZ - 1);
                        if (i = this._getLoadedTile(t),
                        i)
                            break;
                        r = t
                    }
                    for (const t of e)
                        this._loadedParentTiles[t] = i
                }
            }
            _addTile(t) {
                let e = this._tiles[t.key];
                if (e)
                    return e;
                e = this._cache.getAndRemove(t),
                e && (this._setTileReloadTimer(t.key, e),
                e.tileID = t,
                this._state.initializeTileState(e, this.map ? this.map.painter : null),
                this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]),
                delete this._cacheTimers[t.key],
                this._setTileReloadTimer(t.key, e)));
                const i = Boolean(e);
                if (!i) {
                    const i = this.map ? this.map.painter : null;
                    e = new km(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,i,this._isRaster),
                    this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state))
                }
                return e ? (e.uses++,
                this._tiles[t.key] = e,
                i || this._source.fire(new qt("dataloading",{
                    tile: e,
                    coord: e.tileID,
                    dataType: "source"
                })),
                e) : null
            }
            _setTileReloadTimer(t, e) {
                t in this._timers && (clearTimeout(this._timers[t]),
                delete this._timers[t]);
                const i = e.getExpiryTimeout();
                i && (this._timers[t] = setTimeout((()=>{
                    this._reloadTile(t, "expired"),
                    delete this._timers[t]
                }
                ), i))
            }
            _removeTile(t) {
                const e = this._tiles[t];
                e && (e.uses--,
                delete this._tiles[t],
                this._timers[t] && (clearTimeout(this._timers[t]),
                delete this._timers[t]),
                e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0,
                this._abortTile(e),
                this._unloadTile(e))))
            }
            clearTiles() {
                this._shouldReloadOnResume = !1,
                this._paused = !1;
                for (const t in this._tiles)
                    this._removeTile(+t);
                this._source._clear && this._source._clear(),
                this._cache.reset(),
                this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id)
            }
            tilesIn(t, e, i) {
                const r = []
                  , n = this.transform;
                if (!n)
                    return r;
                const o = "globe" === n.projection.name
                  , s = Ia(n.center.lng);
                for (const a in this._tiles) {
                    const l = this._tiles[a];
                    if (i && l.clearQueryDebugViz(),
                    l.holdingForFade())
                        continue;
                    let c;
                    if (o) {
                        const t = l.tileID.canonical;
                        if (0 === t.z) {
                            const e = [Math.abs(T(s, ...ef(t, -1)) - s), Math.abs(T(s, ...ef(t, 1)) - s)];
                            c = [0, 2 * e.indexOf(Math.min(...e)) - 1]
                        } else {
                            const e = [Math.abs(T(s, ...ef(t, -1)) - s), Math.abs(T(s, ...ef(t, 0)) - s), Math.abs(T(s, ...ef(t, 1)) - s)];
                            c = [e.indexOf(Math.min(...e)) - 1]
                        }
                    } else
                        c = [0];
                    for (const i of c) {
                        const o = t.containsTile(l, n, e, i);
                        o && r.push(o)
                    }
                }
                return r
            }
            getVisibleCoordinates(t) {
                const e = this.getRenderableIds(t).map((t=>this._tiles[t].tileID));
                for (const t of e)
                    t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());
                return e
            }
            hasTransition() {
                if (this._source.hasTransition())
                    return !0;
                if (tf(this._source.type))
                    for (const t in this._tiles) {
                        const e = this._tiles[t];
                        if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Zt.now())
                            return !0
                    }
                return !1
            }
            setFeatureState(t, e, i) {
                this._state.updateState(t = t || "_geojsonTileLayer", e, i)
            }
            removeFeatureState(t, e, i) {
                this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i)
            }
            getFeatureState(t, e) {
                return this._state.getState(t = t || "_geojsonTileLayer", e)
            }
            setDependencies(t, e, i) {
                const r = this._tiles[t];
                r && r.setDependencies(e, i)
            }
            reloadTilesForDependencies(t, e) {
                for (const i in this._tiles)
                    this._tiles[i].hasDependency(t, e) && this._reloadTile(+i, "reloading");
                this._cache.filter((i=>!i.hasDependency(t, e)))
            }
            _preloadTiles(t, e) {
                const i = new Map
                  , r = Array.isArray(t) ? t : [t]
                  , n = this.map.painter.terrain
                  , o = this.usedForTerrain && n ? n.getScaledDemTileSize() : this._source.tileSize;
                for (const t of r) {
                    const e = t.coveringTiles({
                        tileSize: o,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const t of e)
                        i.set(t.key, t);
                    this.usedForTerrain && t.updateElevation(!1)
                }
                M(Array.from(i.values()), ((t,e)=>{
                    const i = new km(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);
                    this._loadTile(i, (t=>{
                        "raster-dem" === this._source.type && i.dem && this._backfillDEM(i),
                        e(t, i)
                    }
                    ))
                }
                ), e)
            }
        }
        function Qm(t, e) {
            const i = Math.abs(2 * t.wrap) - +(t.wrap < 0)
              , r = Math.abs(2 * e.wrap) - +(e.wrap < 0);
            return t.overscaledZ - e.overscaledZ || r - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x
        }
        function tf(t) {
            return "raster" === t || "image" === t || "video" === t || "custom" === t
        }
        function ef(t, e) {
            const i = 1 << t.z;
            return [t.x / i + e, (t.x + 1) / i + e]
        }
        Km.maxOverzooming = 10,
        Km.maxUnderzooming = 3;
        class rf {
            constructor(t, e, i) {
                this._demTile = t,
                this._dem = this._demTile.dem,
                this._scale = e,
                this._offset = i
            }
            static create(t, e, i) {
                const r = i || t.findDEMTileFor(e);
                if (!r || !r.dem)
                    return;
                const n = r.dem
                  , o = r.tileID
                  , s = 1 << e.canonical.z - o.canonical.z;
                return new rf(r,r.tileSize / za / s,[(e.canonical.x / s - o.canonical.x) * n.dim, (e.canonical.y / s - o.canonical.y) * n.dim])
            }
            tileCoordToPixel(t, e) {
                const i = e * this._scale + this._offset[1]
                  , r = Math.floor(t * this._scale + this._offset[0])
                  , n = Math.floor(i);
                return new m(r,n)
            }
            getElevationAt(t, e, i, r) {
                const n = t * this._scale + this._offset[0]
                  , o = e * this._scale + this._offset[1]
                  , s = Math.floor(n)
                  , a = Math.floor(o)
                  , l = this._dem;
                return r = !!r,
                i ? Mi(Mi(l.get(s, a, r), l.get(s, a + 1, r), o - a), Mi(l.get(s + 1, a, r), l.get(s + 1, a + 1, r), o - a), n - s) : l.get(s, a, r)
            }
            getElevationAtPixel(t, e, i) {
                return this._dem.get(t, e, !!i)
            }
            getMeterToDEM(t) {
                return (1 << this._demTile.tileID.canonical.z) * Da(1, t) * this._dem.stride
            }
        }
        class nf {
            constructor(t, e) {
                this.tileID = t,
                this.x = t.canonical.x,
                this.y = t.canonical.y,
                this.z = t.canonical.z,
                this.grid = new Un(za,16,0),
                this.featureIndexArray = new Ns,
                this.promoteId = e
            }
            insert(t, e, i, r, n, o=0) {
                const s = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(i, r, n, o);
                const a = this.grid;
                for (let t = 0; t < e.length; t++) {
                    const i = e[t]
                      , r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        r[0] = Math.min(r[0], e.x),
                        r[1] = Math.min(r[1], e.y),
                        r[2] = Math.max(r[2], e.x),
                        r[3] = Math.max(r[3], e.y)
                    }
                    r[0] < za && r[1] < za && r[2] >= 0 && r[3] >= 0 && a.insert(s, r[0], r[1], r[2], r[3])
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new bu(new zh(this.rawTileData)).layers,
                    this.sourceLayerCoder = new vm(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]),
                    this.vtFeatures = {};
                    for (const t in this.vtLayers)
                        this.vtFeatures[t] = []
                }
                return this.vtLayers
            }
            query(t, e, i, r) {
                this.loadVTLayers();
                const n = t.params || {}
                  , o = sn(n.filter)
                  , s = t.tileResult
                  , a = t.transform
                  , l = s.bufferedTilespaceBounds
                  , c = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, ((t,e,i,r)=>sl(s.bufferedTilespaceGeometry, t, e, i, r)));
                c.sort(sf);
                let u = null;
                a.elevation && c.length > 0 && (u = rf.create(a.elevation, this.tileID));
                const h = {};
                let d;
                for (let a = 0; a < c.length; a++) {
                    const l = c[a];
                    if (l === d)
                        continue;
                    d = l;
                    const p = this.featureIndexArray.get(l);
                    let m = null;
                    this.loadMatchingFeature(h, p, o, n.layers, n.availableImages, e, i, r, ((e,i,r,n=0)=>(m || (m = Ja(e, this.tileID.canonical, t.tileTransform)),
                    i.queryIntersectsFeature(s, e, r, m, this.z, t.transform, t.pixelPosMatrix, u, n))))
                }
                return h
            }
            loadMatchingFeature(t, e, i, r, n, o, s, a, l) {
                const {featureIndex: c, bucketIndex: u, sourceLayerIndex: h, layoutVertexArrayOffset: d} = e
                  , p = this.bucketLayerIDs[u];
                if (r && !function(t, e) {
                    for (let i = 0; i < t.length; i++)
                        if (e.indexOf(t[i]) >= 0)
                            return !0;
                    return !1
                }(r, p))
                    return;
                const m = this.sourceLayerCoder.decode(h)
                  , f = this.vtLayers[m].feature(c);
                if (i.needGeometry) {
                    const t = Xa(f, !0);
                    if (!i.filter(new Go(this.tileID.overscaledZ), t, this.tileID.canonical))
                        return
                } else if (!i.filter(new Go(this.tileID.overscaledZ), f))
                    return;
                const _ = this.getId(f, m);
                for (let e = 0; e < p.length; e++) {
                    const i = p[e];
                    if (r && r.indexOf(i) < 0)
                        continue;
                    const u = o[i];
                    if (!u)
                        continue;
                    let h = {};
                    void 0 !== _ && a && (h = a.getState(u.sourceLayer || "_geojsonTileLayer", _));
                    const m = I({}, s[i]);
                    m.paint = of(m.paint, u.paint, f, h, n),
                    m.layout = of(m.layout, u.layout, f, h, n);
                    const g = !l || l(f, u, h, d);
                    if (!g)
                        continue;
                    const y = new wm(f,this.z,this.x,this.y,_);
                    y.layer = m;
                    let x = t[i];
                    void 0 === x && (x = t[i] = []),
                    x.push({
                        featureIndex: c,
                        feature: y,
                        intersectionZ: g
                    })
                }
            }
            lookupSymbolFeatures(t, e, i, r, n, o, s, a) {
                const l = {};
                this.loadVTLayers();
                const c = sn(n);
                for (const n of t)
                    this.loadMatchingFeature(l, {
                        bucketIndex: i,
                        sourceLayerIndex: r,
                        featureIndex: n,
                        layoutVertexArrayOffset: 0
                    }, c, o, s, a, e);
                return l
            }
            loadFeature(t) {
                const {featureIndex: e, sourceLayerIndex: i} = t;
                this.loadVTLayers();
                const r = this.sourceLayerCoder.decode(i)
                  , n = this.vtFeatures[r];
                if (n[e])
                    return n[e];
                const o = this.vtLayers[r].feature(e);
                return n[e] = o,
                o
            }
            hasLayer(t) {
                for (const e of this.bucketLayerIDs)
                    for (const i of e)
                        if (t === i)
                            return !0;
                return !1
            }
            getId(t, e) {
                let i = t.id;
                if (this.promoteId) {
                    const r = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    null != r && (i = t.properties[r]),
                    "boolean" == typeof i && (i = Number(i))
                }
                return i
            }
        }
        function of(t, e, i, r, n) {
            return B(t, ((t,o)=>{
                const s = e instanceof Yo ? e.get(o) : null;
                return s && s.evaluate ? s.evaluate(i, r, n) : s
            }
            ))
        }
        function sf(t, e) {
            return e - t
        }
        jn(nf, "FeatureIndex", {
            omit: ["rawTileData", "sourceLayerCoder"]
        });
        class af {
            constructor(t, e) {
                this.width = t,
                this.height = e,
                this.nextRow = 0,
                this.image = new fc({
                    width: t,
                    height: e
                }),
                this.positions = {},
                this.uploaded = !1
            }
            getDash(t, e) {
                const i = this.getKey(t, e);
                return this.positions[i]
            }
            trim() {
                const t = this.width
                  , e = this.height = P(this.nextRow);
                this.image.resize({
                    width: t,
                    height: e
                })
            }
            getKey(t, e) {
                return t.join(",") + e
            }
            getDashRanges(t, e, i) {
                const r = [];
                let n = t.length % 2 == 1 ? -t[t.length - 1] * i : 0
                  , o = t[0] * i
                  , s = !0;
                r.push({
                    left: n,
                    right: o,
                    isDash: s,
                    zeroLength: 0 === t[0]
                });
                let a = t[0];
                for (let e = 1; e < t.length; e++) {
                    s = !s;
                    const l = t[e];
                    n = a * i,
                    a += l,
                    o = a * i,
                    r.push({
                        left: n,
                        right: o,
                        isDash: s,
                        zeroLength: 0 === l
                    })
                }
                return r
            }
            addRoundDash(t, e, i) {
                const r = e / 2;
                for (let e = -i; e <= i; e++) {
                    const n = this.width * (this.nextRow + i + e);
                    let o = 0
                      , s = t[o];
                    for (let a = 0; a < this.width; a++) {
                        a / s.right > 1 && (s = t[++o]);
                        const l = Math.abs(a - s.left)
                          , c = Math.abs(a - s.right)
                          , u = Math.min(l, c);
                        let h;
                        const d = e / i * (r + 1);
                        if (s.isDash) {
                            const t = r - Math.abs(d);
                            h = Math.sqrt(u * u + t * t)
                        } else
                            h = r - Math.sqrt(u * u + d * d);
                        this.image.data[n + a] = Math.max(0, Math.min(255, h + 128))
                    }
                }
            }
            addRegularDash(t, e) {
                for (let e = t.length - 1; e >= 0; --e) {
                    const i = t[e]
                      , r = t[e + 1];
                    i.zeroLength ? t.splice(e, 1) : r && r.isDash === i.isDash && (r.left = i.left,
                    t.splice(e, 1))
                }
                const i = t[0]
                  , r = t[t.length - 1];
                i.isDash === r.isDash && (i.left = r.left - this.width,
                r.right = i.right + this.width);
                const n = this.width * this.nextRow;
                let o = 0
                  , s = t[o];
                for (let i = 0; i < this.width; i++) {
                    i / s.right > 1 && (s = t[++o]);
                    const r = Math.abs(i - s.left)
                      , a = Math.abs(i - s.right)
                      , l = Math.min(r, a);
                    this.image.data[n + i] = Math.max(0, Math.min(255, (s.isDash ? l : -l) + e + 128))
                }
            }
            addDash(t, e) {
                const i = this.getKey(t, e);
                if (this.positions[i])
                    return this.positions[i];
                const r = "round" === e
                  , n = r ? 7 : 0
                  , o = 2 * n + 1;
                if (this.nextRow + o > this.height)
                    return G("LineAtlas out of space"),
                    null;
                0 === t.length && t.push(1);
                let s = 0;
                for (let e = 0; e < t.length; e++)
                    t[e] < 0 && (G("Negative value is found in line dasharray, replacing values with 0"),
                    t[e] = 0),
                    s += t[e];
                if (0 !== s) {
                    const i = this.width / s
                      , o = this.getDashRanges(t, this.width, i);
                    r ? this.addRoundDash(o, i, n) : this.addRegularDash(o, "square" === e ? .5 * i : 0)
                }
                const a = this.nextRow + n;
                this.nextRow += o;
                const l = {
                    tl: [a, n],
                    br: [s, 0]
                };
                return this.positions[i] = l,
                l
            }
        }
        jn(af, "LineAtlas");
        class lf {
            constructor(t) {
                const e = {}
                  , i = [];
                for (const r in t) {
                    const n = t[r]
                      , o = e[r] = {};
                    for (const t in n.glyphs) {
                        const e = n.glyphs[+t];
                        if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height)
                            continue;
                        const r = e.metrics.localGlyph ? 2 : 1
                          , s = {
                            x: 0,
                            y: 0,
                            w: e.bitmap.width + 2 * r,
                            h: e.bitmap.height + 2 * r
                        };
                        i.push(s),
                        o[t] = s
                    }
                }
                const {w: r, h: n} = $h(i)
                  , o = new fc({
                    width: r || 1,
                    height: n || 1
                });
                for (const i in t) {
                    const r = t[i];
                    for (const t in r.glyphs) {
                        const n = r.glyphs[+t];
                        if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height)
                            continue;
                        const s = e[i][t]
                          , a = n.metrics.localGlyph ? 2 : 1;
                        fc.copy(n.bitmap, o, {
                            x: 0,
                            y: 0
                        }, {
                            x: s.x + a,
                            y: s.y + a
                        }, n.bitmap)
                    }
                }
                this.image = o,
                this.positions = e
            }
        }
        jn(lf, "GlyphAtlas");
        class cf {
            constructor(t) {
                this.tileID = new Vu(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),
                this.tileZoom = t.tileZoom,
                this.uid = t.uid,
                this.zoom = t.zoom,
                this.canonical = t.tileID.canonical,
                this.pixelRatio = t.pixelRatio,
                this.tileSize = t.tileSize,
                this.source = t.source,
                this.overscaling = this.tileID.overscaleFactor(),
                this.showCollisionBoxes = t.showCollisionBoxes,
                this.collectResourceTiming = !!t.collectResourceTiming,
                this.returnDependencies = !!t.returnDependencies,
                this.promoteId = t.promoteId,
                this.enableTerrain = !!t.enableTerrain,
                this.isSymbolTile = t.isSymbolTile,
                this.tileTransform = Cp(t.tileID.canonical, t.projection),
                this.projection = t.projection
            }
            parse(t, e, i, r, n) {
                this.status = "parsing",
                this.data = t,
                this.collisionBoxArray = new ks;
                const o = new vm(Object.keys(t.layers).sort())
                  , s = new nf(this.tileID,this.promoteId);
                s.bucketLayerIDs = [];
                const a = {}
                  , l = new af(256,256)
                  , c = {
                    featureIndex: s,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: l,
                    availableImages: i
                }
                  , u = e.familiesBySource[this.source];
                for (const e in u) {
                    const r = t.layers[e];
                    if (!r)
                        continue;
                    let n = !1
                      , l = !1;
                    for (const t of u[e])
                        "symbol" === t[0].type ? n = !0 : l = !0;
                    if (!0 === this.isSymbolTile && !n)
                        continue;
                    if (!1 === this.isSymbolTile && !l)
                        continue;
                    1 === r.version && G(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const h = o.encode(e)
                      , d = [];
                    for (let t = 0; t < r.length; t++) {
                        const i = r.feature(t)
                          , n = s.getId(i, e);
                        d.push({
                            feature: i,
                            id: n,
                            index: t,
                            sourceLayerIndex: h
                        })
                    }
                    for (const t of u[e]) {
                        const e = t[0];
                        void 0 !== this.isSymbolTile && "symbol" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || "none" !== e.visibility && (uf(t, this.zoom, i),
                        (a[e.id] = e.createBucket({
                            index: s.bucketLayerIDs.length,
                            layers: t,
                            zoom: this.zoom,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: h,
                            sourceID: this.source,
                            enableTerrain: this.enableTerrain,
                            projection: this.projection.spec,
                            availableImages: i
                        })).populate(d, c, this.tileID.canonical, this.tileTransform),
                        s.bucketLayerIDs.push(t.map((t=>t.id))))
                    }
                }
                let h, d, p, m;
                l.trim();
                const f = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }
                  , _ = B(c.glyphDependencies, (t=>Object.keys(t).map(Number)));
                Object.keys(_).length ? r.send("getGlyphs", {
                    uid: this.uid,
                    stacks: _
                }, ((t,e)=>{
                    h || (h = t,
                    d = e,
                    x.call(this))
                }
                ), void 0, !1, f) : d = {};
                const g = Object.keys(c.iconDependencies);
                g.length ? r.send("getImages", {
                    icons: g,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, ((t,e)=>{
                    h || (h = t,
                    p = e,
                    x.call(this))
                }
                ), void 0, !1, f) : p = {};
                const y = Object.keys(c.patternDependencies);
                function x() {
                    if (h)
                        return n(h);
                    if (d && p && m) {
                        const t = new lf(d)
                          , e = new Wh(p,m);
                        for (const r in a) {
                            const n = a[r];
                            n instanceof sm ? (uf(n.layers, this.zoom, i),
                            Nd(n, d, t.positions, p, e.iconPositions, this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection)) : n.hasPattern && (n instanceof eh || n instanceof iu || n instanceof Iu) && (uf(n.layers, this.zoom, i),
                            n.addFeatures(c, this.tileID.canonical, e.patternPositions, i, this.tileTransform))
                        }
                        this.status = "done",
                        n(null, {
                            buckets: A(a).filter((t=>!t.isEmpty())),
                            featureIndex: s,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t.image,
                            lineAtlas: l,
                            imageAtlas: e,
                            glyphMap: this.returnDependencies ? d : null,
                            iconMap: this.returnDependencies ? p : null,
                            glyphPositions: this.returnDependencies ? t.positions : null
                        })
                    }
                }
                y.length ? r.send("getImages", {
                    icons: y,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, ((t,e)=>{
                    h || (h = t,
                    m = e,
                    x.call(this))
                }
                ), void 0, !1, f) : m = {},
                x.call(this)
            }
        }
        function uf(t, e, i) {
            const r = new Go(e);
            for (const e of t)
                e.recalculate(r, i)
        }
        class hf {
            constructor(t) {
                this.entries = {},
                this.scheduler = t
            }
            request(t, e, i, r) {
                const n = this.entries[t] = this.entries[t] || {
                    callbacks: []
                };
                if (n.result) {
                    const [t,i] = n.result;
                    return this.scheduler ? this.scheduler.add((()=>{
                        r(t, i)
                    }
                    ), e) : r(t, i),
                    ()=>{}
                }
                return n.callbacks.push(r),
                n.cancel || (n.cancel = i(((i,r)=>{
                    n.result = [i, r];
                    for (const t of n.callbacks)
                        this.scheduler ? this.scheduler.add((()=>{
                            t(i, r)
                        }
                        ), e) : t(i, r);
                    setTimeout((()=>delete this.entries[t]), 3e3)
                }
                ))),
                ()=>{
                    n.result || (n.callbacks = n.callbacks.filter((t=>t !== r)),
                    n.callbacks.length || (n.cancel(),
                    delete this.entries[t]))
                }
            }
        }
        function df(t, e, i) {
            const r = JSON.stringify(t.request);
            return t.data && (this.deduped.entries[r] = {
                result: [null, t.data]
            }),
            this.deduped.request(r, {
                type: "parseTile",
                isSymbolTile: t.isSymbolTile,
                zoom: t.tileZoom
            }, (e=>{
                const r = ct(t.request, ((t,r,n,o)=>{
                    t ? e(t) : r && e(null, {
                        vectorTile: i ? void 0 : new bu(new zh(r)),
                        rawData: r,
                        cacheControl: n,
                        expires: o
                    })
                }
                ));
                return ()=>{
                    r.cancel(),
                    e()
                }
            }
            ), e)
        }
        t.ARRAY_TYPE = fl,
        t.AUTH_ERR_MSG = ft,
        t.Aabb = oc,
        t.Actor = class {
            constructor(t, i, r) {
                this.target = t,
                this.parent = i,
                this.mapId = r,
                this.callbacks = {},
                this.cancelCallbacks = {},
                O(["receive"], this),
                this.target.addEventListener("message", this.receive, !1),
                this.globalScope = Z() ? t : e,
                this.scheduler = new xm
            }
            send(t, e, i, r, n=!1, o) {
                const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                i && (i.metadata = o,
                this.callbacks[s] = i);
                const a = q(this.globalScope) ? void 0 : [];
                return this.target.postMessage({
                    id: s,
                    type: t,
                    hasCallback: !!i,
                    targetMapId: r,
                    mustQueue: n,
                    sourceMapId: this.mapId,
                    data: Jn(e, a)
                }, a),
                {
                    cancel: ()=>{
                        i && delete this.callbacks[s],
                        this.target.postMessage({
                            id: s,
                            type: "<cancel>",
                            targetMapId: r,
                            sourceMapId: this.mapId
                        })
                    }
                }
            }
            receive(t) {
                const e = t.data
                  , i = e.id;
                if (i && (!e.targetMapId || this.mapId === e.targetMapId))
                    if ("<cancel>" === e.type) {
                        const t = this.cancelCallbacks[i];
                        delete this.cancelCallbacks[i],
                        t && t.cancel()
                    } else if (e.mustQueue || Z()) {
                        const t = this.callbacks[i];
                        this.cancelCallbacks[i] = this.scheduler.add((()=>this.processTask(i, e)), t && t.metadata || {
                            type: "message"
                        })
                    } else
                        this.processTask(i, e)
            }
            processTask(t, e) {
                if ("<response>" === e.type) {
                    const i = this.callbacks[t];
                    delete this.callbacks[t],
                    i && (e.error ? i(Xn(e.error)) : i(null, Xn(e.data)))
                } else {
                    const i = q(this.globalScope) ? void 0 : []
                      , r = e.hasCallback ? (e,r)=>{
                        delete this.cancelCallbacks[t],
                        this.target.postMessage({
                            id: t,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? Jn(e) : null,
                            data: Jn(r, i)
                        }, i)
                    }
                    : t=>{}
                      , n = Xn(e.data);
                    if (this.parent[e.type])
                        this.parent[e.type](e.sourceMapId, n, r);
                    else if (this.parent.getWorkerSource) {
                        const t = e.type.split(".");
                        this.parent.getWorkerSource(e.sourceMapId, t[0], n.source)[t[1]](n, r)
                    } else
                        r(new Error(`Could not find function ${e.type}`))
                }
            }
            remove() {
                this.scheduler.remove(),
                this.target.removeEventListener("message", this.receive, !1)
            }
        }
        ,
        t.CanonicalTileID = Gu,
        t.Color = Me,
        t.ColorMode = $m,
        t.CullFaceMode = Hm,
        t.DEMData = Vm,
        t.DataConstantProperty = Wo,
        t.DedupedRequest = hf,
        t.DepthMode = Jm,
        t.EXTENT = za,
        t.Elevation = class {
            isDataAvailableAtPoint(t) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1)
                    return !1;
                const i = e.getSource().maxzoom
                  , r = 1 << i
                  , n = Math.floor(t.x)
                  , o = Math.floor((t.x - n) * r)
                  , s = Math.floor(t.y * r)
                  , a = this.findDEMTileFor(new Vu(i,n,i,o,s));
                return !(!a || !a.dem)
            }
            getAtPointOrZero(t, e=0) {
                return this.getAtPoint(t, e) || 0
            }
            getAtPoint(t, e, i=!0) {
                if (this.isUsingMockSource())
                    return null;
                null == e && (e = null);
                const r = this._source();
                if (!r)
                    return e;
                if (t.y < 0 || t.y > 1)
                    return e;
                const n = r.getSource().maxzoom
                  , o = 1 << n
                  , s = Math.floor(t.x)
                  , a = t.x - s
                  , l = new Vu(n,s,n,Math.floor(a * o),Math.floor(t.y * o))
                  , c = this.findDEMTileFor(l);
                if (!c || !c.dem)
                    return e;
                const u = c.dem
                  , h = 1 << c.tileID.canonical.z
                  , d = (a * h - c.tileID.canonical.x) * u.dim
                  , p = (t.y * h - c.tileID.canonical.y) * u.dim
                  , m = Math.floor(d)
                  , f = Math.floor(p);
                return (i ? this.exaggeration() : 1) * Mi(Mi(u.get(m, f), u.get(m, f + 1), p - f), Mi(u.get(m + 1, f), u.get(m + 1, f + 1), p - f), d - m)
            }
            getAtTileOffset(t, e, i) {
                const r = 1 << t.canonical.z;
                return this.getAtPointOrZero(new Ba(t.wrap + (t.canonical.x + e / za) / r,(t.canonical.y + i / za) / r))
            }
            getAtTileOffsetFunc(t, e, i, r) {
                return n=>{
                    const o = this.getAtTileOffset(t, n.x, n.y)
                      , s = r.upVector(t.canonical, n.x, n.y);
                    return Bl(s, s, o * r.upVectorScale(t.canonical, e, i).metersToTile),
                    s
                }
            }
            getForTilePoints(t, e, i, r) {
                if (this.isUsingMockSource())
                    return !1;
                const n = rf.create(this, t, r);
                return !!n && (e.forEach((t=>{
                    t[2] = this.exaggeration() * n.getElevationAt(t[0], t[1], i)
                }
                )),
                !0)
            }
            getMinMaxForTile(t) {
                if (this.isUsingMockSource())
                    return null;
                const e = this.findDEMTileFor(t);
                if (!e || !e.dem)
                    return null;
                const i = e.dem.tree
                  , r = e.tileID
                  , n = 1 << t.canonical.z - r.canonical.z;
                let o = t.canonical.x / n - r.canonical.x
                  , s = t.canonical.y / n - r.canonical.y
                  , a = 0;
                for (let e = 0; e < t.canonical.z - r.canonical.z && !i.leaves[a]; e++) {
                    o *= 2,
                    s *= 2;
                    const t = 2 * Math.floor(s) + Math.floor(o);
                    a = i.childOffsets[a] + t,
                    o %= 1,
                    s %= 1
                }
                return {
                    min: this.exaggeration() * i.minimums[a],
                    max: this.exaggeration() * i.maximums[a]
                }
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.")
            }
            raycast(t, e, i) {
                throw new Error("Pure virtual method called.")
            }
            pointCoordinate(t) {
                throw new Error("Pure virtual method called.")
            }
            _source() {
                throw new Error("Pure virtual method called.")
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.")
            }
            exaggeration() {
                throw new Error("Pure virtual method called.")
            }
            findDEMTileFor(t) {
                throw new Error("Pure virtual method called.")
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.")
            }
        }
        ,
        t.ErrorEvent = $t,
        t.EvaluationParameters = Go,
        t.Event = qt,
        t.Evented = Yt,
        t.FillExtrusionBucket = Iu,
        t.Frustum = nc,
        t.FrustumCorners = rc,
        t.GLOBE_METERS_TO_ECEF = tp,
        t.GLOBE_RADIUS = Qd,
        t.GLOBE_SCALE_MATCH_LATITUDE = 45,
        t.GLOBE_ZOOM_THRESHOLD_MAX = 6,
        t.GLOBE_ZOOM_THRESHOLD_MIN = 5,
        t.GlobeSharedBuffers = class {
            constructor(t) {
                this._createGrid(t),
                this._createPoles(t)
            }
            destroy() {
                this._poleIndexBuffer.destroy(),
                this._gridBuffer.destroy(),
                this._gridIndexBuffer.destroy(),
                this._poleNorthVertexBuffer.destroy(),
                this._poleSouthVertexBuffer.destroy();
                for (const t of this._poleSegments)
                    t.destroy();
                for (const t of this._gridSegments)
                    t.destroy();
                if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const t of this._wireframeSegments)
                        t.destroy()
                }
            }
            _createGrid(t) {
                const e = new ss
                  , i = new ws
                  , r = 65;
                for (let t = 0; t < r; t++)
                    for (let i = 0; i < r; i++)
                        e.emplaceBack(i, t);
                this._gridSegments = [];
                for (let t = 0, e = 0; t < ip.length; t++) {
                    const n = ip[t];
                    for (let t = 0; t < n; t++)
                        for (let e = 0; e < 64; e++) {
                            const n = t * r + e;
                            i.emplaceBack(n + 1, n, n + r),
                            i.emplaceBack(n + r, n + r + 1, n + 1)
                        }
                    const o = 64 * n * 2;
                    this._gridSegments.push(wa.simpleSegment(0, e, (n + 1) * r, o)),
                    e += o
                }
                this._gridBuffer = t.createVertexBuffer(e, Kd.members),
                this._gridIndexBuffer = t.createIndexBuffer(i, !0)
            }
            _createPoles(t) {
                const e = new ws;
                for (let t = 0; t <= ep; t++)
                    e.emplaceBack(0, t + 1, t + 2);
                this._poleIndexBuffer = t.createIndexBuffer(e, !0);
                const i = new Ss
                  , r = new Ss;
                this._poleSegments = [];
                for (let t = 0, e = 0; t < 5; t++) {
                    const n = 360 / (1 << t);
                    i.emplaceBack(0, -Qd, 0, .5, 0),
                    r.emplaceBack(0, -Qd, 0, .5, 1);
                    for (let t = 0; t <= ep; t++) {
                        const e = t / ep
                          , o = Mi(0, n, e)
                          , [s,a,l] = fp(Mp, Ap, o, Qd);
                        i.emplaceBack(s, a, l, e, 0),
                        r.emplaceBack(s, a, l, e, 1)
                    }
                    this._poleSegments.push(wa.simpleSegment(e, 0, 66, 64)),
                    e += 66
                }
                this._poleNorthVertexBuffer = t.createVertexBuffer(i, Wd, !1),
                this._poleSouthVertexBuffer = t.createVertexBuffer(r, Wd, !1)
            }
            getGridBuffers(t) {
                return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments[t]]
            }
            getPoleBuffers(t) {
                return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]]
            }
            getWirefameBuffers(t, e) {
                if (!this._wireframeSegments) {
                    const e = new As
                      , i = ep
                      , r = i + 1;
                    this._wireframeSegments = [];
                    for (let t = 0, n = 0; t < ip.length; t++) {
                        const o = ip[t];
                        for (let t = 0; t < o; t++)
                            for (let n = 0; n < i; n++) {
                                const i = t * r + n;
                                e.emplaceBack(i, i + 1),
                                e.emplaceBack(i, i + r),
                                e.emplaceBack(i, i + r + 1)
                            }
                        const s = o * i * 3;
                        this._wireframeSegments.push(wa.simpleSegment(0, n, (o + 1) * r, s)),
                        n += s
                    }
                    this._wireframeIndexBuffer = t.createIndexBuffer(e)
                }
                return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]]
            }
        }
        ,
        t.GlyphManager = Ed,
        t.ImagePosition = Yh,
        t.LivePerformanceUtils = Rt,
        t.LngLat = Sa,
        t.LngLatBounds = Ta,
        t.LocalGlyphMode = Td,
        t.MAX_MERCATOR_LATITUDE = Oa,
        t.MercatorCoordinate = Ba,
        t.ONE_EM = ph,
        t.OverscaledTileID = Vu,
        t.PerformanceMarkers = Ot,
        t.Properties = Qo,
        t.RGBAImage = _c,
        t.Ray = ic,
        t.RequestManager = class {
            constructor(t, e, i) {
                this._transformRequestFn = t,
                this._customAccessToken = e,
                this._silenceAuthErrors = !!i,
                this._createSkuToken()
            }
            _createSkuToken() {
                const t = function() {
                    let t = "";
                    for (let e = 0; e < 10; e++)
                        t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: ["1", h, t].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    }
                }();
                this._skuToken = t.token,
                this._skuTokenExpiresAt = t.tokenExpiresAt
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt
            }
            transformRequest(t, e) {
                return this._transformRequestFn && this._transformRequestFn(t, e) || {
                    url: t
                }
            }
            normalizeStyleURL(t, e) {
                if (!_t(t))
                    return t;
                const i = wt(t);
                return i.path = `/styles/v1${i.path}`,
                this._makeAPIURL(i, this._customAccessToken || e)
            }
            normalizeGlyphsURL(t, e) {
                if (!_t(t))
                    return t;
                const i = wt(t);
                return i.path = `/fonts/v1${i.path}`,
                this._makeAPIURL(i, this._customAccessToken || e)
            }
            normalizeSourceURL(t, e, i, r) {
                if (!_t(t))
                    return t;
                const n = wt(t);
                return n.path = `/v4/${n.authority}.json`,
                n.params.push("secure"),
                i && n.params.push(`language=${i}`),
                r && n.params.push(`worldview=${r}`),
                this._makeAPIURL(n, this._customAccessToken || e)
            }
            normalizeSpriteURL(t, e, i, r) {
                const n = wt(t);
                return _t(t) ? (n.path = `/styles/v1${n.path}/sprite${e}${i}`,
                this._makeAPIURL(n, this._customAccessToken || r)) : (n.path += `${e}${i}`,
                zt(n))
            }
            normalizeTileURL(t, e, i) {
                if (this._isSkuTokenExpired() && this._createSkuToken(),
                t && !_t(t))
                    return t;
                const r = wt(t);
                r.path = r.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || i && "raster" !== r.authority && 512 === i ? "@2x" : ""}${o.supported ? ".webp" : "$1"}`),
                "raster" === r.authority ? r.path = `/${n.RASTER_URL_PREFIX}${r.path}` : (r.path = r.path.replace(/^.+\/v4\//, "/"),
                r.path = `/${n.TILE_URL_VERSION}${r.path}`);
                const s = this._customAccessToken || function(t) {
                    for (const e of t) {
                        const t = e.match(/^access_token=(.*)$/);
                        if (t)
                            return t[1]
                    }
                    return null
                }(r.params) || n.ACCESS_TOKEN;
                return n.REQUIRE_ACCESS_TOKEN && s && this._skuToken && r.params.push(`sku=${this._skuToken}`),
                this._makeAPIURL(r, s)
            }
            canonicalizeTileURL(t, e) {
                const i = wt(t);
                if (!i.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !i.path.match(/\.[\w]+$/))
                    return t;
                let r = "mapbox://";
                i.path.match(/^\/raster\/v1\//) ? r += `raster/${i.path.replace(`/${n.RASTER_URL_PREFIX}/`, "")}` : r += `tiles/${i.path.replace(`/${n.TILE_URL_VERSION}/`, "")}`;
                let o = i.params;
                return e && (o = o.filter((t=>!t.match(/^access_token=/)))),
                o.length && (r += `?${o.join("&")}`),
                r
            }
            canonicalizeTileset(t, e) {
                const i = !!e && _t(e)
                  , r = [];
                for (const e of t.tiles || [])
                    gt(e) ? r.push(this.canonicalizeTileURL(e, i)) : r.push(e);
                return r
            }
            _makeAPIURL(t, e) {
                const i = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"
                  , r = wt(n.API_URL);
                if (t.protocol = r.protocol,
                t.authority = r.authority,
                "http" === t.protocol) {
                    const e = t.params.indexOf("secure");
                    e >= 0 && t.params.splice(e, 1)
                }
                if ("/" !== r.path && (t.path = `${r.path}${t.path}`),
                !n.REQUIRE_ACCESS_TOKEN)
                    return zt(t);
                if (e = e || n.ACCESS_TOKEN,
                !this._silenceAuthErrors) {
                    if (!e)
                        throw new Error(`An API access token is required to use Mapbox GL. ${i}`);
                    if ("s" === e[0])
                        throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i}`)
                }
                return t.params = t.params.filter((t=>-1 === t.indexOf("access_token"))),
                t.params.push(`access_token=${e || ""}`),
                zt(t)
            }
        }
        ,
        t.ResourceType = ot,
        t.SegmentVector = wa,
        t.SourceCache = Km,
        t.StencilMode = qm,
        t.StructArrayLayout1ui2 = Is,
        t.StructArrayLayout2f1f2i16 = xs,
        t.StructArrayLayout2i4 = ss,
        t.StructArrayLayout2ui4 = As,
        t.StructArrayLayout3f12 = bs,
        t.StructArrayLayout3ui6 = ws,
        t.StructArrayLayout4i8 = ls,
        t.StructArrayLayout5f20 = Ss,
        t.Texture = gm,
        t.Tile = km,
        t.Transitionable = Zo,
        t.Uniform1f = ta,
        t.Uniform1i = class extends Qs {
            constructor(t) {
                super(t),
                this.current = 0
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && this.current !== i && (this.current = i,
                this.gl.uniform1i(this.location, i))
            }
        }
        ,
        t.Uniform2f = class extends Qs {
            constructor(t) {
                super(t),
                this.current = [0, 0]
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i,
                this.gl.uniform2f(this.location, i[0], i[1])))
            }
        }
        ,
        t.Uniform3f = class extends Qs {
            constructor(t) {
                super(t),
                this.current = [0, 0, 0]
            }
            set(t, e, i) {
                this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i,
                this.gl.uniform3f(this.location, i[0], i[1], i[2])))
            }
        }
        ,
        t.Uniform4f = ea,
        t.UniformColor = ia,
        t.UniformMatrix2f = class extends Qs {
            constructor(t) {
                super(t),
                this.current = oa
            }
            set(t, e, i) {
                if (this.fetchUniformLocation(t, e))
                    for (let t = 0; t < 4; t++)
                        if (i[t] !== this.current[t]) {
                            this.current = i,
                            this.gl.uniformMatrix2fv(this.location, !1, i);
                            break
                        }
            }
        }
        ,
        t.UniformMatrix3f = class extends Qs {
            constructor(t) {
                super(t),
                this.current = na
            }
            set(t, e, i) {
                if (this.fetchUniformLocation(t, e))
                    for (let t = 0; t < 9; t++)
                        if (i[t] !== this.current[t]) {
                            this.current = i,
                            this.gl.uniformMatrix3fv(this.location, !1, i);
                            break
                        }
            }
        }
        ,
        t.UniformMatrix4f = class extends Qs {
            constructor(t) {
                super(t),
                this.current = ra
            }
            set(t, e, i) {
                if (this.fetchUniformLocation(t, e)) {
                    if (i[12] !== this.current[12] || i[0] !== this.current[0])
                        return this.current = i,
                        void this.gl.uniformMatrix4fv(this.location, !1, i);
                    for (let t = 1; t < 16; t++)
                        if (i[t] !== this.current[t]) {
                            this.current = i,
                            this.gl.uniformMatrix4fv(this.location, !1, i);
                            break
                        }
                }
            }
        }
        ,
        t.UnwrappedTileID = ju,
        t.ValidationError = Wr,
        t.VectorTileFeature = wu,
        t.VectorTileWorkerSource = class extends Yt {
            constructor(t, e, i, r, n) {
                super(),
                this.actor = t,
                this.layerIndex = e,
                this.availableImages = i,
                this.loadVectorData = n || df,
                this.loading = {},
                this.loaded = {},
                this.deduped = new hf(t.scheduler),
                this.isSpriteLoaded = r,
                this.scheduler = t.scheduler
            }
            loadTile(t, e) {
                const i = t.uid
                  , r = t && t.request
                  , n = r && r.collectResourceTiming
                  , o = this.loading[i] = new cf(t);
                o.abort = this.loadVectorData(t, ((s,a)=>{
                    const l = !this.loading[i];
                    if (delete this.loading[i],
                    l || s || !a)
                        return o.status = "done",
                        l || (this.loaded[i] = o),
                        e(s);
                    const c = a.rawData
                      , u = {};
                    a.expires && (u.expires = a.expires),
                    a.cacheControl && (u.cacheControl = a.cacheControl),
                    o.vectorTile = a.vectorTile || new bu(new zh(c));
                    const h = ()=>{
                        o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, ((t,i)=>{
                            if (t || !i)
                                return e(t);
                            const o = {};
                            if (n) {
                                const t = Ut(r);
                                t.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(t)))
                            }
                            e(null, I({
                                rawTileData: c.slice(0)
                            }, i, u, o))
                        }
                        ))
                    }
                    ;
                    this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", (()=>{
                        this.scheduler ? this.scheduler.add(h, {
                            type: "parseTile",
                            isSymbolTile: t.isSymbolTile,
                            zoom: t.tileZoom
                        }) : h()
                    }
                    )),
                    this.loaded = this.loaded || {},
                    this.loaded[i] = o
                }
                ))
            }
            reloadTile(t, e) {
                const i = this.loaded
                  , r = t.uid
                  , n = this;
                if (i && i[r]) {
                    const o = i[r];
                    o.showCollisionBoxes = t.showCollisionBoxes,
                    o.enableTerrain = !!t.enableTerrain,
                    o.projection = t.projection,
                    o.tileTransform = Cp(t.tileID.canonical, t.projection);
                    const s = (t,i)=>{
                        const r = o.reloadCallback;
                        r && (delete o.reloadCallback,
                        o.parse(o.vectorTile, n.layerIndex, this.availableImages, n.actor, r)),
                        e(t, i)
                    }
                    ;
                    "parsing" === o.status ? o.reloadCallback = s : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s())
                }
            }
            abortTile(t, e) {
                const i = t.uid
                  , r = this.loading[i];
                r && (r.abort && r.abort(),
                delete this.loading[i]),
                e()
            }
            removeTile(t, e) {
                const i = this.loaded
                  , r = t.uid;
                i && i[r] && delete i[r],
                e()
            }
        }
        ,
        t.WritingMode = Hh,
        t.add = kl,
        t.addDynamicAttributes = im,
        t.adjoint = function(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = e[3]
              , s = e[4]
              , a = e[5]
              , l = e[6]
              , c = e[7]
              , u = e[8];
            return t[0] = s * u - a * c,
            t[1] = n * c - r * u,
            t[2] = r * a - n * s,
            t[3] = a * l - o * u,
            t[4] = i * u - n * l,
            t[5] = n * o - i * a,
            t[6] = o * c - s * l,
            t[7] = r * l - i * c,
            t[8] = i * s - r * o,
            t
        }
        ,
        t.asyncAll = M,
        t.bezier = w,
        t.bindAll = O,
        t.boundsAttributes = Cm,
        t.bufferConvexPolygon = function(t, e) {
            const i = [];
            for (let r = 0; r < t.length; r++) {
                const n = S(r - 1, -1, t.length - 1)
                  , o = S(r + 1, -1, t.length - 1)
                  , s = t[r]
                  , a = t[o]
                  , l = t[n].sub(s).unit()
                  , c = a.sub(s).unit()
                  , u = c.angleWithSep(l.x, l.y)
                  , h = l.add(c).unit().mult(-1 * e / Math.sin(u / 2));
                i.push(s.add(h))
            }
            return i
        }
        ,
        t.cacheEntryPossiblyAdded = function(t) {
            nt++,
            nt > tt && (t.getActor().send("enforceCacheSizeLimit", Q),
            nt = 0)
        }
        ,
        t.calculateGlobeLabelMatrix = function(t, e) {
            const {x: i, y: r} = t.point
              , n = wp(i, r, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);
            return vl(n, n, bp(cp(e)))
        }
        ,
        t.calculateGlobeMatrix = function(t) {
            const {x: e, y: i} = t.point
              , {lng: r, lat: n} = t._center;
            return wp(e, i, t.worldSize, r, n)
        }
        ,
        t.calculateGlobeMercatorMatrix = function(t) {
            const e = t.pixelsPerMeter
              , i = e / Da(1, t.center.lat)
              , r = yl(new Float64Array(16));
            return bl(r, r, [t.point.x, t.point.y, 0]),
            wl(r, r, [i, i, e]),
            Float32Array.from(r)
        }
        ,
        t.circumferenceAtLatitude = Aa,
        t.clamp = T,
        t.clearTileCache = function(t) {
            if (!et())
                return;
            const i = e.caches.delete(W);
            t && i.catch(t).then((()=>t()))
        }
        ,
        t.clipLine = vd,
        t.clone = function(t) {
            var e = new fl(16);
            return e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            e[9] = t[9],
            e[10] = t[10],
            e[11] = t[11],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15],
            e
        }
        ,
        t.clone$1 = U,
        t.collisionCircleLayout = dh,
        t.config = n,
        t.conjugate = function(t, e) {
            return t[0] = -e[0],
            t[1] = -e[1],
            t[2] = -e[2],
            t[3] = e[3],
            t
        }
        ,
        t.create = function() {
            var t = new fl(16);
            return fl != Float32Array && (t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0),
            t[0] = 1,
            t[5] = 1,
            t[10] = 1,
            t[15] = 1,
            t
        }
        ,
        t.create$1 = _l,
        t.createExpression = Zr,
        t.createLayout = ns,
        t.createStyleLayer = function(t) {
            return "custom" === t.type ? new pm(t) : new _m[t.type](t)
        }
        ,
        t.cross = Gl,
        t.degToRad = y,
        t.distance = function(t, e) {
            return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2])
        }
        ,
        t.div = function(t, e, i) {
            return t[0] = e[0] / i[0],
            t[1] = e[1] / i[1],
            t[2] = e[2] / i[2],
            t
        }
        ,
        t.dot = Nl,
        t.earthRadius = Ea,
        t.ease = z,
        t.easeCubicInOut = b,
        t.ecefToLatLng = function([t,e,i]) {
            const r = Math.hypot(t, e, i)
              , n = Math.atan2(t, i)
              , o = .5 * Math.PI - Math.acos(-e / r);
            return new Sa(x(n),x(o))
        }
        ,
        t.emitValidationErrors = Fn,
        t.endsWith = R,
        t.enforceCacheSizeLimit = function(t) {
            it(),
            H && H.then((e=>{
                e.keys().then((i=>{
                    for (let r = 0; r < i.length - t; r++)
                        e.delete(i[r])
                }
                ))
            }
            ))
        }
        ,
        t.evaluateSizeForFeature = _h,
        t.evaluateSizeForZoom = gh,
        t.evaluateVariableOffset = Ud,
        t.evented = Bo,
        t.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
        }
        ,
        t.exactEquals$1 = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
        }
        ,
        t.exported = Zt,
        t.exported$1 = o,
        t.extend = I,
        t.extend$1 = Ht,
        t.fillExtrusionHeightLift = Ru,
        t.filterObject = F,
        t.fromMat4 = function(t, e) {
            return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[4],
            t[4] = e[5],
            t[5] = e[6],
            t[6] = e[8],
            t[7] = e[9],
            t[8] = e[10],
            t
        }
        ,
        t.fromQuat = function(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = e[3]
              , s = i + i
              , a = r + r
              , l = n + n
              , c = i * s
              , u = r * s
              , h = r * a
              , d = n * s
              , p = n * a
              , m = n * l
              , f = o * s
              , _ = o * a
              , g = o * l;
            return t[0] = 1 - h - m,
            t[1] = u + g,
            t[2] = d - _,
            t[3] = 0,
            t[4] = u - g,
            t[5] = 1 - c - m,
            t[6] = p + f,
            t[7] = 0,
            t[8] = d + _,
            t[9] = p - f,
            t[10] = 1 - c - h,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        ,
        t.fromRotation = function(t, e) {
            var i = Math.sin(e)
              , r = Math.cos(e);
            return t[0] = r,
            t[1] = i,
            t[2] = 0,
            t[3] = -i,
            t[4] = r,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 1,
            t
        }
        ,
        t.fromScaling = El,
        t.furthestTileCorner = function(t) {
            const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
            return v[e]
        }
        ,
        t.getAABBPointSquareDist = function(t, e, i) {
            let r = 0;
            for (let n = 0; n < 2; ++n) {
                const o = i ? i[n] : 0;
                t[n] > o && (r += (t[n] - o) * (t[n] - o)),
                e[n] < o && (r += (o - e[n]) * (o - e[n]))
            }
            return r
        }
        ,
        t.getAnchorAlignment = ld,
        t.getAnchorJustification = Gd,
        t.getBounds = function(t) {
            let e = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , n = -1 / 0;
            for (const o of t)
                e = Math.min(e, o.x),
                i = Math.min(i, o.y),
                r = Math.max(r, o.x),
                n = Math.max(n, o.y);
            return {
                min: new m(e,i),
                max: new m(r,n)
            }
        }
        ,
        t.getColumn = Y,
        t.getGridMatrix = function(t, e, i, r) {
            const n = e.getNorth()
              , o = e.getSouth()
              , s = e.getWest()
              , a = e.getEast()
              , l = 1 << t.z
              , c = a - s
              , u = n - o
              , h = c / ep
              , d = -u / ip[i]
              , p = [0, h, 0, d, 0, 0, n, s, 0];
            if (t.z > 0) {
                const t = 180 / r;
                gl(p, p, [t / c + 1, 0, 0, 0, t / u + 1, 0, -.5 * t / h, .5 * t / d, 1])
            }
            return p[2] = l,
            p[5] = t.x,
            p[8] = t.y,
            p
        }
        ,
        t.getImage = mt,
        t.getJSON = function(t, e) {
            return lt(I(t, {
                type: "json"
            }), e)
        }
        ,
        t.getLatitudinalLod = function(t) {
            const e = 80.051129;
            t = T(t, -80.051129, e) / e * 90;
            const i = Math.pow(Math.abs(Math.sin(y(t))), 3);
            return Math.round(i * (ip.length - 1))
        }
        ,
        t.getMapSessionAPI = Pt,
        t.getPerformanceMeasurement = Ut,
        t.getProjection = Hp,
        t.getRTLTextPluginStatus = Fo,
        t.getReferrer = at,
        t.getTilePoint = function(t, {x: e, y: i}, r=0) {
            return new m(((e - r) * t.scale - t.x) * za,(i * t.scale - t.y) * za)
        }
        ,
        t.getTileVec3 = function(t, e, i=0) {
            return Dl(((e.x - i) * t.scale - t.x) * za, (e.y * t.scale - t.y) * za, La(e.z, e.y))
        }
        ,
        t.getVideo = function(t, i) {
            const r = e.document.createElement("video");
            r.muted = !0,
            r.onloadstart = function() {
                i(null, r)
            }
            ;
            for (let i = 0; i < t.length; i++) {
                const n = e.document.createElement("source");
                ut(t[i]) || (r.crossOrigin = "Anonymous"),
                n.src = t[i],
                r.appendChild(n)
            }
            return {
                cancel: ()=>{}
            }
        }
        ,
        t.globeCenterToScreenPoint = function(t) {
            const e = [0, 0, 0]
              , i = yl(new Float64Array(16));
            return vl(i, t.pixelMatrix, t.globeMatrix),
            jl(e, e, i),
            new m(e[0],e[1])
        }
        ,
        t.globeDenormalizeECEF = bp,
        t.globeECEFOrigin = function(t, e) {
            const i = [0, 0, 0];
            return jl(i, i, vp(cp(e.canonical))),
            jl(i, i, t),
            i
        }
        ,
        t.globeNormalizeECEF = vp,
        t.globePixelsToTileUnits = function(t, e) {
            return za / (512 * Math.pow(2, t)) * yp(cp(e))
        }
        ,
        t.globePoleMatrixForTile = function(t, e, i) {
            const r = yl(new Float64Array(16))
              , n = (e / (1 << t) - .5) * Math.PI * 2;
            return Tl(r, i.globeMatrix, n),
            Float32Array.from(r)
        }
        ,
        t.globeTileBounds = cp,
        t.globeTiltAtLngLat = Tp,
        t.globeToMercatorTransition = zp,
        t.globeUseCustomAntiAliasing = function(t, e, i) {
            const r = zp(i.zoom)
              , n = t.style.map._antialias
              , o = !!e.extStandardDerivatives
              , s = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;
            return 0 === r && !n && !s && o
        }
        ,
        t.identity = yl,
        t.identity$1 = Kl,
        t.invert = xl,
        t.isFullscreen = function() {
            return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement
        }
        ,
        t.isLngLatBehindGlobe = Ep,
        t.isMapAuthenticated = function(t) {
            return Lt.has(t)
        }
        ,
        t.isMapboxURL = _t,
        t.isSafariWithAntialiasingBug = function(t) {
            const e = t.navigator ? t.navigator.userAgent : null;
            return !!q(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
        }
        ,
        t.latFromMercatorY = Pa,
        t.latLngToECEF = _p,
        t.len = ql,
        t.length = Cl,
        t.length$1 = function(t) {
            return Math.hypot(t[0], t[1], t[2], t[3])
        }
        ,
        t.lngFromMercatorX = ka,
        t.loadVectorTile = df,
        t.makeRequest = lt,
        t.mapValue = function(t, e, i, r, n) {
            return T((t - e) / (i - e) * (n - r) + r, r, n)
        }
        ,
        t.mercatorScale = Ra,
        t.mercatorXfromLng = Ia,
        t.mercatorYfromLat = Ca,
        t.mercatorZfromAltitude = Da,
        t.mul = Ml,
        t.mul$1 = Xl,
        t.multiply = vl,
        t.multiply$1 = gl,
        t.multiply$2 = Ll,
        t.nextPowerOfTwo = P,
        t.normalize = Ul,
        t.normalize$1 = ec,
        t.normalize$2 = Yl,
        t.number = Mi,
        t.ortho = function(t, e, i, r, n, o, s) {
            var a = 1 / (e - i)
              , l = 1 / (r - n)
              , c = 1 / (o - s);
            return t[0] = -2 * a,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = -2 * l,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 2 * c,
            t[11] = 0,
            t[12] = (e + i) * a,
            t[13] = (n + r) * l,
            t[14] = (s + o) * c,
            t[15] = 1,
            t
        }
        ,
        t.pbf = zh,
        t.perspective = function(t, e, i, r, n) {
            var o, s = 1 / Math.tan(e / 2);
            return t[0] = s / i,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = s,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[11] = -1,
            t[12] = 0,
            t[13] = 0,
            t[15] = 0,
            null != n && n !== 1 / 0 ? (t[10] = (n + r) * (o = 1 / (r - n)),
            t[14] = 2 * n * r * o) : (t[10] = -1,
            t[14] = -2 * r),
            t
        }
        ,
        t.pick = function(t, e) {
            const i = {};
            for (let r = 0; r < e.length; r++) {
                const n = e[r];
                n in t && (i[n] = t[n])
            }
            return i
        }
        ,
        t.plugin = No,
        t.pointGeometry = m,
        t.polesInViewport = function(t) {
            const e = yl(new Float64Array(16));
            vl(e, t.pixelMatrix, t.globeMatrix);
            const i = [0, rp, 0]
              , r = [0, np, 0];
            return jl(i, i, e),
            jl(r, r, e),
            [i[0] > 0 && i[0] <= t.width && i[1] > 0 && i[1] <= t.height && !Ep(t, new Sa(t.center.lat,90)), r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Ep(t, new Sa(t.center.lat,-90))]
        }
        ,
        t.polygonContainsPoint = ol,
        t.polygonIntersectsBox = sl,
        t.polygonIntersectsPolygon = Wa,
        t.polygonizeBounds = function(t, e, i=0, r=!0) {
            const n = new m(i,i)
              , o = t.sub(n)
              , s = e.add(n)
              , a = [o, new m(s.x,o.y), s, new m(o.x,s.y)];
            return r && a.push(o.clone()),
            a
        }
        ,
        t.posAttributes = Kd,
        t.postMapLoadEvent = It,
        t.postPerformanceEvent = Dt,
        t.postTurnstileEvent = Mt,
        t.potpack = $h,
        t.prevPowerOfTwo = function(t) {
            return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        ,
        t.radToDeg = x,
        t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],
        t.registerForPluginStateChange = function(t) {
            return t({
                pluginStatus: Po,
                pluginURL: Lo
            }),
            Bo.on("pluginStateChange", t),
            t
        }
        ,
        t.removeAuthState = function(t) {
            Lt.delete(t)
        }
        ,
        t.renderColorRamp = yc,
        t.resample = Ua,
        t.rotateX = zl,
        t.rotateX$1 = Ql,
        t.rotateY = Tl,
        t.rotateY$1 = tc,
        t.rotateZ = function(t, e, i) {
            var r = Math.sin(i)
              , n = Math.cos(i)
              , o = e[0]
              , s = e[1]
              , a = e[2]
              , l = e[3]
              , c = e[4]
              , u = e[5]
              , h = e[6]
              , d = e[7];
            return e !== t && (t[8] = e[8],
            t[9] = e[9],
            t[10] = e[10],
            t[11] = e[11],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[0] = o * n + c * r,
            t[1] = s * n + u * r,
            t[2] = a * n + h * r,
            t[3] = l * n + d * r,
            t[4] = c * n - o * r,
            t[5] = u * n - s * r,
            t[6] = h * n - a * r,
            t[7] = d * n - l * r,
            t
        }
        ,
        t.rotateZ$1 = function(t, e, i) {
            i *= .5;
            var r = e[0]
              , n = e[1]
              , o = e[2]
              , s = e[3]
              , a = Math.sin(i)
              , l = Math.cos(i);
            return t[0] = r * l + n * a,
            t[1] = n * l - r * a,
            t[2] = o * l + s * a,
            t[3] = s * l - o * a,
            t
        }
        ,
        t.scale = wl,
        t.scale$1 = $l,
        t.scale$2 = Bl,
        t.scaleAndAdd = Fl,
        t.set = function(t, e, i, r) {
            return t[0] = e,
            t[1] = i,
            t[2] = r,
            t
        }
        ,
        t.setCacheLimits = function(t, e) {
            Q = t,
            tt = e
        }
        ,
        t.setColumn = function(t, e, i) {
            t[4 * e + 0] = i[0],
            t[4 * e + 1] = i[1],
            t[4 * e + 2] = i[2],
            t[4 * e + 3] = i[3]
        }
        ,
        t.setRTLTextPlugin = function(t, e, i=!1) {
            if (Po === Io || Po === Co || Po === Do)
                throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Lo = Zt.resolveURL(t),
            Po = Io,
            ko = e,
            Ro(),
            i || Uo()
        }
        ,
        t.smoothstep = E,
        t.spec = Wt,
        t.squaredLength = function(t) {
            var e = t[0]
              , i = t[1]
              , r = t[2];
            return e * e + i * i + r * r
        }
        ,
        t.storeAuthState = function(t, e) {
            e ? Lt.add(t) : Lt.delete(t)
        }
        ,
        t.sub = Jl,
        t.subtract = Pl,
        t.symbolSize = yh,
        t.tileAABB = function(t, e, i, r, n, o, s, a, l) {
            if ("globe" === l.name)
                return function(t, e, i) {
                    const r = e / t.worldSize
                      , n = t.globeMatrix;
                    if (i.z <= 1) {
                        const t = cp(i).getCorners();
                        return dp(t, n, r),
                        oc.fromPoints(t)
                    }
                    const o = pp(i)
                      , s = mp(o);
                    dp(s, n, r);
                    const a = Number.MAX_VALUE
                      , l = [-a, -a, -a]
                      , c = [a, a, a];
                    if (o.contains(t.center)) {
                        for (const t of s)
                            Ol(c, c, t),
                            Rl(l, l, t);
                        l[2] = 0;
                        const e = t.point
                          , i = [e.x * r, e.y * r, 0];
                        return Ol(c, c, i),
                        Rl(l, l, i),
                        new oc(c,l)
                    }
                    const u = [n[12] * r, n[13] * r, n[14] * r]
                      , h = o.getCenter()
                      , d = T(t.center.lat, -85.051129, Oa)
                      , p = T(h.lat, -85.051129, Oa)
                      , m = Ia(t.center.lng)
                      , f = Ca(d);
                    let _ = m - Ia(h.lng);
                    const g = f - Ca(p);
                    _ > .5 ? _ -= 1 : _ < -.5 && (_ += 1);
                    let x = 0;
                    Math.abs(_) > Math.abs(g) ? x = _ >= 0 ? 1 : 3 : (x = g >= 0 ? 0 : 2,
                    Fl(u, u, [n[4] * r, n[5] * r, n[6] * r], -Math.sin(y(g >= 0 ? o.getSouth() : o.getNorth())) * Qd));
                    const v = s[x]
                      , b = s[(x + 1) % 4]
                      , w = new ap(v,b,u)
                      , z = [lp(w, 0) || v[0], lp(w, 1) || v[1], lp(w, 2) || v[2]]
                      , E = zp(t.zoom);
                    if (E > 0) {
                        const r = function({x: t, y: e, z: i}, r, n, o, s) {
                            const a = 1 / (1 << i);
                            let l = t * a
                              , c = l + a
                              , u = e * a
                              , h = u + a
                              , d = 0;
                            const p = (l + c) / 2 - o;
                            return p > .5 ? d = -1 : p < -.5 && (d = 1),
                            l = ((l + d) * r - (o *= r)) * n + o,
                            c = ((c + d) * r - o) * n + o,
                            u = (u * r - (s *= r)) * n + s,
                            h = (h * r - s) * n + s,
                            [[l, h, 0], [c, h, 0], [c, u, 0], [l, u, 0]]
                        }(i, e, t._pixelsPerMercatorPixel, m, f);
                        for (let t = 0; t < s.length; t++)
                            up(s[t], r[t], E);
                        const n = kl([], r[x], r[(x + 1) % 4]);
                        Bl(n, n, .5),
                        up(z, n, E)
                    }
                    for (const t of s)
                        Ol(c, c, t),
                        Rl(l, l, t);
                    return c[2] = Math.min(v[2], b[2]),
                    Ol(c, c, z),
                    Rl(l, l, z),
                    new oc(c,l)
                }(t, e, new Gu(i,r,n));
            const c = Cp({
                z: i,
                x: r,
                y: n
            }, l);
            return new oc([(o + c.x / c.scale) * e, e * (c.y / c.scale), s],[(o + c.x2 / c.scale) * e, e * (c.y2 / c.scale), a])
        }
        ,
        t.tileCornersToBounds = pp,
        t.tileTransform = Cp,
        t.transformMat3 = function(t, e, i) {
            var r = e[0]
              , n = e[1]
              , o = e[2];
            return t[0] = r * i[0] + n * i[3] + o * i[6],
            t[1] = r * i[1] + n * i[4] + o * i[7],
            t[2] = r * i[2] + n * i[5] + o * i[8],
            t
        }
        ,
        t.transformMat4 = jl,
        t.transformMat4$1 = Wl,
        t.transformQuat = Vl,
        t.transitionTileAABBinECEF = hp,
        t.translate = bl,
        t.transpose = function(t, e) {
            if (t === e) {
                var i = e[1]
                  , r = e[2]
                  , n = e[5];
                t[1] = e[3],
                t[2] = e[6],
                t[3] = i,
                t[5] = e[7],
                t[6] = r,
                t[7] = n
            } else
                t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8];
            return t
        }
        ,
        t.triggerPluginCompletionEvent = Oo,
        t.uniqueId = D,
        t.updateGlobeVertexNormal = function(t, e, i, r, n) {
            const o = 5 * e + 2;
            t.float32[o + 0] = i,
            t.float32[o + 1] = r,
            t.float32[o + 2] = n
        }
        ,
        t.validateCustomStyleLayer = function(t) {
            const e = []
              , i = t.id;
            return void 0 === i && e.push({
                message: `layers.${i}: missing required property "id"`
            }),
            void 0 === t.render && e.push({
                message: `layers.${i}: missing required method "render"`
            }),
            t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({
                message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`
            }),
            e
        }
        ,
        t.validateFilter = t=>Bn(yn(t)),
        t.validateFog = t=>Bn(Cn(t)),
        t.validateLayer = t=>Bn(zn(t)),
        t.validateLight = t=>Bn(An(t)),
        t.validateSource = t=>Bn(Sn(t)),
        t.validateStyle = Ln,
        t.validateTerrain = t=>Bn(In(t)),
        t.values = A,
        t.vectorTile = cu,
        t.version = i,
        t.warnOnce = G,
        t.window = e,
        t.wrap = S
    }
    )),
    r(0, (function(t) {
        function e(t) {
            if ("number" == typeof t || "boolean" == typeof t || "string" == typeof t || null == t)
                return JSON.stringify(t);
            if (Array.isArray(t)) {
                let i = "[";
                for (const r of t)
                    i += `${e(r)},`;
                return `${i}]`
            }
            let i = "{";
            for (const r of Object.keys(t).sort())
                i += `${r}:${e(t[r])},`;
            return `${i}}`
        }
        function i(i) {
            let r = "";
            for (const n of t.refProperties)
                r += `/${e(i[n])}`;
            return r
        }
        class r {
            constructor(t) {
                this.keyCache = {},
                t && this.replace(t)
            }
            replace(t) {
                this._layerConfigs = {},
                this._layers = {},
                this.update(t, [])
            }
            update(e, r) {
                for (const i of e)
                    this._layerConfigs[i.id] = i,
                    (this._layers[i.id] = t.createStyleLayer(i)).compileFilter(),
                    this.keyCache[i.id] && delete this.keyCache[i.id];
                for (const t of r)
                    delete this.keyCache[t],
                    delete this._layerConfigs[t],
                    delete this._layers[t];
                this.familiesBySource = {};
                const n = function(t, e) {
                    const r = {};
                    for (let n = 0; n < t.length; n++) {
                        const o = e && e[t[n].id] || i(t[n]);
                        e && (e[t[n].id] = o);
                        let s = r[o];
                        s || (s = r[o] = []),
                        s.push(t[n])
                    }
                    const n = [];
                    for (const t in r)
                        n.push(r[t]);
                    return n
                }(t.values(this._layerConfigs), this.keyCache);
                for (const t of n) {
                    const e = t.map((t=>this._layers[t.id]))
                      , i = e[0];
                    if ("none" === i.visibility)
                        continue;
                    const r = i.source || "";
                    let n = this.familiesBySource[r];
                    n || (n = this.familiesBySource[r] = {});
                    const o = i.sourceLayer || "_geojsonTileLayer";
                    let s = n[o];
                    s || (s = n[o] = []),
                    s.push(e)
                }
            }
        }
        class n {
            loadTile(e, i) {
                const {uid: r, encoding: n, rawImageData: o, padding: s, buildQuadTree: a} = e
                  , l = t.window.ImageBitmap && o instanceof t.window.ImageBitmap ? this.getImageData(o, s) : o;
                i(null, new t.DEMData(r,l,n,s < 1,a))
            }
            getImageData(t, e) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width,t.height),
                this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })),
                this.offscreenCanvas.width = t.width,
                this.offscreenCanvas.height = t.height,
                this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);
                const i = this.offscreenCanvasContext.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height),
                i
            }
        }
        var o = function t(e, i) {
            var r, n = e && e.type;
            if ("FeatureCollection" === n)
                for (r = 0; r < e.features.length; r++)
                    t(e.features[r], i);
            else if ("GeometryCollection" === n)
                for (r = 0; r < e.geometries.length; r++)
                    t(e.geometries[r], i);
            else if ("Feature" === n)
                t(e.geometry, i);
            else if ("Polygon" === n)
                s(e.coordinates, i);
            else if ("MultiPolygon" === n)
                for (r = 0; r < e.coordinates.length; r++)
                    s(e.coordinates[r], i);
            return e
        };
        function s(t, e) {
            if (0 !== t.length) {
                a(t[0], e);
                for (var i = 1; i < t.length; i++)
                    a(t[i], !e)
            }
        }
        function a(t, e) {
            for (var i = 0, r = 0, n = 0, o = t.length, s = o - 1; n < o; s = n++) {
                var a = (t[n][0] - t[s][0]) * (t[s][1] + t[n][1])
                  , l = i + a;
                r += Math.abs(i) >= Math.abs(a) ? i - l + a : a - l + i,
                i = l
            }
            i + r >= 0 != !!e && t.reverse()
        }
        const l = t.VectorTileFeature.prototype.toGeoJSON;
        class c {
            constructor(e) {
                this._feature = e,
                this.extent = t.EXTENT,
                this.type = e.type,
                this.properties = e.tags,
                "id"in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10))
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const e = [];
                    for (const i of this._feature.geometry)
                        e.push([new t.pointGeometry(i[0],i[1])]);
                    return e
                }
                {
                    const e = [];
                    for (const i of this._feature.geometry) {
                        const r = [];
                        for (const e of i)
                            r.push(new t.pointGeometry(e[0],e[1]));
                        e.push(r)
                    }
                    return e
                }
            }
            toGeoJSON(t, e, i) {
                return l.call(this, t, e, i)
            }
        }
        class u {
            constructor(e) {
                this.layers = {
                    _geojsonTileLayer: this
                },
                this.name = "_geojsonTileLayer",
                this.extent = t.EXTENT,
                this.length = e.length,
                this._features = e
            }
            feature(t) {
                return new c(this._features[t])
            }
        }
        var h = {
            exports: {}
        }
          , d = t.pointGeometry
          , p = t.vectorTile.VectorTileFeature
          , m = f;
        function f(t, e) {
            this.options = e || {},
            this.features = t,
            this.length = t.length
        }
        function _(t, e) {
            this.id = "number" == typeof t.id ? t.id : void 0,
            this.type = t.type,
            this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry,
            this.properties = t.tags,
            this.extent = e || 4096
        }
        f.prototype.feature = function(t) {
            return new _(this.features[t],this.options.extent)
        }
        ,
        _.prototype.loadGeometry = function() {
            var t = this.rawGeometry;
            this.geometry = [];
            for (var e = 0; e < t.length; e++) {
                for (var i = t[e], r = [], n = 0; n < i.length; n++)
                    r.push(new d(i[n][0],i[n][1]));
                this.geometry.push(r)
            }
            return this.geometry
        }
        ,
        _.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var t = this.geometry, e = 1 / 0, i = -1 / 0, r = 1 / 0, n = -1 / 0, o = 0; o < t.length; o++)
                for (var s = t[o], a = 0; a < s.length; a++) {
                    var l = s[a];
                    e = Math.min(e, l.x),
                    i = Math.max(i, l.x),
                    r = Math.min(r, l.y),
                    n = Math.max(n, l.y)
                }
            return [e, r, i, n]
        }
        ,
        _.prototype.toGeoJSON = p.prototype.toGeoJSON;
        var g = t.pbf
          , y = m;
        function x(t) {
            var e = new g;
            return function(t, e) {
                for (var i in t.layers)
                    e.writeMessage(3, v, t.layers[i])
            }(t, e),
            e.finish()
        }
        function v(t, e) {
            var i;
            e.writeVarintField(15, t.version || 1),
            e.writeStringField(1, t.name || ""),
            e.writeVarintField(5, t.extent || 4096);
            var r = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for (i = 0; i < t.length; i++)
                r.feature = t.feature(i),
                e.writeMessage(2, b, r);
            var n = r.keys;
            for (i = 0; i < n.length; i++)
                e.writeStringField(3, n[i]);
            var o = r.values;
            for (i = 0; i < o.length; i++)
                e.writeMessage(4, S, o[i])
        }
        function b(t, e) {
            var i = t.feature;
            void 0 !== i.id && e.writeVarintField(1, i.id),
            e.writeMessage(2, w, t),
            e.writeVarintField(3, i.type),
            e.writeMessage(4, E, i)
        }
        function w(t, e) {
            var i = t.feature
              , r = t.keys
              , n = t.values
              , o = t.keycache
              , s = t.valuecache;
            for (var a in i.properties) {
                var l = i.properties[a]
                  , c = o[a];
                if (null !== l) {
                    void 0 === c && (r.push(a),
                    o[a] = c = r.length - 1),
                    e.writeVarint(c);
                    var u = typeof l;
                    "string" !== u && "boolean" !== u && "number" !== u && (l = JSON.stringify(l));
                    var h = u + ":" + l
                      , d = s[h];
                    void 0 === d && (n.push(l),
                    s[h] = d = n.length - 1),
                    e.writeVarint(d)
                }
            }
        }
        function z(t, e) {
            return (e << 3) + (7 & t)
        }
        function T(t) {
            return t << 1 ^ t >> 31
        }
        function E(t, e) {
            for (var i = t.loadGeometry(), r = t.type, n = 0, o = 0, s = i.length, a = 0; a < s; a++) {
                var l = i[a]
                  , c = 1;
                1 === r && (c = l.length),
                e.writeVarint(z(1, c));
                for (var u = 3 === r ? l.length - 1 : l.length, h = 0; h < u; h++) {
                    1 === h && 1 !== r && e.writeVarint(z(2, u - 1));
                    var d = l[h].x - n
                      , p = l[h].y - o;
                    e.writeVarint(T(d)),
                    e.writeVarint(T(p)),
                    n += d,
                    o += p
                }
                3 === r && e.writeVarint(z(7, 1))
            }
        }
        function S(t, e) {
            var i = typeof t;
            "string" === i ? e.writeStringField(1, t) : "boolean" === i ? e.writeBooleanField(7, t) : "number" === i && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t))
        }
        function M(t, e, i, r, n, o) {
            if (n - r <= i)
                return;
            const s = r + n >> 1;
            A(t, e, s, r, n, o % 2),
            M(t, e, i, r, s - 1, o + 1),
            M(t, e, i, s + 1, n, o + 1)
        }
        function A(t, e, i, r, n, o) {
            for (; n > r; ) {
                if (n - r > 600) {
                    const s = n - r + 1
                      , a = i - r + 1
                      , l = Math.log(s)
                      , c = .5 * Math.exp(2 * l / 3)
                      , u = .5 * Math.sqrt(l * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);
                    A(t, e, i, Math.max(r, Math.floor(i - a * c / s + u)), Math.min(n, Math.floor(i + (s - a) * c / s + u)), o)
                }
                const s = e[2 * i + o];
                let a = r
                  , l = n;
                for (I(t, e, r, i),
                e[2 * n + o] > s && I(t, e, r, n); a < l; ) {
                    for (I(t, e, a, l),
                    a++,
                    l--; e[2 * a + o] < s; )
                        a++;
                    for (; e[2 * l + o] > s; )
                        l--
                }
                e[2 * r + o] === s ? I(t, e, r, l) : (l++,
                I(t, e, l, n)),
                l <= i && (r = l + 1),
                i <= l && (n = l - 1)
            }
        }
        function I(t, e, i, r) {
            C(t, i, r),
            C(e, 2 * i, 2 * r),
            C(e, 2 * i + 1, 2 * r + 1)
        }
        function C(t, e, i) {
            const r = t[e];
            t[e] = t[i],
            t[i] = r
        }
        function D(t, e, i, r) {
            const n = t - i
              , o = e - r;
            return n * n + o * o
        }
        h.exports = x,
        h.exports.fromVectorTileJs = x,
        h.exports.fromGeojsonVt = function(t, e) {
            e = e || {};
            var i = {};
            for (var r in t)
                i[r] = new y(t[r].features,e),
                i[r].name = r,
                i[r].version = e.version,
                i[r].extent = e.extent;
            return x({
                layers: i
            })
        }
        ,
        h.exports.GeoJSONWrapper = y;
        const k = t=>t[0]
          , P = t=>t[1];
        class L {
            constructor(t, e=k, i=P, r=64, n=Float64Array) {
                this.nodeSize = r,
                this.points = t;
                const o = t.length < 65536 ? Uint16Array : Uint32Array
                  , s = this.ids = new o(t.length)
                  , a = this.coords = new n(2 * t.length);
                for (let r = 0; r < t.length; r++)
                    s[r] = r,
                    a[2 * r] = e(t[r]),
                    a[2 * r + 1] = i(t[r]);
                M(s, a, r, 0, s.length - 1, 0)
            }
            range(t, e, i, r) {
                return function(t, e, i, r, n, o, s) {
                    const a = [0, t.length - 1, 0]
                      , l = [];
                    let c, u;
                    for (; a.length; ) {
                        const h = a.pop()
                          , d = a.pop()
                          , p = a.pop();
                        if (d - p <= s) {
                            for (let s = p; s <= d; s++)
                                c = e[2 * s],
                                u = e[2 * s + 1],
                                c >= i && c <= n && u >= r && u <= o && l.push(t[s]);
                            continue
                        }
                        const m = Math.floor((p + d) / 2);
                        c = e[2 * m],
                        u = e[2 * m + 1],
                        c >= i && c <= n && u >= r && u <= o && l.push(t[m]);
                        const f = (h + 1) % 2;
                        (0 === h ? i <= c : r <= u) && (a.push(p),
                        a.push(m - 1),
                        a.push(f)),
                        (0 === h ? n >= c : o >= u) && (a.push(m + 1),
                        a.push(d),
                        a.push(f))
                    }
                    return l
                }(this.ids, this.coords, t, e, i, r, this.nodeSize)
            }
            within(t, e, i) {
                return function(t, e, i, r, n, o) {
                    const s = [0, t.length - 1, 0]
                      , a = []
                      , l = n * n;
                    for (; s.length; ) {
                        const c = s.pop()
                          , u = s.pop()
                          , h = s.pop();
                        if (u - h <= o) {
                            for (let n = h; n <= u; n++)
                                D(e[2 * n], e[2 * n + 1], i, r) <= l && a.push(t[n]);
                            continue
                        }
                        const d = Math.floor((h + u) / 2)
                          , p = e[2 * d]
                          , m = e[2 * d + 1];
                        D(p, m, i, r) <= l && a.push(t[d]);
                        const f = (c + 1) % 2;
                        (0 === c ? i - n <= p : r - n <= m) && (s.push(h),
                        s.push(d - 1),
                        s.push(f)),
                        (0 === c ? i + n >= p : r + n >= m) && (s.push(d + 1),
                        s.push(u),
                        s.push(f))
                    }
                    return a
                }(this.ids, this.coords, t, e, i, this.nodeSize)
            }
        }
        const O = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: t=>t
        }
          , R = Math.fround || (B = new Float32Array(1),
        t=>(B[0] = +t,
        B[0]));
        var B;
        class F {
            constructor(t) {
                this.options = X(Object.create(O), t),
                this.trees = new Array(this.options.maxZoom + 1)
            }
            load(t) {
                const {log: e, minZoom: i, maxZoom: r, nodeSize: n} = this.options;
                e && console.time("total time");
                const o = `prepare ${t.length} points`;
                e && console.time(o),
                this.points = t;
                let s = [];
                for (let e = 0; e < t.length; e++)
                    t[e].geometry && s.push(N(t[e], e));
                this.trees[r + 1] = new L(s,q,$,n,Float32Array),
                e && console.timeEnd(o);
                for (let t = r; t >= i; t--) {
                    const i = +Date.now();
                    s = this._cluster(s, t),
                    this.trees[t] = new L(s,q,$,n,Float32Array),
                    e && console.log("z%d: %d clusters in %dms", t, s.length, +Date.now() - i)
                }
                return e && console.timeEnd("total time"),
                this
            }
            getClusters(t, e) {
                let i = ((t[0] + 180) % 360 + 360) % 360 - 180;
                const r = Math.max(-90, Math.min(90, t[1]));
                let n = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
                const o = Math.max(-90, Math.min(90, t[3]));
                if (t[2] - t[0] >= 360)
                    i = -180,
                    n = 180;
                else if (i > n) {
                    const t = this.getClusters([i, r, 180, o], e)
                      , s = this.getClusters([-180, r, n, o], e);
                    return t.concat(s)
                }
                const s = this.trees[this._limitZoom(e)]
                  , a = s.range(V(i), Z(o), V(n), Z(r))
                  , l = [];
                for (const t of a) {
                    const e = s.points[t];
                    l.push(e.numPoints ? G(e) : this.points[e.index])
                }
                return l
            }
            getChildren(t) {
                const e = this._getOriginId(t)
                  , i = this._getOriginZoom(t)
                  , r = "No cluster with the specified id."
                  , n = this.trees[i];
                if (!n)
                    throw new Error(r);
                const o = n.points[e];
                if (!o)
                    throw new Error(r);
                const s = this.options.radius / (this.options.extent * Math.pow(2, i - 1))
                  , a = n.within(o.x, o.y, s)
                  , l = [];
                for (const e of a) {
                    const i = n.points[e];
                    i.parentId === t && l.push(i.numPoints ? G(i) : this.points[i.index])
                }
                if (0 === l.length)
                    throw new Error(r);
                return l
            }
            getLeaves(t, e, i) {
                const r = [];
                return this._appendLeaves(r, t, e = e || 10, i = i || 0, 0),
                r
            }
            getTile(t, e, i) {
                const r = this.trees[this._limitZoom(t)]
                  , n = Math.pow(2, t)
                  , {extent: o, radius: s} = this.options
                  , a = s / o
                  , l = (i - a) / n
                  , c = (i + 1 + a) / n
                  , u = {
                    features: []
                };
                return this._addTileFeatures(r.range((e - a) / n, l, (e + 1 + a) / n, c), r.points, e, i, n, u),
                0 === e && this._addTileFeatures(r.range(1 - a / n, l, 1, c), r.points, n, i, n, u),
                e === n - 1 && this._addTileFeatures(r.range(0, l, a / n, c), r.points, -1, i, n, u),
                u.features.length ? u : null
            }
            getClusterExpansionZoom(t) {
                let e = this._getOriginZoom(t) - 1;
                for (; e <= this.options.maxZoom; ) {
                    const i = this.getChildren(t);
                    if (e++,
                    1 !== i.length)
                        break;
                    t = i[0].properties.cluster_id
                }
                return e
            }
            _appendLeaves(t, e, i, r, n) {
                const o = this.getChildren(e);
                for (const e of o) {
                    const o = e.properties;
                    if (o && o.cluster ? n + o.point_count <= r ? n += o.point_count : n = this._appendLeaves(t, o.cluster_id, i, r, n) : n < r ? n++ : t.push(e),
                    t.length === i)
                        break
                }
                return n
            }
            _addTileFeatures(t, e, i, r, n, o) {
                for (const s of t) {
                    const t = e[s]
                      , a = t.numPoints;
                    let l, c, u;
                    if (a)
                        l = j(t),
                        c = t.x,
                        u = t.y;
                    else {
                        const e = this.points[t.index];
                        l = e.properties,
                        c = V(e.geometry.coordinates[0]),
                        u = Z(e.geometry.coordinates[1])
                    }
                    const h = {
                        type: 1,
                        geometry: [[Math.round(this.options.extent * (c * n - i)), Math.round(this.options.extent * (u * n - r))]],
                        tags: l
                    };
                    let d;
                    a ? d = t.id : this.options.generateId ? d = t.index : this.points[t.index].id && (d = this.points[t.index].id),
                    void 0 !== d && (h.id = d),
                    o.features.push(h)
                }
            }
            _limitZoom(t) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1))
            }
            _cluster(t, e) {
                const i = []
                  , {radius: r, extent: n, reduce: o, minPoints: s} = this.options
                  , a = r / (n * Math.pow(2, e));
                for (let r = 0; r < t.length; r++) {
                    const n = t[r];
                    if (n.zoom <= e)
                        continue;
                    n.zoom = e;
                    const l = this.trees[e + 1]
                      , c = l.within(n.x, n.y, a)
                      , u = n.numPoints || 1;
                    let h = u;
                    for (const t of c) {
                        const i = l.points[t];
                        i.zoom > e && (h += i.numPoints || 1)
                    }
                    if (h > u && h >= s) {
                        let t = n.x * u
                          , s = n.y * u
                          , a = o && u > 1 ? this._map(n, !0) : null;
                        const d = (r << 5) + (e + 1) + this.points.length;
                        for (const i of c) {
                            const r = l.points[i];
                            if (r.zoom <= e)
                                continue;
                            r.zoom = e;
                            const c = r.numPoints || 1;
                            t += r.x * c,
                            s += r.y * c,
                            r.parentId = d,
                            o && (a || (a = this._map(n, !0)),
                            o(a, this._map(r)))
                        }
                        n.parentId = d,
                        i.push(U(t / h, s / h, d, h, a))
                    } else if (i.push(n),
                    h > 1)
                        for (const t of c) {
                            const r = l.points[t];
                            r.zoom <= e || (r.zoom = e,
                            i.push(r))
                        }
                }
                return i
            }
            _getOriginId(t) {
                return t - this.points.length >> 5
            }
            _getOriginZoom(t) {
                return (t - this.points.length) % 32
            }
            _map(t, e) {
                if (t.numPoints)
                    return e ? X({}, t.properties) : t.properties;
                const i = this.points[t.index].properties
                  , r = this.options.map(i);
                return e && r === i ? X({}, r) : r
            }
        }
        function U(t, e, i, r, n) {
            return {
                x: R(t),
                y: R(e),
                zoom: 1 / 0,
                id: i,
                parentId: -1,
                numPoints: r,
                properties: n
            }
        }
        function N(t, e) {
            const [i,r] = t.geometry.coordinates;
            return {
                x: R(V(i)),
                y: R(Z(r)),
                zoom: 1 / 0,
                index: e,
                parentId: -1
            }
        }
        function G(t) {
            var e;
            return {
                type: "Feature",
                id: t.id,
                properties: j(t),
                geometry: {
                    type: "Point",
                    coordinates: [(e = t.x,
                    360 * (e - .5)), J(t.y)]
                }
            }
        }
        function j(t) {
            const e = t.numPoints
              , i = e >= 1e4 ? `${Math.round(e / 1e3)}k` : e >= 1e3 ? Math.round(e / 100) / 10 + "k" : e;
            return X(X({}, t.properties), {
                cluster: !0,
                cluster_id: t.id,
                point_count: e,
                point_count_abbreviated: i
            })
        }
        function V(t) {
            return t / 360 + .5
        }
        function Z(t) {
            const e = Math.sin(t * Math.PI / 180)
              , i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
            return i < 0 ? 0 : i > 1 ? 1 : i
        }
        function J(t) {
            const e = (180 - 360 * t) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(e)) / Math.PI - 90
        }
        function X(t, e) {
            for (const i in e)
                t[i] = e[i];
            return t
        }
        function q(t) {
            return t.x
        }
        function $(t) {
            return t.y
        }
        function Y(t, e, i, r) {
            for (var n, o = r, s = i - e >> 1, a = i - e, l = t[e], c = t[e + 1], u = t[i], h = t[i + 1], d = e + 3; d < i; d += 3) {
                var p = W(t[d], t[d + 1], l, c, u, h);
                if (p > o)
                    n = d,
                    o = p;
                else if (p === o) {
                    var m = Math.abs(d - s);
                    m < a && (n = d,
                    a = m)
                }
            }
            o > r && (n - e > 3 && Y(t, e, n, r),
            t[n + 2] = o,
            i - n > 3 && Y(t, n, i, r))
        }
        function W(t, e, i, r, n, o) {
            var s = n - i
              , a = o - r;
            if (0 !== s || 0 !== a) {
                var l = ((t - i) * s + (e - r) * a) / (s * s + a * a);
                l > 1 ? (i = n,
                r = o) : l > 0 && (i += s * l,
                r += a * l)
            }
            return (s = t - i) * s + (a = e - r) * a
        }
        function H(t, e, i, r) {
            var n = {
                id: void 0 === t ? null : t,
                type: e,
                geometry: i,
                tags: r,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return function(t) {
                var e = t.geometry
                  , i = t.type;
                if ("Point" === i || "MultiPoint" === i || "LineString" === i)
                    K(t, e);
                else if ("Polygon" === i || "MultiLineString" === i)
                    for (var r = 0; r < e.length; r++)
                        K(t, e[r]);
                else if ("MultiPolygon" === i)
                    for (r = 0; r < e.length; r++)
                        for (var n = 0; n < e[r].length; n++)
                            K(t, e[r][n])
            }(n),
            n
        }
        function K(t, e) {
            for (var i = 0; i < e.length; i += 3)
                t.minX = Math.min(t.minX, e[i]),
                t.minY = Math.min(t.minY, e[i + 1]),
                t.maxX = Math.max(t.maxX, e[i]),
                t.maxY = Math.max(t.maxY, e[i + 1])
        }
        function Q(t, e, i, r) {
            if (e.geometry) {
                var n = e.geometry.coordinates
                  , o = e.geometry.type
                  , s = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2)
                  , a = []
                  , l = e.id;
                if (i.promoteId ? l = e.properties[i.promoteId] : i.generateId && (l = r || 0),
                "Point" === o)
                    tt(n, a);
                else if ("MultiPoint" === o)
                    for (var c = 0; c < n.length; c++)
                        tt(n[c], a);
                else if ("LineString" === o)
                    et(n, a, s, !1);
                else if ("MultiLineString" === o) {
                    if (i.lineMetrics) {
                        for (c = 0; c < n.length; c++)
                            et(n[c], a = [], s, !1),
                            t.push(H(l, "LineString", a, e.properties));
                        return
                    }
                    it(n, a, s, !1)
                } else if ("Polygon" === o)
                    it(n, a, s, !0);
                else {
                    if ("MultiPolygon" !== o) {
                        if ("GeometryCollection" === o) {
                            for (c = 0; c < e.geometry.geometries.length; c++)
                                Q(t, {
                                    id: l,
                                    geometry: e.geometry.geometries[c],
                                    properties: e.properties
                                }, i, r);
                            return
                        }
                        throw new Error("Input data is not a valid GeoJSON object.")
                    }
                    for (c = 0; c < n.length; c++) {
                        var u = [];
                        it(n[c], u, s, !0),
                        a.push(u)
                    }
                }
                t.push(H(l, o, a, e.properties))
            }
        }
        function tt(t, e) {
            e.push(rt(t[0])),
            e.push(nt(t[1])),
            e.push(0)
        }
        function et(t, e, i, r) {
            for (var n, o, s = 0, a = 0; a < t.length; a++) {
                var l = rt(t[a][0])
                  , c = nt(t[a][1]);
                e.push(l),
                e.push(c),
                e.push(0),
                a > 0 && (s += r ? (n * c - l * o) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(c - o, 2))),
                n = l,
                o = c
            }
            var u = e.length - 3;
            e[2] = 1,
            Y(e, 0, u, i),
            e[u + 2] = 1,
            e.size = Math.abs(s),
            e.start = 0,
            e.end = e.size
        }
        function it(t, e, i, r) {
            for (var n = 0; n < t.length; n++) {
                var o = [];
                et(t[n], o, i, r),
                e.push(o)
            }
        }
        function rt(t) {
            return t / 360 + .5
        }
        function nt(t) {
            var e = Math.sin(t * Math.PI / 180)
              , i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
            return i < 0 ? 0 : i > 1 ? 1 : i
        }
        function ot(t, e, i, r, n, o, s, a) {
            if (r /= e,
            o >= (i /= e) && s < r)
                return t;
            if (s < i || o >= r)
                return null;
            for (var l = [], c = 0; c < t.length; c++) {
                var u = t[c]
                  , h = u.geometry
                  , d = u.type
                  , p = 0 === n ? u.minX : u.minY
                  , m = 0 === n ? u.maxX : u.maxY;
                if (p >= i && m < r)
                    l.push(u);
                else if (!(m < i || p >= r)) {
                    var f = [];
                    if ("Point" === d || "MultiPoint" === d)
                        st(h, f, i, r, n);
                    else if ("LineString" === d)
                        at(h, f, i, r, n, !1, a.lineMetrics);
                    else if ("MultiLineString" === d)
                        ct(h, f, i, r, n, !1);
                    else if ("Polygon" === d)
                        ct(h, f, i, r, n, !0);
                    else if ("MultiPolygon" === d)
                        for (var _ = 0; _ < h.length; _++) {
                            var g = [];
                            ct(h[_], g, i, r, n, !0),
                            g.length && f.push(g)
                        }
                    if (f.length) {
                        if (a.lineMetrics && "LineString" === d) {
                            for (_ = 0; _ < f.length; _++)
                                l.push(H(u.id, d, f[_], u.tags));
                            continue
                        }
                        "LineString" !== d && "MultiLineString" !== d || (1 === f.length ? (d = "LineString",
                        f = f[0]) : d = "MultiLineString"),
                        "Point" !== d && "MultiPoint" !== d || (d = 3 === f.length ? "Point" : "MultiPoint"),
                        l.push(H(u.id, d, f, u.tags))
                    }
                }
            }
            return l.length ? l : null
        }
        function st(t, e, i, r, n) {
            for (var o = 0; o < t.length; o += 3) {
                var s = t[o + n];
                s >= i && s <= r && (e.push(t[o]),
                e.push(t[o + 1]),
                e.push(t[o + 2]))
            }
        }
        function at(t, e, i, r, n, o, s) {
            for (var a, l, c = lt(t), u = 0 === n ? ht : dt, h = t.start, d = 0; d < t.length - 3; d += 3) {
                var p = t[d]
                  , m = t[d + 1]
                  , f = t[d + 2]
                  , _ = t[d + 3]
                  , g = t[d + 4]
                  , y = 0 === n ? p : m
                  , x = 0 === n ? _ : g
                  , v = !1;
                s && (a = Math.sqrt(Math.pow(p - _, 2) + Math.pow(m - g, 2))),
                y < i ? x > i && (l = u(c, p, m, _, g, i),
                s && (c.start = h + a * l)) : y > r ? x < r && (l = u(c, p, m, _, g, r),
                s && (c.start = h + a * l)) : ut(c, p, m, f),
                x < i && y >= i && (l = u(c, p, m, _, g, i),
                v = !0),
                x > r && y <= r && (l = u(c, p, m, _, g, r),
                v = !0),
                !o && v && (s && (c.end = h + a * l),
                e.push(c),
                c = lt(t)),
                s && (h += a)
            }
            var b = t.length - 3;
            p = t[b],
            m = t[b + 1],
            f = t[b + 2],
            (y = 0 === n ? p : m) >= i && y <= r && ut(c, p, m, f),
            b = c.length - 3,
            o && b >= 3 && (c[b] !== c[0] || c[b + 1] !== c[1]) && ut(c, c[0], c[1], c[2]),
            c.length && e.push(c)
        }
        function lt(t) {
            var e = [];
            return e.size = t.size,
            e.start = t.start,
            e.end = t.end,
            e
        }
        function ct(t, e, i, r, n, o) {
            for (var s = 0; s < t.length; s++)
                at(t[s], e, i, r, n, o, !1)
        }
        function ut(t, e, i, r) {
            t.push(e),
            t.push(i),
            t.push(r)
        }
        function ht(t, e, i, r, n, o) {
            var s = (o - e) / (r - e);
            return t.push(o),
            t.push(i + (n - i) * s),
            t.push(1),
            s
        }
        function dt(t, e, i, r, n, o) {
            var s = (o - i) / (n - i);
            return t.push(e + (r - e) * s),
            t.push(o),
            t.push(1),
            s
        }
        function pt(t, e) {
            for (var i = [], r = 0; r < t.length; r++) {
                var n, o = t[r], s = o.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s)
                    n = mt(o.geometry, e);
                else if ("MultiLineString" === s || "Polygon" === s) {
                    n = [];
                    for (var a = 0; a < o.geometry.length; a++)
                        n.push(mt(o.geometry[a], e))
                } else if ("MultiPolygon" === s)
                    for (n = [],
                    a = 0; a < o.geometry.length; a++) {
                        for (var l = [], c = 0; c < o.geometry[a].length; c++)
                            l.push(mt(o.geometry[a][c], e));
                        n.push(l)
                    }
                i.push(H(o.id, s, n, o.tags))
            }
            return i
        }
        function mt(t, e) {
            var i = [];
            i.size = t.size,
            void 0 !== t.start && (i.start = t.start,
            i.end = t.end);
            for (var r = 0; r < t.length; r += 3)
                i.push(t[r] + e, t[r + 1], t[r + 2]);
            return i
        }
        function ft(t, e) {
            if (t.transformed)
                return t;
            var i, r, n, o = 1 << t.z, s = t.x, a = t.y;
            for (i = 0; i < t.features.length; i++) {
                var l = t.features[i]
                  , c = l.geometry
                  , u = l.type;
                if (l.geometry = [],
                1 === u)
                    for (r = 0; r < c.length; r += 2)
                        l.geometry.push(_t(c[r], c[r + 1], e, o, s, a));
                else
                    for (r = 0; r < c.length; r++) {
                        var h = [];
                        for (n = 0; n < c[r].length; n += 2)
                            h.push(_t(c[r][n], c[r][n + 1], e, o, s, a));
                        l.geometry.push(h)
                    }
            }
            return t.transformed = !0,
            t
        }
        function _t(t, e, i, r, n, o) {
            return [Math.round(i * (t * r - n)), Math.round(i * (e * r - o))]
        }
        function gt(t, e, i, r, n) {
            for (var o = e === n.maxZoom ? 0 : n.tolerance / ((1 << e) * n.extent), s = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: i,
                y: r,
                z: e,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a = 0; a < t.length; a++) {
                s.numFeatures++,
                yt(s, t[a], o, n);
                var l = t[a].minX
                  , c = t[a].minY
                  , u = t[a].maxX
                  , h = t[a].maxY;
                l < s.minX && (s.minX = l),
                c < s.minY && (s.minY = c),
                u > s.maxX && (s.maxX = u),
                h > s.maxY && (s.maxY = h)
            }
            return s
        }
        function yt(t, e, i, r) {
            var n = e.geometry
              , o = e.type
              , s = [];
            if ("Point" === o || "MultiPoint" === o)
                for (var a = 0; a < n.length; a += 3)
                    s.push(n[a]),
                    s.push(n[a + 1]),
                    t.numPoints++,
                    t.numSimplified++;
            else if ("LineString" === o)
                xt(s, n, t, i, !1, !1);
            else if ("MultiLineString" === o || "Polygon" === o)
                for (a = 0; a < n.length; a++)
                    xt(s, n[a], t, i, "Polygon" === o, 0 === a);
            else if ("MultiPolygon" === o)
                for (var l = 0; l < n.length; l++) {
                    var c = n[l];
                    for (a = 0; a < c.length; a++)
                        xt(s, c[a], t, i, !0, 0 === a)
                }
            if (s.length) {
                var u = e.tags || null;
                if ("LineString" === o && r.lineMetrics) {
                    for (var h in u = {},
                    e.tags)
                        u[h] = e.tags[h];
                    u.mapbox_clip_start = n.start / n.size,
                    u.mapbox_clip_end = n.end / n.size
                }
                var d = {
                    geometry: s,
                    type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1,
                    tags: u
                };
                null !== e.id && (d.id = e.id),
                t.features.push(d)
            }
        }
        function xt(t, e, i, r, n, o) {
            var s = r * r;
            if (r > 0 && e.size < (n ? s : r))
                i.numPoints += e.length / 3;
            else {
                for (var a = [], l = 0; l < e.length; l += 3)
                    (0 === r || e[l + 2] > s) && (i.numSimplified++,
                    a.push(e[l]),
                    a.push(e[l + 1])),
                    i.numPoints++;
                n && function(t, e) {
                    for (var i = 0, r = 0, n = t.length, o = n - 2; r < n; o = r,
                    r += 2)
                        i += (t[r] - t[o]) * (t[r + 1] + t[o + 1]);
                    if (i > 0 === e)
                        for (r = 0,
                        n = t.length; r < n / 2; r += 2) {
                            var s = t[r]
                              , a = t[r + 1];
                            t[r] = t[n - 2 - r],
                            t[r + 1] = t[n - 1 - r],
                            t[n - 2 - r] = s,
                            t[n - 1 - r] = a
                        }
                }(a, o),
                t.push(a)
            }
        }
        function vt(t, e) {
            var i = (e = this.options = function(t, e) {
                for (var i in e)
                    t[i] = e[i];
                return t
            }(Object.create(this.options), e)).debug;
            if (i && console.time("preprocess data"),
            e.maxZoom < 0 || e.maxZoom > 24)
                throw new Error("maxZoom should be in the 0-24 range");
            if (e.promoteId && e.generateId)
                throw new Error("promoteId and generateId cannot be used together.");
            var r, n, o, s, a, l, c = function(t, e) {
                var i = [];
                if ("FeatureCollection" === t.type)
                    for (var r = 0; r < t.features.length; r++)
                        Q(i, t.features[r], e, r);
                else
                    Q(i, "Feature" === t.type ? t : {
                        geometry: t
                    }, e);
                return i
            }(t, e);
            this.tiles = {},
            this.tileCoords = [],
            i && (console.timeEnd("preprocess data"),
            console.log("index: maxZoom: %d, maxPoints: %d", e.indexMaxZoom, e.indexMaxPoints),
            console.time("generate tiles"),
            this.stats = {},
            this.total = 0),
            r = c,
            o = (n = e).buffer / n.extent,
            s = r,
            a = ot(r, 1, -1 - o, o, 0, -1, 2, n),
            l = ot(r, 1, 1 - o, 2 + o, 0, -1, 2, n),
            (a || l) && (s = ot(r, 1, -o, 1 + o, 0, -1, 2, n) || [],
            a && (s = pt(a, 1).concat(s)),
            l && (s = s.concat(pt(l, -1)))),
            (c = s).length && this.splitTile(c, 0, 0, 0),
            i && (c.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
            console.timeEnd("generate tiles"),
            console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
        }
        function bt(t, e, i) {
            return 32 * ((1 << t) * i + e) + t
        }
        function wt(t, e) {
            const i = t.tileID.canonical;
            if (!this._geoJSONIndex)
                return e(null, null);
            const r = this._geoJSONIndex.getTile(i.z, i.x, i.y);
            if (!r)
                return e(null, null);
            const n = new u(r.features);
            let o = h.exports(n);
            0 === o.byteOffset && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)),
            e(null, {
                vectorTile: n,
                rawData: o.buffer
            })
        }
        vt.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        },
        vt.prototype.splitTile = function(t, e, i, r, n, o, s) {
            for (var a = [t, e, i, r], l = this.options, c = l.debug; a.length; ) {
                r = a.pop(),
                i = a.pop(),
                e = a.pop(),
                t = a.pop();
                var u = 1 << e
                  , h = bt(e, i, r)
                  , d = this.tiles[h];
                if (!d && (c > 1 && console.time("creation"),
                d = this.tiles[h] = gt(t, e, i, r, l),
                this.tileCoords.push({
                    z: e,
                    x: i,
                    y: r
                }),
                c)) {
                    c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", e, i, r, d.numFeatures, d.numPoints, d.numSimplified),
                    console.timeEnd("creation"));
                    var p = "z" + e;
                    this.stats[p] = (this.stats[p] || 0) + 1,
                    this.total++
                }
                if (d.source = t,
                n) {
                    if (e === l.maxZoom || e === n)
                        continue;
                    var m = 1 << n - e;
                    if (i !== Math.floor(o / m) || r !== Math.floor(s / m))
                        continue
                } else if (e === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints)
                    continue;
                if (d.source = null,
                0 !== t.length) {
                    c > 1 && console.time("clipping");
                    var f, _, g, y, x, v, b = .5 * l.buffer / l.extent, w = .5 - b, z = .5 + b, T = 1 + b;
                    f = _ = g = y = null,
                    x = ot(t, u, i - b, i + z, 0, d.minX, d.maxX, l),
                    v = ot(t, u, i + w, i + T, 0, d.minX, d.maxX, l),
                    t = null,
                    x && (f = ot(x, u, r - b, r + z, 1, d.minY, d.maxY, l),
                    _ = ot(x, u, r + w, r + T, 1, d.minY, d.maxY, l),
                    x = null),
                    v && (g = ot(v, u, r - b, r + z, 1, d.minY, d.maxY, l),
                    y = ot(v, u, r + w, r + T, 1, d.minY, d.maxY, l),
                    v = null),
                    c > 1 && console.timeEnd("clipping"),
                    a.push(f || [], e + 1, 2 * i, 2 * r),
                    a.push(_ || [], e + 1, 2 * i, 2 * r + 1),
                    a.push(g || [], e + 1, 2 * i + 1, 2 * r),
                    a.push(y || [], e + 1, 2 * i + 1, 2 * r + 1)
                }
            }
        }
        ,
        vt.prototype.getTile = function(t, e, i) {
            var r = this.options
              , n = r.extent
              , o = r.debug;
            if (t < 0 || t > 24)
                return null;
            var s = 1 << t
              , a = bt(t, e = (e % s + s) % s, i);
            if (this.tiles[a])
                return ft(this.tiles[a], n);
            o > 1 && console.log("drilling down to z%d-%d-%d", t, e, i);
            for (var l, c = t, u = e, h = i; !l && c > 0; )
                c--,
                u = Math.floor(u / 2),
                h = Math.floor(h / 2),
                l = this.tiles[bt(c, u, h)];
            return l && l.source ? (o > 1 && console.log("found parent tile z%d-%d-%d", c, u, h),
            o > 1 && console.time("drilling down"),
            this.splitTile(l.source, c, u, h, t, e, i),
            o > 1 && console.timeEnd("drilling down"),
            this.tiles[a] ? ft(this.tiles[a], n) : null) : null
        }
        ;
        class zt extends t.VectorTileWorkerSource {
            constructor(t, e, i, r, n) {
                super(t, e, i, r, wt),
                n && (this.loadGeoJSON = n)
            }
            loadData(e, i) {
                const r = e && e.request
                  , n = r && r.collectResourceTiming;
                this.loadGeoJSON(e, ((s,a)=>{
                    if (s || !a)
                        return i(s);
                    if ("object" != typeof a)
                        return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));
                    {
                        o(a, !0);
                        try {
                            if (e.filter) {
                                const i = t.createExpression(e.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === i.result)
                                    throw new Error(i.value.map((t=>`${t.key}: ${t.message}`)).join(", "));
                                const r = a.features.filter((t=>i.value.evaluate({
                                    zoom: 0
                                }, t)));
                                a = {
                                    type: "FeatureCollection",
                                    features: r
                                }
                            }
                            this._geoJSONIndex = e.cluster ? new F(function({superclusterOptions: e, clusterProperties: i}) {
                                if (!i || !e)
                                    return e;
                                const r = {}
                                  , n = {}
                                  , o = {
                                    accumulated: null,
                                    zoom: 0
                                }
                                  , s = {
                                    properties: null
                                }
                                  , a = Object.keys(i);
                                for (const e of a) {
                                    const [o,s] = i[e]
                                      , a = t.createExpression(s)
                                      , l = t.createExpression("string" == typeof o ? [o, ["accumulated"], ["get", e]] : o);
                                    r[e] = a.value,
                                    n[e] = l.value
                                }
                                return e.map = t=>{
                                    s.properties = t;
                                    const e = {};
                                    for (const t of a)
                                        e[t] = r[t].evaluate(o, s);
                                    return e
                                }
                                ,
                                e.reduce = (t,e)=>{
                                    s.properties = e;
                                    for (const e of a)
                                        o.accumulated = t[e],
                                        t[e] = n[e].evaluate(o, s)
                                }
                                ,
                                e
                            }(e)).load(a.features) : (l = a,
                            c = e.geojsonVtOptions,
                            new vt(l,c))
                        } catch (t) {
                            return i(t)
                        }
                        this.loaded = {};
                        const s = {};
                        if (n) {
                            const i = t.getPerformanceMeasurement(r);
                            i && (s.resourceTiming = {},
                            s.resourceTiming[e.source] = JSON.parse(JSON.stringify(i)))
                        }
                        i(null, s)
                    }
                    var l, c
                }
                ))
            }
            reloadTile(t, e) {
                const i = this.loaded;
                return i && i[t.uid] ? super.reloadTile(t, e) : this.loadTile(t, e)
            }
            loadGeoJSON(e, i) {
                if (e.request)
                    t.getJSON(e.request, i);
                else {
                    if ("string" != typeof e.data)
                        return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));
                    try {
                        return i(null, JSON.parse(e.data))
                    } catch (t) {
                        return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`))
                    }
                }
            }
            getClusterExpansionZoom(t, e) {
                try {
                    e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId))
                } catch (t) {
                    e(t)
                }
            }
            getClusterChildren(t, e) {
                try {
                    e(null, this._geoJSONIndex.getChildren(t.clusterId))
                } catch (t) {
                    e(t)
                }
            }
            getClusterLeaves(t, e) {
                try {
                    e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset))
                } catch (t) {
                    e(t)
                }
            }
        }
        class Tt {
            constructor(e) {
                this.self = e,
                this.actor = new t.Actor(e,this),
                this.layerIndexes = {},
                this.availableImages = {},
                this.isSpriteLoaded = {},
                this.projections = {},
                this.defaultProjection = t.getProjection({
                    name: "mercator"
                }),
                this.workerSourceTypes = {
                    vector: t.VectorTileWorkerSource,
                    geojson: zt
                },
                this.workerSources = {},
                this.demWorkerSources = {},
                this.self.registerWorkerSource = (t,e)=>{
                    if (this.workerSourceTypes[t])
                        throw new Error(`Worker source with name "${t}" already registered.`);
                    this.workerSourceTypes[t] = e
                }
                ,
                this.self.registerRTLTextPlugin = e=>{
                    if (t.plugin.isParsed())
                        throw new Error("RTL text plugin already registered.");
                    t.plugin.applyArabicShaping = e.applyArabicShaping,
                    t.plugin.processBidirectionalText = e.processBidirectionalText,
                    t.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText
                }
            }
            clearCaches(t, e, i) {
                delete this.layerIndexes[t],
                delete this.availableImages[t],
                delete this.workerSources[t],
                delete this.demWorkerSources[t],
                i()
            }
            checkIfReady(t, e, i) {
                i()
            }
            setReferrer(t, e) {
                this.referrer = e
            }
            spriteLoaded(e, i) {
                this.isSpriteLoaded[e] = i;
                for (const r in this.workerSources[e]) {
                    const n = this.workerSources[e][r];
                    for (const e in n)
                        n[e]instanceof t.VectorTileWorkerSource && (n[e].isSpriteLoaded = i,
                        n[e].fire(new t.Event("isSpriteLoaded")))
                }
            }
            setImages(t, e, i) {
                this.availableImages[t] = e;
                for (const i in this.workerSources[t]) {
                    const r = this.workerSources[t][i];
                    for (const t in r)
                        r[t].availableImages = e
                }
                i()
            }
            enableTerrain(t, e, i) {
                this.terrain = e,
                i()
            }
            setProjection(e, i) {
                this.projections[e] = t.getProjection(i)
            }
            setLayers(t, e, i) {
                this.getLayerIndex(t).replace(e),
                i()
            }
            updateLayers(t, e, i) {
                this.getLayerIndex(t).update(e.layers, e.removedIds),
                i()
            }
            loadTile(e, i, r) {
                const n = this.enableTerrain ? t.extend({
                    enableTerrain: this.terrain
                }, i) : i;
                n.projection = this.projections[e] || this.defaultProjection,
                this.getWorkerSource(e, i.type, i.source).loadTile(n, r)
            }
            loadDEMTile(e, i, r) {
                const n = this.enableTerrain ? t.extend({
                    buildQuadTree: this.terrain
                }, i) : i;
                this.getDEMWorkerSource(e, i.source).loadTile(n, r)
            }
            reloadTile(e, i, r) {
                const n = this.enableTerrain ? t.extend({
                    enableTerrain: this.terrain
                }, i) : i;
                n.projection = this.projections[e] || this.defaultProjection,
                this.getWorkerSource(e, i.type, i.source).reloadTile(n, r)
            }
            abortTile(t, e, i) {
                this.getWorkerSource(t, e.type, e.source).abortTile(e, i)
            }
            removeTile(t, e, i) {
                this.getWorkerSource(t, e.type, e.source).removeTile(e, i)
            }
            removeSource(t, e, i) {
                if (!this.workerSources[t] || !this.workerSources[t][e.type] || !this.workerSources[t][e.type][e.source])
                    return;
                const r = this.workerSources[t][e.type][e.source];
                delete this.workerSources[t][e.type][e.source],
                void 0 !== r.removeSource ? r.removeSource(e, i) : i()
            }
            loadWorkerSource(t, e, i) {
                try {
                    this.self.importScripts(e.url),
                    i()
                } catch (t) {
                    i(t.toString())
                }
            }
            syncRTLPluginState(e, i, r) {
                try {
                    t.plugin.setState(i);
                    const e = t.plugin.getPluginURL();
                    if (t.plugin.isLoaded() && !t.plugin.isParsed() && null != e) {
                        this.self.importScripts(e);
                        const i = t.plugin.isParsed();
                        r(i ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${e}`), i)
                    }
                } catch (t) {
                    r(t.toString())
                }
            }
            getAvailableImages(t) {
                let e = this.availableImages[t];
                return e || (e = []),
                e
            }
            getLayerIndex(t) {
                let e = this.layerIndexes[t];
                return e || (e = this.layerIndexes[t] = new r),
                e
            }
            getWorkerSource(t, e, i) {
                if (this.workerSources[t] || (this.workerSources[t] = {}),
                this.workerSources[t][e] || (this.workerSources[t][e] = {}),
                !this.workerSources[t][e][i]) {
                    const r = {
                        send: (e,i,r,n,o,s)=>{
                            this.actor.send(e, i, r, t, o, s)
                        }
                        ,
                        scheduler: this.actor.scheduler
                    };
                    this.workerSources[t][e][i] = new this.workerSourceTypes[e](r,this.getLayerIndex(t),this.getAvailableImages(t),this.isSpriteLoaded[t])
                }
                return this.workerSources[t][e][i]
            }
            getDEMWorkerSource(t, e) {
                return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}),
                this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new n),
                this.demWorkerSources[t][e]
            }
            enforceCacheSizeLimit(e, i) {
                t.enforceCacheSizeLimit(i)
            }
            getWorkerPerformanceMetrics(t, e, i) {
                i(void 0, void 0)
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Tt(self)),
        Tt
    }
    )),
    r(0, (function(t) {
        function e(t, i) {
            if (Array.isArray(t)) {
                if (!Array.isArray(i) || t.length !== i.length)
                    return !1;
                for (let r = 0; r < t.length; r++)
                    if (!e(t[r], i[r]))
                        return !1;
                return !0
            }
            if ("object" == typeof t && null !== t && null !== i) {
                if ("object" != typeof i)
                    return !1;
                if (Object.keys(t).length !== Object.keys(i).length)
                    return !1;
                for (const r in t)
                    if (!e(t[r], i[r]))
                        return !1;
                return !0
            }
            return t === i
        }
        var i = r;
        function r(t) {
            return e = t,
            !("undefined" == typeof window || "undefined" == typeof document || (!(Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray) || (!Function.prototype || !Function.prototype.bind || (!(Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions) || (!("JSON"in window && "parse"in JSON && "stringify"in JSON) || (!function() {
                if (!("Worker"in window && "Blob"in window && "URL"in window))
                    return !1;
                var t, e, i = new Blob([""],{
                    type: "text/javascript"
                }), r = URL.createObjectURL(i);
                try {
                    e = new Worker(r),
                    t = !0
                } catch (e) {
                    t = !1
                }
                return e && e.terminate(),
                URL.revokeObjectURL(r),
                t
            }() || (!("Uint8ClampedArray"in window) || (!ArrayBuffer.isView || (!function() {
                var t = document.createElement("canvas");
                t.width = t.height = 1;
                var e = t.getContext("2d");
                if (!e)
                    return !1;
                var i = e.getImageData(0, 0, 1, 1);
                return i && i.width === t.width
            }() || (void 0 === n[i = e && e.failIfMajorPerformanceCaveat] && (n[i] = function(t) {
                var e, i, n, o, s = (i = t,
                n = document.createElement("canvas"),
                (o = Object.create(r.webGLContextAttributes)).failIfMajorPerformanceCaveat = i,
                n.getContext("webgl", o) || n.getContext("experimental-webgl", o));
                if (!s)
                    return !1;
                try {
                    e = s.createShader(s.VERTEX_SHADER)
                } catch (i) {
                    return !1
                }
                return !(!e || s.isContextLost()) && (s.shaderSource(e, "void main() {}"),
                s.compileShader(e),
                !0 === s.getShaderParameter(e, s.COMPILE_STATUS))
            }(i)),
            !n[i] || (document.documentMode || void 0)))))))))));
            var e, i
        }
        var n = {};
        function o(e, i, r) {
            const n = t.window.document.createElement(e);
            return void 0 !== i && (n.className = i),
            r && r.appendChild(n),
            n
        }
        function s(e, i, r) {
            const n = t.window.document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const t of Object.keys(i))
                n.setAttributeNS(null, t, i[t]);
            return r && r.appendChild(n),
            n
        }
        r.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        const a = t.window.document && t.window.document.documentElement.style
          , l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
        let c;
        function u() {
            a && l && (c = a[l],
            a[l] = "none")
        }
        function h() {
            a && l && (a[l] = c)
        }
        function d(e) {
            e.preventDefault(),
            e.stopPropagation(),
            t.window.removeEventListener("click", d, !0)
        }
        function p() {
            t.window.addEventListener("click", d, !0),
            t.window.setTimeout((()=>{
                t.window.removeEventListener("click", d, !0)
            }
            ), 0)
        }
        function m(t, e) {
            const i = t.getBoundingClientRect();
            return g(t, i, e)
        }
        function f(t, e) {
            const i = t.getBoundingClientRect()
              , r = [];
            for (let n = 0; n < e.length; n++)
                r.push(g(t, i, e[n]));
            return r
        }
        function _(e) {
            return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button
        }
        function g(e, i, r) {
            const n = e.offsetWidth === i.width ? 1 : e.offsetWidth / i.width;
            return new t.pointGeometry((r.clientX - i.left) * n,(r.clientY - i.top) * n)
        }
        function y(t, e) {
            var i = e[0]
              , r = e[1]
              , n = e[2]
              , o = e[3]
              , s = i * o - n * r;
            return s ? (t[0] = o * (s = 1 / s),
            t[1] = -r * s,
            t[2] = -n * s,
            t[3] = i * s,
            t) : null
        }
        function x(t) {
            const {userImage: e} = t;
            return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)),
            !0)
        }
        class v extends t.Evented {
            constructor() {
                super(),
                this.images = {},
                this.updatedImages = {},
                this.callbackDispatchedThisFrame = {},
                this.loaded = !1,
                this.requestors = [],
                this.patterns = {},
                this.atlasImage = new t.RGBAImage({
                    width: 1,
                    height: 1
                }),
                this.dirty = !0
            }
            isLoaded() {
                return this.loaded
            }
            setLoaded(t) {
                if (this.loaded !== t && (this.loaded = t,
                t)) {
                    for (const {ids: t, callback: e} of this.requestors)
                        this._notify(t, e);
                    this.requestors = []
                }
            }
            hasImage(t) {
                return !!this.getImage(t)
            }
            getImage(t) {
                return this.images[t]
            }
            addImage(t, e) {
                this._validate(t, e) && (this.images[t] = e)
            }
            _validate(e, i) {
                let r = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchX" value`))),
                r = !1),
                this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchY" value`))),
                r = !1),
                this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "content" value`))),
                r = !1),
                r
            }
            _validateStretch(t, e) {
                if (!t)
                    return !0;
                let i = 0;
                for (const r of t) {
                    if (r[0] < i || r[1] < r[0] || e < r[1])
                        return !1;
                    i = r[1]
                }
                return !0
            }
            _validateContent(t, e) {
                return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]))
            }
            updateImage(t, e) {
                e.version = this.images[t].version + 1,
                this.images[t] = e,
                this.updatedImages[t] = !0
            }
            removeImage(t) {
                const e = this.images[t];
                delete this.images[t],
                delete this.patterns[t],
                e.userImage && e.userImage.onRemove && e.userImage.onRemove()
            }
            listImages() {
                return Object.keys(this.images)
            }
            getImages(t, e) {
                let i = !0;
                if (!this.isLoaded())
                    for (const e of t)
                        this.images[e] || (i = !1);
                this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({
                    ids: t,
                    callback: e
                })
            }
            _notify(e, i) {
                const r = {};
                for (const i of e) {
                    this.images[i] || this.fire(new t.Event("styleimagemissing",{
                        id: i
                    }));
                    const e = this.images[i];
                    e ? r[i] = {
                        data: e.data.clone(),
                        pixelRatio: e.pixelRatio,
                        sdf: e.sdf,
                        version: e.version,
                        stretchX: e.stretchX,
                        stretchY: e.stretchY,
                        content: e.content,
                        hasRenderCallback: Boolean(e.userImage && e.userImage.render)
                    } : t.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                }
                i(null, r)
            }
            getPixelSize() {
                const {width: t, height: e} = this.atlasImage;
                return {
                    width: t,
                    height: e
                }
            }
            getPattern(e) {
                const i = this.patterns[e]
                  , r = this.getImage(e);
                if (!r)
                    return null;
                if (i && i.position.version === r.version)
                    return i.position;
                if (i)
                    i.position.version = r.version;
                else {
                    const i = {
                        w: r.data.width + 2,
                        h: r.data.height + 2,
                        x: 0,
                        y: 0
                    }
                      , n = new t.ImagePosition(i,r);
                    this.patterns[e] = {
                        bin: i,
                        position: n
                    }
                }
                return this._updatePatternAtlas(),
                this.patterns[e].position
            }
            bind(e) {
                const i = e.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                this.dirty = !1) : this.atlasTexture = new t.Texture(e,this.atlasImage,i.RGBA),
                this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
            }
            _updatePatternAtlas() {
                const e = [];
                for (const t in this.patterns)
                    e.push(this.patterns[t].bin);
                const {w: i, h: r} = t.potpack(e)
                  , n = this.atlasImage;
                n.resize({
                    width: i || 1,
                    height: r || 1
                });
                for (const e in this.patterns) {
                    const {bin: i} = this.patterns[e]
                      , r = i.x + 1
                      , o = i.y + 1
                      , s = this.images[e].data
                      , a = s.width
                      , l = s.height;
                    t.RGBAImage.copy(s, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: r,
                        y: o
                    }, {
                        width: a,
                        height: l
                    }),
                    t.RGBAImage.copy(s, n, {
                        x: 0,
                        y: l - 1
                    }, {
                        x: r,
                        y: o - 1
                    }, {
                        width: a,
                        height: 1
                    }),
                    t.RGBAImage.copy(s, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: r,
                        y: o + l
                    }, {
                        width: a,
                        height: 1
                    }),
                    t.RGBAImage.copy(s, n, {
                        x: a - 1,
                        y: 0
                    }, {
                        x: r - 1,
                        y: o
                    }, {
                        width: 1,
                        height: l
                    }),
                    t.RGBAImage.copy(s, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: r + a,
                        y: o
                    }, {
                        width: 1,
                        height: l
                    })
                }
                this.dirty = !0
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {}
            }
            dispatchRenderCallbacks(t) {
                for (const e of t) {
                    if (this.callbackDispatchedThisFrame[e])
                        continue;
                    this.callbackDispatchedThisFrame[e] = !0;
                    const t = this.images[e];
                    x(t) && this.updateImage(e, t)
                }
            }
        }
        const b = new t.Properties({
            anchor: new t.DataConstantProperty(t.spec.light.anchor),
            position: new class {
                constructor() {
                    this.specification = t.spec.light.position
                }
                possiblyEvaluate(e, i) {
                    return function([e,i,r]) {
                        const n = t.degToRad(i + 90)
                          , o = t.degToRad(r);
                        return {
                            x: e * Math.cos(n) * Math.sin(o),
                            y: e * Math.sin(n) * Math.sin(o),
                            z: e * Math.cos(o),
                            azimuthal: i,
                            polar: r
                        }
                    }(e.expression.evaluate(i))
                }
                interpolate(e, i, r) {
                    return {
                        x: t.number(e.x, i.x, r),
                        y: t.number(e.y, i.y, r),
                        z: t.number(e.z, i.z, r),
                        azimuthal: t.number(e.azimuthal, i.azimuthal, r),
                        polar: t.number(e.polar, i.polar, r)
                    }
                }
            }
            ,
            color: new t.DataConstantProperty(t.spec.light.color),
            intensity: new t.DataConstantProperty(t.spec.light.intensity)
        })
          , w = "-transition";
        class z extends t.Evented {
            constructor(e) {
                super(),
                this._transitionable = new t.Transitionable(b),
                this.setLight(e),
                this._transitioning = this._transitionable.untransitioned()
            }
            getLight() {
                return this._transitionable.serialize()
            }
            setLight(e, i={}) {
                if (!this._validate(t.validateLight, e, i))
                    for (const i in e) {
                        const r = e[i];
                        t.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), r) : this._transitionable.setValue(i, r)
                    }
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning)
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t)
            }
            _validate(e, i, r) {
                return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: t.spec
                })))
            }
        }
        const T = new t.Properties({
            source: new t.DataConstantProperty(t.spec.terrain.source),
            exaggeration: new t.DataConstantProperty(t.spec.terrain.exaggeration)
        })
          , E = "-transition";
        class S extends t.Evented {
            constructor(e, i) {
                super(),
                this._transitionable = new t.Transitionable(T),
                this.set(e),
                this._transitioning = this._transitionable.untransitioned(),
                this.drapeRenderMode = i
            }
            get() {
                return this._transitionable.serialize()
            }
            set(e) {
                for (const i in e) {
                    const r = e[i];
                    t.endsWith(i, E) ? this._transitionable.setTransition(i.slice(0, -E.length), r) : this._transitionable.setValue(i, r)
                }
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning)
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t)
            }
        }
        function M(e, i, r, n) {
            const o = t.smoothstep(45, 65, r)
              , [s,a] = A(e, n)
              , l = t.length(i);
            let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
            return c *= c * c,
            c = Math.min(1, 1.00747 * c),
            c * o * e.alpha
        }
        function A(t, e) {
            const i = .5 / Math.tan(.5 * e);
            return [t.range[0] + i, t.range[1] + i]
        }
        const I = new t.Properties({
            range: new t.DataConstantProperty(t.spec.fog.range),
            color: new t.DataConstantProperty(t.spec.fog.color),
            "high-color": new t.DataConstantProperty(t.spec.fog["high-color"]),
            "space-color": new t.DataConstantProperty(t.spec.fog["space-color"]),
            "horizon-blend": new t.DataConstantProperty(t.spec.fog["horizon-blend"]),
            "star-intensity": new t.DataConstantProperty(t.spec.fog["star-intensity"])
        })
          , C = "-transition";
        class D extends t.Evented {
            constructor(e, i) {
                super(),
                this._transitionable = new t.Transitionable(I),
                this.set(e),
                this._transitioning = this._transitionable.untransitioned(),
                this._transform = i
            }
            get state() {
                const e = this._transform
                  , i = "globe" === e.projection.name
                  , r = t.globeToMercatorTransition(e.zoom)
                  , n = this.properties.get("range")
                  , o = [.5, 3];
                return {
                    range: i ? [t.number(o[0], n[0], r), t.number(o[1], n[1], r)] : n,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                }
            }
            get() {
                return this._transitionable.serialize()
            }
            set(e, i={}) {
                if (!this._validate(t.validateFog, e, i)) {
                    for (const i of Object.keys(t.spec.fog))
                        e && void 0 === e[i] && (e[i] = t.spec.fog[i].default);
                    for (const i in e) {
                        const r = e[i];
                        t.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), r) : this._transitionable.setValue(i, r)
                    }
                }
            }
            getOpacity(e) {
                if (!this._transform.projection.supportsFog)
                    return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : t.smoothstep(45, 65, e)) * i.a
            }
            getOpacityAtLatLng(e, i) {
                return this._transform.projection.supportsFog ? function(e, i, r) {
                    const n = t.MercatorCoordinate.fromLngLat(i)
                      , o = r.elevation ? r.elevation.getAtPointOrZero(n) : 0
                      , s = [n.x, n.y, o];
                    return t.transformMat4(s, s, r.mercatorFogMatrix),
                    M(e, s, r.pitch, r._fov)
                }(this.state, e, i) : 0
            }
            getFovAdjustedRange(t) {
                return this._transform.projection.supportsFog ? A(this.state, t) : [0, 1]
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning)
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t)
            }
            _validate(e, i, r) {
                return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: t.spec
                })))
            }
        }
        class k {
            constructor(e, i) {
                this.workerPool = e,
                this.actors = [],
                this.currentActor = 0,
                this.id = t.uniqueId();
                const r = this.workerPool.acquire(this.id);
                for (let t = 0; t < r.length; t++) {
                    const e = new k.Actor(r[t],i,this.id);
                    e.name = `Worker ${t}`,
                    this.actors.push(e)
                }
                this.ready = !1,
                this.broadcast("checkIfReady", null, (()=>{
                    this.ready = !0
                }
                ))
            }
            broadcast(e, i, r) {
                t.asyncAll(this.actors, ((t,r)=>{
                    t.send(e, i, r)
                }
                ), r = r || function() {}
                )
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length,
                this.actors[this.currentActor]
            }
            remove() {
                this.actors.forEach((t=>{
                    t.remove()
                }
                )),
                this.actors = [],
                this.workerPool.release(this.id)
            }
        }
        function P(e, i, r) {
            return i * (t.EXTENT / (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ)))
        }
        k.Actor = t.Actor;
        class L {
            constructor(t, e, i, r) {
                this.screenBounds = t,
                this.cameraPoint = e,
                this._screenRaycastCache = {},
                this._cameraRaycastCache = {},
                this.isAboveHorizon = i,
                this.screenGeometry = this.bufferedScreenGeometry(0),
                this.screenGeometryMercator = this._bufferedScreenMercator(0, r)
            }
            static createFromScreenPoints(e, i) {
                let r, n;
                if (e instanceof t.pointGeometry || "number" == typeof e[0]) {
                    const o = t.pointGeometry.convert(e);
                    r = [o],
                    n = i.isPointAboveHorizon(o)
                } else {
                    const o = t.pointGeometry.convert(e[0])
                      , s = t.pointGeometry.convert(e[1]);
                    r = [o, s],
                    n = t.polygonizeBounds(o, s).every((t=>i.isPointAboveHorizon(t)))
                }
                return new L(r,i.getCameraPoint(),n,i)
            }
            isPointQuery() {
                return 1 === this.screenBounds.length
            }
            bufferedScreenGeometry(e) {
                return t.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], e)
            }
            bufferedCameraGeometry(e) {
                const i = this.screenBounds[0]
                  , r = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.pointGeometry(1,1)) : this.screenBounds[1]
                  , n = t.polygonizeBounds(i, r, 0, !1);
                return this.cameraPoint.y > r.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < r.x ? n.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= r.x ? n[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (n[3] = this.cameraPoint)),
                t.bufferConvexPolygon(n, e)
            }
            bufferedCameraGeometryGlobe(e) {
                const i = this.screenBounds[0]
                  , r = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.pointGeometry(1,1)) : this.screenBounds[1]
                  , n = t.polygonizeBounds(i, r, e)
                  , o = this.cameraPoint.clone();
                switch (3 * ((o.y > i.y) + (o.y > r.y)) + ((o.x > i.x) + (o.x > r.x))) {
                case 0:
                    n[0] = o,
                    n[4] = o.clone();
                    break;
                case 1:
                    n.splice(1, 0, o);
                    break;
                case 2:
                    n[1] = o;
                    break;
                case 3:
                    n.splice(4, 0, o);
                    break;
                case 5:
                    n.splice(2, 0, o);
                    break;
                case 6:
                    n[3] = o;
                    break;
                case 7:
                    n.splice(3, 0, o);
                    break;
                case 8:
                    n[2] = o
                }
                return n
            }
            containsTile(e, i, r, n=0) {
                const o = e.queryPadding / i._pixelsPerMercatorPixel + 1
                  , s = r ? this._bufferedCameraMercator(o, i) : this._bufferedScreenMercator(o, i);
                let a = e.tileID.wrap + (s.unwrapped ? n : 0);
                const l = s.polygon.map((i=>t.getTilePoint(e.tileTransform, i, a)));
                if (!t.polygonIntersectsBox(l, 0, 0, t.EXTENT, t.EXTENT))
                    return;
                a = e.tileID.wrap + (this.screenGeometryMercator.unwrapped ? n : 0);
                const c = this.screenGeometryMercator.polygon.map((i=>t.getTileVec3(e.tileTransform, i, a)))
                  , u = c.map((e=>new t.pointGeometry(e[0],e[1])))
                  , h = i.getFreeCameraOptions().position || new t.MercatorCoordinate(0,0,0)
                  , d = t.getTileVec3(e.tileTransform, h, a)
                  , p = c.map((e=>{
                    const i = t.sub(e, e, d);
                    return t.normalize(i, i),
                    new t.Ray(d,i)
                }
                ))
                  , m = P(e, 1, i.zoom) * i._pixelsPerMercatorPixel;
                var f;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: u,
                    tilespaceRays: p,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (f = t.getBounds(l),
                    f.min.x = t.clamp(f.min.x, 0, t.EXTENT),
                    f.min.y = t.clamp(f.min.y, 0, t.EXTENT),
                    f.max.x = t.clamp(f.max.x, 0, t.EXTENT),
                    f.max.y = t.clamp(f.max.y, 0, t.EXTENT),
                    f),
                    tile: e,
                    tileID: e.tileID,
                    pixelToTileUnitsFactor: m
                }
            }
            _bufferedScreenMercator(t, e) {
                const i = B(t);
                if (this._screenRaycastCache[i])
                    return this._screenRaycastCache[i];
                {
                    let r;
                    return r = "globe" === e.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(t), e) : {
                        polygon: this.bufferedScreenGeometry(t).map((t=>e.pointCoordinate3D(t))),
                        unwrapped: !0
                    },
                    this._screenRaycastCache[i] = r,
                    r
                }
            }
            _bufferedCameraMercator(t, e) {
                const i = B(t);
                if (this._cameraRaycastCache[i])
                    return this._cameraRaycastCache[i];
                {
                    let r;
                    return r = "globe" === e.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), e) : {
                        polygon: this.bufferedCameraGeometry(t).map((t=>e.pointCoordinate3D(t))),
                        unwrapped: !0
                    },
                    this._cameraRaycastCache[i] = r,
                    r
                }
            }
            _projectAndResample(e, i) {
                const r = function(e, i) {
                    const r = t.multiply([], i.pixelMatrix, i.globeMatrix)
                      , n = [0, -t.GLOBE_RADIUS, 0, 1]
                      , o = [0, t.GLOBE_RADIUS, 0, 1]
                      , s = [0, 0, 0, 1];
                    t.transformMat4$1(n, n, r),
                    t.transformMat4$1(o, o, r),
                    t.transformMat4$1(s, s, r);
                    const a = new t.pointGeometry(n[0] / n[3],n[1] / n[3])
                      , l = new t.pointGeometry(o[0] / o[3],o[1] / o[3])
                      , c = t.polygonContainsPoint(e, a) && n[3] < s[3]
                      , u = t.polygonContainsPoint(e, l) && o[3] < s[3];
                    if (!c && !u)
                        return null;
                    const h = function(t, e, i) {
                        for (let r = 1; r < t.length; r++) {
                            const n = R(e.pointCoordinate3D(t[r - 1]).x)
                              , o = R(e.pointCoordinate3D(t[r]).x);
                            if (i < 0) {
                                if (n < o)
                                    return {
                                        idx: r,
                                        t: -n / (o - 1 - n)
                                    }
                            } else if (o < n)
                                return {
                                    idx: r,
                                    t: (1 - n) / (o + 1 - n)
                                }
                        }
                        return null
                    }(e, i, c ? -1 : 1);
                    if (!h)
                        return null;
                    const {idx: d, t: p} = h;
                    let m = d > 1 ? O(e.slice(0, d), i) : []
                      , f = d < e.length ? O(e.slice(d), i) : [];
                    m = m.map((e=>new t.pointGeometry(R(e.x),e.y))),
                    f = f.map((e=>new t.pointGeometry(R(e.x),e.y)));
                    const _ = [...m];
                    0 === _.length && _.push(f[f.length - 1]);
                    const g = t.number(_[_.length - 1].y, (0 === f.length ? m[0] : f[0]).y, p);
                    let y;
                    return y = c ? [new t.pointGeometry(0,g), new t.pointGeometry(0,0), new t.pointGeometry(1,0), new t.pointGeometry(1,g)] : [new t.pointGeometry(1,g), new t.pointGeometry(1,1), new t.pointGeometry(0,1), new t.pointGeometry(0,g)],
                    _.push(...y),
                    0 === f.length ? _.push(m[0]) : _.push(...f),
                    {
                        polygon: _.map((e=>new t.MercatorCoordinate(e.x,e.y))),
                        unwrapped: !1
                    }
                }(e, i);
                if (r)
                    return r;
                const n = function(e, i) {
                    let r = !1
                      , n = -1 / 0
                      , o = 0;
                    for (let t = 0; t < e.length - 1; t++)
                        e[t].x > n && (n = e[t].x,
                        o = t);
                    for (let t = 0; t < e.length - 1; t++) {
                        const i = (o + t) % (e.length - 1)
                          , n = e[i]
                          , s = e[i + 1];
                        Math.abs(n.x - s.x) > .5 && (n.x < s.x ? (n.x += 1,
                        0 === i && (e[e.length - 1].x += 1)) : (s.x += 1,
                        i + 1 === e.length - 1 && (e[0].x += 1)),
                        r = !0)
                    }
                    const s = t.mercatorXfromLng(i.center.lng);
                    return r && s < Math.abs(s - 1) && e.forEach((t=>{
                        t.x -= 1
                    }
                    )),
                    {
                        polygon: e,
                        unwrapped: r
                    }
                }(O(e, i).map((e=>new t.pointGeometry(R(e.x),e.y))), i);
                return {
                    polygon: n.polygon.map((e=>new t.MercatorCoordinate(e.x,e.y))),
                    unwrapped: n.unwrapped
                }
            }
        }
        function O(e, i) {
            return t.resample(e, (t=>{
                const e = i.pointCoordinate3D(t);
                t.x = e.x,
                t.y = e.y
            }
            ), 1 / 256)
        }
        function R(t) {
            return t < 0 ? 1 + t % 1 : t % 1
        }
        function B(t) {
            return 100 * t | 0
        }
        function F(e, i, r, n, o) {
            const s = function(r, n) {
                if (r)
                    return o(r);
                if (n) {
                    e.url && n.tiles && e.tiles && delete e.tiles;
                    const r = t.pick(t.extend(n, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                    n.vector_layers && (r.vectorLayers = n.vector_layers,
                    r.vectorLayerIds = r.vectorLayers.map((t=>t.id))),
                    r.tiles = i.canonicalizeTileset(r, e.url),
                    o(null, r)
                }
            };
            return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url, null, r, n), t.ResourceType.Source), s) : t.exported.frame((()=>s(null, e)))
        }
        class U {
            constructor(e, i, r) {
                this.bounds = t.LngLatBounds.convert(this.validateBounds(e)),
                this.minzoom = i || 0,
                this.maxzoom = r || 24
            }
            validateBounds(t) {
                return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90]
            }
            contains(e) {
                const i = Math.pow(2, e.z)
                  , r = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i)
                  , n = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i)
                  , o = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i)
                  , s = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);
                return e.x >= r && e.x < o && e.y >= n && e.y < s
            }
        }
        class N {
            constructor(t, e, i) {
                this.context = t;
                const r = t.gl;
                this.buffer = r.createBuffer(),
                this.dynamicDraw = Boolean(i),
                this.context.unbindVAO(),
                t.bindElementBuffer.set(this.buffer),
                r.bufferData(r.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW),
                this.dynamicDraw || e.destroy()
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer)
            }
            updateData(t) {
                const e = this.context.gl;
                this.context.unbindVAO(),
                this.bind(),
                e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer)
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                delete this.buffer)
            }
        }
        const G = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class j {
            constructor(t, e, i, r) {
                this.length = e.length,
                this.attributes = i,
                this.itemSize = e.bytesPerElement,
                this.dynamicDraw = r,
                this.context = t;
                const n = t.gl;
                this.buffer = n.createBuffer(),
                t.bindVertexBuffer.set(this.buffer),
                n.bufferData(n.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW),
                this.dynamicDraw || e.destroy()
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer)
            }
            updateData(t) {
                const e = this.context.gl;
                this.bind(),
                e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer)
            }
            enableAttributes(t, e) {
                for (let i = 0; i < this.attributes.length; i++) {
                    const r = e.attributes[this.attributes[i].name];
                    void 0 !== r && t.enableVertexAttribArray(r)
                }
            }
            setVertexAttribPointers(t, e, i) {
                for (let r = 0; r < this.attributes.length; r++) {
                    const n = this.attributes[r]
                      , o = e.attributes[n.name];
                    void 0 !== o && t.vertexAttribPointer(o, n.components, t[G[n.type]], !1, this.itemSize, n.offset + this.itemSize * (i || 0))
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                delete this.buffer)
            }
        }
        class V {
            constructor(t) {
                this.gl = t.gl,
                this.default = this.getDefault(),
                this.current = this.default,
                this.dirty = !1
            }
            get() {
                return this.current
            }
            set(t) {}
            getDefault() {
                return this.default
            }
            setDefault() {
                this.set(this.default)
            }
        }
        class Z extends V {
            getDefault() {
                return t.Color.transparent
            }
            set(t) {
                const e = this.current;
                (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a),
                this.current = t,
                this.dirty = !1)
            }
        }
        class J extends V {
            getDefault() {
                return 1
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.clearDepth(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class X extends V {
            getDefault() {
                return 0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.clearStencil(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class q extends V {
            getDefault() {
                return [!0, !0, !0, !0]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                this.current = t,
                this.dirty = !1)
            }
        }
        class $ extends V {
            getDefault() {
                return !0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.depthMask(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class Y extends V {
            getDefault() {
                return 255
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.stencilMask(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class W extends V {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                }
            }
            set(t) {
                const e = this.current;
                (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask),
                this.current = t,
                this.dirty = !1)
            }
        }
        class H extends V {
            getDefault() {
                const t = this.gl;
                return [t.KEEP, t.KEEP, t.KEEP]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]),
                this.current = t,
                this.dirty = !1)
            }
        }
        class K extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
                this.current = t,
                this.dirty = !1
            }
        }
        class Q extends V {
            getDefault() {
                return [0, 1]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]),
                this.current = t,
                this.dirty = !1)
            }
        }
        class tt extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
                this.current = t,
                this.dirty = !1
            }
        }
        class et extends V {
            getDefault() {
                return this.gl.LESS
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.depthFunc(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class it extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.BLEND) : e.disable(e.BLEND),
                this.current = t,
                this.dirty = !1
            }
        }
        class rt extends V {
            getDefault() {
                const t = this.gl;
                return [t.ONE, t.ZERO]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]),
                this.current = t,
                this.dirty = !1)
            }
        }
        class nt extends V {
            getDefault() {
                return t.Color.transparent
            }
            set(t) {
                const e = this.current;
                (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a),
                this.current = t,
                this.dirty = !1)
            }
        }
        class ot extends V {
            getDefault() {
                return this.gl.FUNC_ADD
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.blendEquation(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class st extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
                this.current = t,
                this.dirty = !1
            }
        }
        class at extends V {
            getDefault() {
                return this.gl.BACK
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.cullFace(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class lt extends V {
            getDefault() {
                return this.gl.CCW
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.frontFace(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class ct extends V {
            getDefault() {
                return null
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.useProgram(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class ut extends V {
            getDefault() {
                return this.gl.TEXTURE0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.activeTexture(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class ht extends V {
            getDefault() {
                const t = this.gl;
                return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]),
                this.current = t,
                this.dirty = !1)
            }
        }
        class dt extends V {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindFramebuffer(e.FRAMEBUFFER, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class pt extends V {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindRenderbuffer(e.RENDERBUFFER, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class mt extends V {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindTexture(e.TEXTURE_2D, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class ft extends V {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindBuffer(e.ARRAY_BUFFER, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class _t extends V {
            getDefault() {
                return null
            }
            set(t) {
                const e = this.gl;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class gt extends V {
            constructor(t) {
                super(t),
                this.vao = t.extVertexArrayObject
            }
            getDefault() {
                return null
            }
            set(t) {
                this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t),
                this.current = t,
                this.dirty = !1)
            }
        }
        class yt extends V {
            getDefault() {
                return 4
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_ALIGNMENT, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class xt extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class vt extends V {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class bt extends V {
            constructor(t, e) {
                super(t),
                this.context = t,
                this.parent = e
            }
            getDefault() {
                return null
            }
        }
        class wt extends bt {
            setDirty() {
                this.dirty = !0
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0),
                this.current = t,
                this.dirty = !1
            }
        }
        class zt extends bt {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferRenderbuffer(e.FRAMEBUFFER, this.attachment(), e.RENDERBUFFER, t),
                this.current = t,
                this.dirty = !1
            }
        }
        class Tt extends zt {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT
            }
        }
        class Et {
            constructor(t, e, i, r) {
                this.context = t,
                this.width = e,
                this.height = i;
                const n = this.framebuffer = t.gl.createFramebuffer();
                this.colorAttachment = new wt(t,n),
                r && (this.depthAttachment = new zt(t,n))
            }
            destroy() {
                const t = this.context.gl
                  , e = this.colorAttachment.get();
                if (e && t.deleteTexture(e),
                this.depthAttachment) {
                    const e = this.depthAttachment.get();
                    e && t.deleteRenderbuffer(e)
                }
                t.deleteFramebuffer(this.framebuffer)
            }
        }
        class St {
            constructor(t) {
                this.gl = t,
                this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"),
                this.clearColor = new Z(this),
                this.clearDepth = new J(this),
                this.clearStencil = new X(this),
                this.colorMask = new q(this),
                this.depthMask = new $(this),
                this.stencilMask = new Y(this),
                this.stencilFunc = new W(this),
                this.stencilOp = new H(this),
                this.stencilTest = new K(this),
                this.depthRange = new Q(this),
                this.depthTest = new tt(this),
                this.depthFunc = new et(this),
                this.blend = new it(this),
                this.blendFunc = new rt(this),
                this.blendColor = new nt(this),
                this.blendEquation = new ot(this),
                this.cullFace = new st(this),
                this.cullFaceSide = new at(this),
                this.frontFace = new lt(this),
                this.program = new ct(this),
                this.activeTexture = new ut(this),
                this.viewport = new ht(this),
                this.bindFramebuffer = new dt(this),
                this.bindRenderbuffer = new pt(this),
                this.bindTexture = new mt(this),
                this.bindVertexBuffer = new ft(this),
                this.bindElementBuffer = new _t(this),
                this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this),
                this.pixelStoreUnpack = new yt(this),
                this.pixelStoreUnpackPremultiplyAlpha = new xt(this),
                this.pixelStoreUnpackFlipY = new vt(this),
                this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                this.extTextureFilterAnisotropicForceOff = !1,
                this.extStandardDerivativesForceOff = !1,
                this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"),
                this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),
                this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),
                this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"),
                this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"),
                this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")),
                this.extStandardDerivatives = t.getExtension("OES_standard_derivatives"),
                this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"),
                this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)
            }
            setDefault() {
                this.unbindVAO(),
                this.clearColor.setDefault(),
                this.clearDepth.setDefault(),
                this.clearStencil.setDefault(),
                this.colorMask.setDefault(),
                this.depthMask.setDefault(),
                this.stencilMask.setDefault(),
                this.stencilFunc.setDefault(),
                this.stencilOp.setDefault(),
                this.stencilTest.setDefault(),
                this.depthRange.setDefault(),
                this.depthTest.setDefault(),
                this.depthFunc.setDefault(),
                this.blend.setDefault(),
                this.blendFunc.setDefault(),
                this.blendColor.setDefault(),
                this.blendEquation.setDefault(),
                this.cullFace.setDefault(),
                this.cullFaceSide.setDefault(),
                this.frontFace.setDefault(),
                this.program.setDefault(),
                this.activeTexture.setDefault(),
                this.bindFramebuffer.setDefault(),
                this.pixelStoreUnpack.setDefault(),
                this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                this.pixelStoreUnpackFlipY.setDefault()
            }
            setDirty() {
                this.clearColor.dirty = !0,
                this.clearDepth.dirty = !0,
                this.clearStencil.dirty = !0,
                this.colorMask.dirty = !0,
                this.depthMask.dirty = !0,
                this.stencilMask.dirty = !0,
                this.stencilFunc.dirty = !0,
                this.stencilOp.dirty = !0,
                this.stencilTest.dirty = !0,
                this.depthRange.dirty = !0,
                this.depthTest.dirty = !0,
                this.depthFunc.dirty = !0,
                this.blend.dirty = !0,
                this.blendFunc.dirty = !0,
                this.blendColor.dirty = !0,
                this.blendEquation.dirty = !0,
                this.cullFace.dirty = !0,
                this.cullFaceSide.dirty = !0,
                this.frontFace.dirty = !0,
                this.program.dirty = !0,
                this.activeTexture.dirty = !0,
                this.viewport.dirty = !0,
                this.bindFramebuffer.dirty = !0,
                this.bindRenderbuffer.dirty = !0,
                this.bindTexture.dirty = !0,
                this.bindVertexBuffer.dirty = !0,
                this.bindElementBuffer.dirty = !0,
                this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0),
                this.pixelStoreUnpack.dirty = !0,
                this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                this.pixelStoreUnpackFlipY.dirty = !0
            }
            createIndexBuffer(t, e) {
                return new N(this,t,e)
            }
            createVertexBuffer(t, e, i) {
                return new j(this,t,e,i)
            }
            createRenderbuffer(t, e, i) {
                const r = this.gl
                  , n = r.createRenderbuffer();
                return this.bindRenderbuffer.set(n),
                r.renderbufferStorage(r.RENDERBUFFER, t, e, i),
                this.bindRenderbuffer.set(null),
                n
            }
            createFramebuffer(t, e, i) {
                return new Et(this,t,e,i)
            }
            clear({color: t, depth: e, stencil: i}) {
                const r = this.gl;
                let n = 0;
                t && (n |= r.COLOR_BUFFER_BIT,
                this.clearColor.set(t),
                this.colorMask.set([!0, !0, !0, !0])),
                void 0 !== e && (n |= r.DEPTH_BUFFER_BIT,
                this.depthRange.set([0, 1]),
                this.clearDepth.set(e),
                this.depthMask.set(!0)),
                void 0 !== i && (n |= r.STENCIL_BUFFER_BIT,
                this.clearStencil.set(i),
                this.stencilMask.set(255)),
                r.clear(n)
            }
            setCullFace(t) {
                !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                this.cullFaceSide.set(t.mode),
                this.frontFace.set(t.frontFace))
            }
            setDepthMode(t) {
                t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0),
                this.depthFunc.set(t.func),
                this.depthMask.set(t.mask),
                this.depthRange.set(t.range)) : this.depthTest.set(!1)
            }
            setStencilMode(t) {
                t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0),
                this.stencilMask.set(t.mask),
                this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                this.stencilFunc.set({
                    func: t.test.func,
                    ref: t.ref,
                    mask: t.test.mask
                })) : this.stencilTest.set(!1)
            }
            setColorMode(i) {
                e(i.blendFunction, t.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                this.blendFunc.set(i.blendFunction),
                this.blendColor.set(i.blendColor)),
                this.colorMask.set(i.mask)
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null)
            }
        }
        class Mt extends t.Evented {
            constructor(e, i, r, n) {
                super(),
                this.id = e,
                this.dispatcher = r,
                this.setEventedParent(n),
                this.type = "raster",
                this.minzoom = 0,
                this.maxzoom = 22,
                this.roundZoom = !0,
                this.scheme = "xyz",
                this.tileSize = 512,
                this._loaded = !1,
                this._options = t.extend({
                    type: "raster"
                }, i),
                t.extend(this, t.pick(i, ["url", "scheme", "tileSize"]))
            }
            load() {
                this._loaded = !1,
                this.fire(new t.Event("dataloading",{
                    dataType: "source"
                })),
                this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, ((e,i)=>{
                    this._tileJSONRequest = null,
                    this._loaded = !0,
                    e ? this.fire(new t.ErrorEvent(e)) : i && (t.extend(this, i),
                    i.bounds && (this.tileBounds = new U(i.bounds,this.minzoom,this.maxzoom)),
                    t.postTurnstileEvent(i.tiles),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "metadata"
                    })),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    })))
                }
                ))
            }
            loaded() {
                return this._loaded
            }
            onAdd(t) {
                this.map = t,
                this.load()
            }
            onRemove() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                this._tileJSONRequest = null)
            }
            serialize() {
                return t.extend({}, this._options)
            }
            hasTile(t) {
                return !this.tileBounds || this.tileBounds.contains(t.canonical)
            }
            loadTile(e, i) {
                const r = t.exported.devicePixelRatio >= 2
                  , n = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), r, this.tileSize);
                e.request = t.getImage(this.map._requestManager.transformRequest(n, t.ResourceType.Tile), ((r,n,o,s)=>(delete e.request,
                e.aborted ? (e.state = "unloaded",
                i(null)) : r ? (e.state = "errored",
                i(r)) : n ? (this.map._refreshExpiredTiles && e.setExpiryData({
                    cacheControl: o,
                    expires: s
                }),
                e.setTexture(n, this.map.painter),
                e.state = "loaded",
                t.cacheEntryPossiblyAdded(this.dispatcher),
                void i(null)) : i(null))))
            }
            static loadTileData(t, e, i) {
                t.setTexture(e, i)
            }
            static unloadTileData(t, e) {
                t.texture && e.saveTileTexture(t.texture)
            }
            abortTile(t, e) {
                t.request && (t.request.cancel(),
                delete t.request),
                e()
            }
            unloadTile(t, e) {
                t.texture && this.map.painter.saveTileTexture(t.texture),
                e()
            }
            hasTransition() {
                return !1
            }
        }
        let At;
        function It(e, i, r, n, o, s, a, l) {
            const c = [e, r, o, i, n, s, 1, 1, 1]
              , u = [a, l, 1]
              , h = t.adjoint([], c)
              , [d,p,m] = t.transformMat3(u, u, t.transpose(h, h));
            return t.multiply$1(c, [d, 0, 0, 0, p, 0, 0, 0, m], c)
        }
        class Ct extends t.Evented {
            constructor(t, e, i, r) {
                super(),
                this.id = t,
                this.dispatcher = i,
                this.coordinates = e.coordinates,
                this.type = "image",
                this.minzoom = 0,
                this.maxzoom = 22,
                this.tileSize = 512,
                this.tiles = {},
                this._loaded = !1,
                this.setEventedParent(r),
                this.options = e,
                this._dirty = !1
            }
            load(e, i) {
                this._loaded = i || !1,
                this.fire(new t.Event("dataloading",{
                    dataType: "source"
                })),
                this.url = this.options.url,
                this._imageRequest = t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), ((i,r)=>{
                    if (this._imageRequest = null,
                    this._loaded = !0,
                    i)
                        this.fire(new t.ErrorEvent(i));
                    else if (r) {
                        const {HTMLImageElement: i} = t.window;
                        this.image = r instanceof i ? t.exported.getImageData(r) : r,
                        this._dirty = !0,
                        this.width = this.image.width,
                        this.height = this.image.height,
                        e && (this.coordinates = e),
                        this._finishLoading()
                    }
                }
                ))
            }
            loaded() {
                return this._loaded
            }
            updateImage(t) {
                return this.image && t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(),
                this._imageRequest = null),
                this.options.url = t.url,
                this.load(t.coordinates, this._loaded),
                this) : this
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates),
                this.fire(new t.Event("data",{
                    dataType: "source",
                    sourceDataType: "metadata"
                })))
            }
            onAdd(t) {
                this.map = t,
                this.load()
            }
            onRemove() {
                this._imageRequest && (this._imageRequest.cancel(),
                this._imageRequest = null),
                this.texture && this.texture.destroy()
            }
            setCoordinates(e) {
                this.coordinates = e,
                this._boundsArray = void 0;
                const i = e.map(t.MercatorCoordinate.fromLngLat);
                return this.tileID = function(e) {
                    let i = 1 / 0
                      , r = 1 / 0
                      , n = -1 / 0
                      , o = -1 / 0;
                    for (const t of e)
                        i = Math.min(i, t.x),
                        r = Math.min(r, t.y),
                        n = Math.max(n, t.x),
                        o = Math.max(o, t.y);
                    const s = Math.max(n - i, o - r)
                      , a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2))
                      , l = Math.pow(2, a);
                    return new t.CanonicalTileID(a,Math.floor((i + n) / 2 * l),Math.floor((r + o) / 2 * l))
                }(i),
                this.minzoom = this.maxzoom = this.tileID.z,
                this.fire(new t.Event("data",{
                    dataType: "source",
                    sourceDataType: "content"
                })),
                this
            }
            _clear() {
                this._boundsArray = void 0
            }
            _prepareData(e) {
                for (const t in this.tiles) {
                    const e = this.tiles[t];
                    "loaded" !== e.state && (e.state = "loaded",
                    e.texture = this.texture)
                }
                if (this._boundsArray)
                    return;
                const i = t.tileTransform(this.tileID, this.map.transform.projection)
                  , [r,n,o,s] = this.coordinates.map((e=>{
                    const r = i.projection.project(e[0], e[1]);
                    return t.getTilePoint(i, r)._round()
                }
                ));
                this.perspectiveTransform = function(e, i, r, n, o, s, a, l, c, u) {
                    const h = It(0, 0, e, 0, 0, i, e, i)
                      , d = It(r, n, o, s, a, l, c, u);
                    return t.multiply$1(d, t.adjoint(h, h), d),
                    [d[6] / d[8] * e / t.EXTENT, d[7] / d[8] * i / t.EXTENT]
                }(this.width, this.height, r.x, r.y, n.x, n.y, s.x, s.y, o.x, o.y);
                const a = this._boundsArray = new t.StructArrayLayout4i8;
                a.emplaceBack(r.x, r.y, 0, 0),
                a.emplaceBack(n.x, n.y, t.EXTENT, 0),
                a.emplaceBack(s.x, s.y, 0, t.EXTENT),
                a.emplaceBack(o.x, o.y, t.EXTENT, t.EXTENT),
                this.boundsBuffer && this.boundsBuffer.destroy(),
                this.boundsBuffer = e.createVertexBuffer(a, t.boundsAttributes.members),
                this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image)
                    return;
                const e = this.map.painter.context
                  , i = e.gl;
                this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new t.Texture(e,this.image,i.RGBA),
                this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)),
                this._dirty = !1),
                this._prepareData(e)
            }
            loadTile(t, e) {
                this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t,
                t.buckets = {},
                e(null)) : (t.state = "errored",
                e(null))
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                }
            }
            hasTransition() {
                return !1
            }
        }
        const Dt = {
            vector: class extends t.Evented {
                constructor(e, i, r, n) {
                    if (super(),
                    this.id = e,
                    this.dispatcher = r,
                    this.type = "vector",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.scheme = "xyz",
                    this.tileSize = 512,
                    this.reparseOverscaled = !0,
                    this.isTileClipped = !0,
                    this._loaded = !1,
                    t.extend(this, t.pick(i, ["url", "scheme", "tileSize", "promoteId"])),
                    this._options = t.extend({
                        type: "vector"
                    }, i),
                    this._collectResourceTiming = i.collectResourceTiming,
                    512 !== this.tileSize)
                        throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(n),
                    this._tileWorkers = {},
                    this._deduped = new t.DedupedRequest
                }
                load(e) {
                    this._loaded = !1,
                    this.fire(new t.Event("dataloading",{
                        dataType: "source"
                    }));
                    const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language
                      , r = this.map._worldview;
                    this._tileJSONRequest = F(this._options, this.map._requestManager, i, r, ((n,o)=>{
                        this._tileJSONRequest = null,
                        this._loaded = !0,
                        n ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`),
                        r && 2 !== r.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${r}`),
                        this.fire(new t.ErrorEvent(n))) : o && (t.extend(this, o),
                        o.bounds && (this.tileBounds = new U(o.bounds,this.minzoom,this.maxzoom)),
                        t.postTurnstileEvent(o.tiles, this.map._requestManager._customAccessToken),
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })),
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))),
                        e && e(n)
                    }
                    ))
                }
                loaded() {
                    return this._loaded
                }
                hasTile(t) {
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }
                onAdd(t) {
                    this.map = t,
                    this.load()
                }
                reload() {
                    this.cancelTileJSONRequest(),
                    this.load((()=>{
                        const t = this.map.style._getSourceCaches(this.id);
                        for (const e of t)
                            e.clearTiles()
                    }
                    ))
                }
                setSourceProperty(t) {
                    t(),
                    this.reload()
                }
                setTiles(t) {
                    return this._options.tiles = t,
                    this.reload(),
                    this
                }
                setUrl(t) {
                    return this.url = t,
                    this._options.url = t,
                    this.reload(),
                    this
                }
                onRemove() {
                    this.cancelTileJSONRequest()
                }
                serialize() {
                    return t.extend({}, this._options)
                }
                loadTile(e, i) {
                    const r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme))
                      , n = {
                        request: this.map._requestManager.transformRequest(r, t.ResourceType.Tile),
                        data: void 0,
                        uid: e.uid,
                        tileID: e.tileID,
                        tileZoom: e.tileZoom,
                        zoom: e.tileID.overscaledZ,
                        tileSize: this.tileSize * e.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: t.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        isSymbolTile: e.isSymbolTile
                    };
                    if (n.request.collectResourceTiming = this._collectResourceTiming,
                    e.actor && "expired" !== e.state)
                        "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", n, o.bind(this));
                    else if (e.actor = this._tileWorkers[r] = this._tileWorkers[r] || this.dispatcher.getActor(),
                    this.dispatcher.ready)
                        e.request = e.actor.send("loadTile", n, o.bind(this), void 0, !0);
                    else {
                        const i = t.loadVectorTile.call({
                            deduped: this._deduped
                        }, n, ((t,i)=>{
                            t || !i ? o.call(this, t) : (n.data = {
                                cacheControl: i.cacheControl,
                                expires: i.expires,
                                rawData: i.rawData.slice(0)
                            },
                            e.actor && e.actor.send("loadTile", n, o.bind(this), void 0, !0))
                        }
                        ), !0);
                        e.request = {
                            cancel: i
                        }
                    }
                    function o(r, n) {
                        return delete e.request,
                        e.aborted ? i(null) : r && 404 !== r.status ? i(r) : (n && n.resourceTiming && (e.resourceTiming = n.resourceTiming),
                        this.map._refreshExpiredTiles && n && e.setExpiryData(n),
                        e.loadVectorData(n, this.map.painter),
                        t.cacheEntryPossiblyAdded(this.dispatcher),
                        i(null),
                        void (e.reloadCallback && (this.loadTile(e, e.reloadCallback),
                        e.reloadCallback = null)))
                    }
                }
                abortTile(t) {
                    t.request && (t.request.cancel(),
                    delete t.request),
                    t.actor && t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id
                    })
                }
                unloadTile(t) {
                    t.unloadVectorData(),
                    t.actor && t.actor.send("removeTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id
                    })
                }
                hasTransition() {
                    return !1
                }
                afterUpdate() {
                    this._tileWorkers = {}
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                    this._tileJSONRequest = null)
                }
            }
            ,
            raster: Mt,
            "raster-dem": class extends Mt {
                constructor(e, i, r, n) {
                    super(e, i, r, n),
                    this.type = "raster-dem",
                    this.maxzoom = 22,
                    this._options = t.extend({
                        type: "raster-dem"
                    }, i),
                    this.encoding = i.encoding || "mapbox"
                }
                loadTile(e, i) {
                    const r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function n(t, r) {
                        t && (e.state = "errored",
                        i(t)),
                        r && (e.dem = r,
                        e.dem.onDeserialize(),
                        e.needsHillshadePrepare = !0,
                        e.needsDEMTextureUpload = !0,
                        e.state = "loaded",
                        i(null))
                    }
                    e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function(r, o, s, a) {
                        if (delete e.request,
                        e.aborted)
                            e.state = "unloaded",
                            i(null);
                        else if (r)
                            e.state = "errored",
                            i(r);
                        else if (o) {
                            this.map._refreshExpiredTiles && e.setExpiryData({
                                cacheControl: s,
                                expires: a
                            });
                            const i = t.window.ImageBitmap && o instanceof t.window.ImageBitmap && (null == At && (At = t.window.OffscreenCanvas && new t.window.OffscreenCanvas(1,1).getContext("2d") && "function" == typeof t.window.createImageBitmap),
                            At)
                              , r = 1 - (o.width - t.prevPowerOfTwo(o.width)) / 2;
                            r < 1 || e.neighboringTiles || (e.neighboringTiles = this._getNeighboringTiles(e.tileID));
                            const l = i ? o : t.exported.getImageData(o, r)
                              , c = {
                                uid: e.uid,
                                coord: e.tileID,
                                source: this.id,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: r
                            };
                            e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(),
                            e.actor.send("loadDEMTile", c, n.bind(this), void 0, !0))
                        }
                    }
                    .bind(this))
                }
                _getNeighboringTiles(e) {
                    const i = e.canonical
                      , r = Math.pow(2, i.z)
                      , n = (i.x - 1 + r) % r
                      , o = 0 === i.x ? e.wrap - 1 : e.wrap
                      , s = (i.x + 1 + r) % r
                      , a = i.x + 1 === r ? e.wrap + 1 : e.wrap
                      , l = {};
                    return l[new t.OverscaledTileID(e.overscaledZ,o,i.z,n,i.y).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y).key] = {
                        backfilled: !1
                    },
                    i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ,o,i.z,n,i.y - 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y - 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y - 1).key] = {
                        backfilled: !1
                    }),
                    i.y + 1 < r && (l[new t.OverscaledTileID(e.overscaledZ,o,i.z,n,i.y + 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y + 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y + 1).key] = {
                        backfilled: !1
                    }),
                    l
                }
                unloadTile(t) {
                    t.demTexture && this.map.painter.saveTileTexture(t.demTexture),
                    t.fbo && (t.fbo.destroy(),
                    delete t.fbo),
                    t.dem && delete t.dem,
                    delete t.neighboringTiles,
                    t.state = "unloaded"
                }
            }
            ,
            geojson: class extends t.Evented {
                constructor(e, i, r, n) {
                    super(),
                    this.id = e,
                    this.type = "geojson",
                    this.minzoom = 0,
                    this.maxzoom = 18,
                    this.tileSize = 512,
                    this.isTileClipped = !0,
                    this.reparseOverscaled = !0,
                    this._loaded = !1,
                    this.actor = r.getActor(),
                    this.setEventedParent(n),
                    this._data = i.data,
                    this._options = t.extend({}, i),
                    this._collectResourceTiming = i.collectResourceTiming,
                    void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
                    i.type && (this.type = i.type),
                    i.attribution && (this.attribution = i.attribution),
                    this.promoteId = i.promoteId;
                    const o = t.EXTENT / this.tileSize;
                    this.workerOptions = t.extend({
                        source: this.id,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * o,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * o,
                            extent: t.EXTENT,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: t.EXTENT,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * o,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter
                    }, i.workerOptions)
                }
                onAdd(t) {
                    this.map = t,
                    this.setData(this._data)
                }
                setData(t) {
                    return this._data = t,
                    this._updateWorkerData(),
                    this
                }
                getClusterExpansionZoom(t, e) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: t,
                        source: this.id
                    }, e),
                    this
                }
                getClusterChildren(t, e) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: t,
                        source: this.id
                    }, e),
                    this
                }
                getClusterLeaves(t, e, i, r) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        clusterId: t,
                        limit: e,
                        offset: i
                    }, r),
                    this
                }
                _updateWorkerData() {
                    if (this._pendingLoad)
                        return void (this._coalesce = !0);
                    this.fire(new t.Event("dataloading",{
                        dataType: "source"
                    })),
                    this._loaded = !1;
                    const e = t.extend({}, this.workerOptions)
                      , i = this._data;
                    "string" == typeof i ? (e.request = this.map._requestManager.transformRequest(t.exported.resolveURL(i), t.ResourceType.Source),
                    e.request.collectResourceTiming = this._collectResourceTiming) : e.data = JSON.stringify(i),
                    this._pendingLoad = this.actor.send(`${this.type}.loadData`, e, ((e,i)=>{
                        if (this._loaded = !0,
                        this._pendingLoad = null,
                        e)
                            this.fire(new t.ErrorEvent(e));
                        else {
                            const e = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (e.resourceTiming = i.resourceTiming[this.id]),
                            this.fire(new t.Event("data",e)),
                            this._metadataFired = !0
                        }
                        this._coalesce && (this._updateWorkerData(),
                        this._coalesce = !1)
                    }
                    ))
                }
                loaded() {
                    return this._loaded
                }
                loadTile(e, i) {
                    const r = e.actor ? "reloadTile" : "loadTile";
                    e.actor = this.actor,
                    e.request = this.actor.send(r, {
                        type: this.type,
                        uid: e.uid,
                        tileID: e.tileID,
                        tileZoom: e.tileZoom,
                        zoom: e.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        pixelRatio: t.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId
                    }, ((t,n)=>(delete e.request,
                    e.unloadVectorData(),
                    e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(n, this.map.painter, "reloadTile" === r),
                    i(null)))), void 0, "loadTile" === r)
                }
                abortTile(t) {
                    t.request && (t.request.cancel(),
                    delete t.request),
                    t.aborted = !0
                }
                unloadTile(t) {
                    t.unloadVectorData(),
                    this.actor.send("removeTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id
                    })
                }
                onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel()
                }
                serialize() {
                    return t.extend({}, this._options, {
                        type: this.type,
                        data: this._data
                    })
                }
                hasTransition() {
                    return !1
                }
            }
            ,
            video: class extends Ct {
                constructor(t, e, i, r) {
                    super(t, e, i, r),
                    this.roundZoom = !0,
                    this.type = "video",
                    this.options = e
                }
                load() {
                    this._loaded = !1;
                    const e = this.options;
                    this.urls = [];
                    for (const i of e.urls)
                        this.urls.push(this.map._requestManager.transformRequest(i, t.ResourceType.Source).url);
                    t.getVideo(this.urls, ((e,i)=>{
                        this._loaded = !0,
                        e ? this.fire(new t.ErrorEvent(e)) : i && (this.video = i,
                        this.video.loop = !0,
                        this.video.setAttribute("playsinline", ""),
                        this.video.addEventListener("playing", (()=>{
                            this.map.triggerRepaint()
                        }
                        )),
                        this.map && this.video.play(),
                        this._finishLoading())
                    }
                    ))
                }
                pause() {
                    this.video && this.video.pause()
                }
                play() {
                    this.video && this.video.play()
                }
                seek(e) {
                    if (this.video) {
                        const i = this.video.seekable;
                        e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
                    }
                }
                getVideo() {
                    return this.video
                }
                onAdd(t) {
                    this.map || (this.map = t,
                    this.load(),
                    this.video && (this.video.play(),
                    this.setCoordinates(this.coordinates)))
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                        return;
                    const e = this.map.painter.context
                      , i = e.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                    i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e,this.video,i.RGBA),
                    this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                    this.width = this.video.videoWidth,
                    this.height = this.video.videoHeight),
                    this._prepareData(e)
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this.video && !this.video.paused
                }
            }
            ,
            image: Ct,
            canvas: class extends Ct {
                constructor(e, i, r, n) {
                    super(e, i, r, n),
                    i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((t=>!Array.isArray(t) || 2 !== t.length || t.some((t=>"number" != typeof t)))) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "coordinates"'))),
                    i.animate && "boolean" != typeof i.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                    i.canvas ? "string" == typeof i.canvas || i.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "canvas"'))),
                    this.options = i,
                    this.animate = void 0 === i.animate || i.animate
                }
                load() {
                    this._loaded = !0,
                    this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)),
                    this.width = this.canvas.width,
                    this.height = this.canvas.height,
                    this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0,
                        this.map.triggerRepaint()
                    }
                    ,
                    this.pause = function() {
                        this._playing && (this.prepare(),
                        this._playing = !1)
                    }
                    ,
                    this._finishLoading())
                }
                getCanvas() {
                    return this.canvas
                }
                onAdd(t) {
                    this.map = t,
                    this.load(),
                    this.canvas && this.animate && this.play()
                }
                onRemove() {
                    this.pause()
                }
                prepare() {
                    let e = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                    e = !0),
                    this.canvas.height !== this.height && (this.height = this.canvas.height,
                    e = !0),
                    this._hasInvalidDimensions())
                        return;
                    if (0 === Object.keys(this.tiles).length)
                        return;
                    const i = this.map.painter.context;
                    this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new t.Texture(i,this.canvas,i.gl.RGBA,{
                        premultiply: !0
                    }),
                    this._prepareData(i)
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this._playing
                }
                _hasInvalidDimensions() {
                    for (const t of [this.canvas.width, this.canvas.height])
                        if (isNaN(t) || t <= 0)
                            return !0;
                    return !1
                }
            }
            ,
            custom: class extends t.Evented {
                constructor(e, i, r, n) {
                    super(),
                    this.id = e,
                    this.type = "custom",
                    this._dataType = "raster",
                    this._dispatcher = r,
                    this._implementation = i,
                    this.setEventedParent(n),
                    this.scheme = "xyz",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.tileSize = 512,
                    this._loaded = !1,
                    this.roundZoom = !0,
                    this._implementation || this.fire(new t.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))),
                    this._implementation.loadTile || this.fire(new t.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))),
                    this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds,this.minzoom,this.maxzoom)),
                    i.update = this._update.bind(this),
                    i.clearTiles = this._clearTiles.bind(this),
                    i.coveringTiles = this._coveringTiles.bind(this),
                    t.extend(this, t.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]))
                }
                serialize() {
                    return t.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                }
                load() {
                    this._loaded = !0,
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "metadata"
                    })),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    }))
                }
                loaded() {
                    return this._loaded
                }
                onAdd(e) {
                    this._map = e,
                    this._loaded = !1,
                    this.fire(new t.Event("dataloading",{
                        dataType: "source"
                    })),
                    this._implementation.onAdd && this._implementation.onAdd(e),
                    this.load()
                }
                onRemove(t) {
                    this._implementation.onRemove && this._implementation.onRemove(t)
                }
                hasTile(t) {
                    if (this._implementation.hasTile) {
                        const {x: e, y: i, z: r} = t.canonical;
                        return this._implementation.hasTile({
                            x: e,
                            y: i,
                            z: r
                        })
                    }
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }
                loadTile(e, i) {
                    const {x: r, y: n, z: o} = e.tileID.canonical
                      , s = new t.window.AbortController;
                    e.request = Promise.resolve(this._implementation.loadTile({
                        x: r,
                        y: n,
                        z: o
                    }, {
                        signal: s.signal
                    })).then(function(r) {
                        return delete e.request,
                        e.aborted ? (e.state = "unloaded",
                        i(null)) : void 0 === r ? (e.state = "errored",
                        i(null)) : null === r ? (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }),
                        e.state = "loaded",
                        i(null)) : (n = r)instanceof t.window.ImageData || n instanceof t.window.HTMLCanvasElement || n instanceof t.window.ImageBitmap || n instanceof t.window.HTMLImageElement ? (this.loadTileData(e, r),
                        e.state = "loaded",
                        void i(null)) : (e.state = "errored",
                        i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                        var n
                    }
                    .bind(this)).catch((t=>{
                        20 !== t.code && (e.state = "errored",
                        i(t))
                    }
                    )),
                    e.request.cancel = ()=>s.abort()
                }
                loadTileData(t, e) {
                    Mt.loadTileData(t, e, this._map.painter)
                }
                unloadTileData(t) {
                    Mt.unloadTileData(t, this._map.painter)
                }
                unloadTile(t, e) {
                    if (this.unloadTileData(t),
                    this._implementation.unloadTile) {
                        const {x: e, y: i, z: r} = t.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: r
                        })
                    }
                    e()
                }
                abortTile(t, e) {
                    t.request && t.request.cancel && (t.request.cancel(),
                    delete t.request),
                    e()
                }
                hasTransition() {
                    return !1
                }
                _coveringTiles() {
                    return this._map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((t=>({
                        x: t.canonical.x,
                        y: t.canonical.y,
                        z: t.canonical.z
                    })))
                }
                _clearTiles() {
                    this._map.style._clearSource(this.id)
                }
                _update() {
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    }))
                }
            }
        }
          , kt = function(e, i, r, n) {
            const o = new Dt[i.type](e,i,r,n);
            if (o.id !== e)
                throw new Error(`Expected Source id to be ${e} instead of ${o.id}`);
            return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], o),
            o
        };
        function Pt(e, i) {
            const r = t.identity([]);
            return t.scale(r, r, [.5 * e.width, .5 * -e.height, 1]),
            t.translate(r, r, [1, -1, 0]),
            t.multiply(r, r, e.calculateProjMatrix(i.toUnwrapped())),
            Float32Array.from(r)
        }
        function Lt(t, e, i, r, n, o, s, a=!1) {
            const l = t.tilesIn(r, s, a);
            l.sort(Rt);
            const c = [];
            for (const r of l)
                c.push({
                    wrappedTileID: r.tile.tileID.wrapped().key,
                    queryResults: r.tile.queryRenderedFeatures(e, i, t._state, r, n, o, Pt(t.transform, r.tile.tileID), a)
                });
            const u = function(t) {
                const e = {}
                  , i = {};
                for (const r of t) {
                    const t = r.queryResults
                      , n = r.wrappedTileID
                      , o = i[n] = i[n] || {};
                    for (const i in t) {
                        const r = t[i]
                          , n = o[i] = o[i] || {}
                          , s = e[i] = e[i] || [];
                        for (const t of r)
                            n[t.featureIndex] || (n[t.featureIndex] = !0,
                            s.push(t))
                    }
                }
                return e
            }(c);
            for (const e in u)
                u[e].forEach((e=>{
                    const i = e.feature
                      , r = i.layer;
                    r && "background" !== r.type && "sky" !== r.type && (i.source = r.source,
                    r["source-layer"] && (i.sourceLayer = r["source-layer"]),
                    i.state = void 0 !== i.id ? t.getFeatureState(r["source-layer"], i.id) : {})
                }
                ));
            return u
        }
        function Ot(t, e) {
            const i = t.getRenderableIds().map((e=>t.getTileByID(e)))
              , r = []
              , n = {};
            for (let t = 0; t < i.length; t++) {
                const o = i[t]
                  , s = o.tileID.canonical.key;
                n[s] || (n[s] = !0,
                o.querySourceFeatures(r, e))
            }
            return r
        }
        function Rt(t, e) {
            const i = t.tileID
              , r = e.tileID;
            return i.overscaledZ - r.overscaledZ || i.canonical.y - r.canonical.y || i.wrap - r.wrap || i.canonical.x - r.canonical.x
        }
        function Bt() {
            return null != ho.workerClass ? new ho.workerClass : new t.window.Worker(ho.workerUrl)
        }
        const Ft = "mapboxgl_preloaded_worker_pool";
        class Ut {
            constructor() {
                this.active = {}
            }
            acquire(t) {
                if (!this.workers)
                    for (this.workers = []; this.workers.length < Ut.workerCount; )
                        this.workers.push(new Bt);
                return this.active[t] = !0,
                this.workers.slice()
            }
            release(t) {
                delete this.active[t],
                0 === this.numActive() && (this.workers.forEach((t=>{
                    t.terminate()
                }
                )),
                this.workers = null)
            }
            isPreloaded() {
                return !!this.active[Ft]
            }
            numActive() {
                return Object.keys(this.active).length
            }
        }
        let Nt;
        function Gt() {
            return Nt || (Nt = new Ut),
            Nt
        }
        function jt(e, i) {
            const r = {};
            for (const t in e)
                "ref" !== t && (r[t] = e[t]);
            return t.refProperties.forEach((t=>{
                t in i && (r[t] = i[t])
            }
            )),
            r
        }
        function Vt(t) {
            t = t.slice();
            const e = Object.create(null);
            for (let i = 0; i < t.length; i++)
                e[t[i].id] = t[i];
            for (let i = 0; i < t.length; i++)
                "ref"in t[i] && (t[i] = jt(t[i], e[t[i].ref]));
            return t
        }
        Ut.workerCount = 2;
        const Zt = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setProjection: "setProjection"
        };
        function Jt(t, e, i) {
            i.push({
                command: Zt.addSource,
                args: [t, e[t]]
            })
        }
        function Xt(t, e, i) {
            e.push({
                command: Zt.removeSource,
                args: [t]
            }),
            i[t] = !0
        }
        function qt(t, e, i, r) {
            Xt(t, i, r),
            Jt(t, e, i)
        }
        function $t(t, i, r) {
            let n;
            for (n in t[r])
                if (t[r].hasOwnProperty(n) && "data" !== n && !e(t[r][n], i[r][n]))
                    return !1;
            for (n in i[r])
                if (i[r].hasOwnProperty(n) && "data" !== n && !e(t[r][n], i[r][n]))
                    return !1;
            return !0
        }
        function Yt(t, i, r, n, o, s) {
            let a;
            for (a in i = i || {},
            t = t || {})
                t.hasOwnProperty(a) && (e(t[a], i[a]) || r.push({
                    command: s,
                    args: [n, a, i[a], o]
                }));
            for (a in i)
                i.hasOwnProperty(a) && !t.hasOwnProperty(a) && (e(t[a], i[a]) || r.push({
                    command: s,
                    args: [n, a, i[a], o]
                }))
        }
        function Wt(t) {
            return t.id
        }
        function Ht(t, e) {
            return t[e.id] = e,
            t
        }
        class Kt {
            constructor(t, e) {
                this.reset(t, e)
            }
            reset(t, e) {
                this.points = t || [],
                this._distances = [0];
                for (let t = 1; t < this.points.length; t++)
                    this._distances[t] = this._distances[t - 1] + this.points[t].dist(this.points[t - 1]);
                this.length = this._distances[this._distances.length - 1],
                this.padding = Math.min(e || 0, .5 * this.length),
                this.paddedLength = this.length - 2 * this.padding
            }
            lerp(e) {
                if (1 === this.points.length)
                    return this.points[0];
                e = t.clamp(e, 0, 1);
                let i = 1
                  , r = this._distances[i];
                const n = e * this.paddedLength + this.padding;
                for (; r < n && i < this._distances.length; )
                    r = this._distances[++i];
                const o = i - 1
                  , s = this._distances[o]
                  , a = r - s
                  , l = a > 0 ? (n - s) / a : 0;
                return this.points[o].mult(1 - l).add(this.points[i].mult(l))
            }
        }
        class Qt {
            constructor(t, e, i) {
                const r = this.boxCells = []
                  , n = this.circleCells = [];
                this.xCellCount = Math.ceil(t / i),
                this.yCellCount = Math.ceil(e / i);
                for (let t = 0; t < this.xCellCount * this.yCellCount; t++)
                    r.push([]),
                    n.push([]);
                this.circleKeys = [],
                this.boxKeys = [],
                this.bboxes = [],
                this.circles = [],
                this.width = t,
                this.height = e,
                this.xScale = this.xCellCount / t,
                this.yScale = this.yCellCount / e,
                this.boxUid = 0,
                this.circleUid = 0
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length
            }
            insert(t, e, i, r, n) {
                this._forEachCell(e, i, r, n, this._insertBoxCell, this.boxUid++),
                this.boxKeys.push(t),
                this.bboxes.push(e),
                this.bboxes.push(i),
                this.bboxes.push(r),
                this.bboxes.push(n)
            }
            insertCircle(t, e, i, r) {
                this._forEachCell(e - r, i - r, e + r, i + r, this._insertCircleCell, this.circleUid++),
                this.circleKeys.push(t),
                this.circles.push(e),
                this.circles.push(i),
                this.circles.push(r)
            }
            _insertBoxCell(t, e, i, r, n, o) {
                this.boxCells[n].push(o)
            }
            _insertCircleCell(t, e, i, r, n, o) {
                this.circleCells[n].push(o)
            }
            _query(t, e, i, r, n, o) {
                if (i < 0 || t > this.width || r < 0 || e > this.height)
                    return !n && [];
                const s = [];
                if (t <= 0 && e <= 0 && this.width <= i && this.height <= r) {
                    if (n)
                        return !0;
                    for (let t = 0; t < this.boxKeys.length; t++)
                        s.push({
                            key: this.boxKeys[t],
                            x1: this.bboxes[4 * t],
                            y1: this.bboxes[4 * t + 1],
                            x2: this.bboxes[4 * t + 2],
                            y2: this.bboxes[4 * t + 3]
                        });
                    for (let t = 0; t < this.circleKeys.length; t++) {
                        const e = this.circles[3 * t]
                          , i = this.circles[3 * t + 1]
                          , r = this.circles[3 * t + 2];
                        s.push({
                            key: this.circleKeys[t],
                            x1: e - r,
                            y1: i - r,
                            x2: e + r,
                            y2: i + r
                        })
                    }
                    return o ? s.filter(o) : s
                }
                return this._forEachCell(t, e, i, r, this._queryCell, s, {
                    hitTest: n,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, o),
                n ? s.length > 0 : s
            }
            _queryCircle(t, e, i, r, n) {
                const o = t - i
                  , s = t + i
                  , a = e - i
                  , l = e + i;
                if (s < 0 || o > this.width || l < 0 || a > this.height)
                    return !r && [];
                const c = [];
                return this._forEachCell(o, a, s, l, this._queryCellCircle, c, {
                    hitTest: r,
                    circle: {
                        x: t,
                        y: e,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, n),
                r ? c.length > 0 : c
            }
            query(t, e, i, r, n) {
                return this._query(t, e, i, r, !1, n)
            }
            hitTest(t, e, i, r, n) {
                return this._query(t, e, i, r, !0, n)
            }
            hitTestCircle(t, e, i, r) {
                return this._queryCircle(t, e, i, !0, r)
            }
            _queryCell(t, e, i, r, n, o, s, a) {
                const l = s.seenUids
                  , c = this.boxCells[n];
                if (null !== c) {
                    const n = this.bboxes;
                    for (const u of c)
                        if (!l.box[u]) {
                            l.box[u] = !0;
                            const c = 4 * u;
                            if (t <= n[c + 2] && e <= n[c + 3] && i >= n[c + 0] && r >= n[c + 1] && (!a || a(this.boxKeys[u]))) {
                                if (s.hitTest)
                                    return o.push(!0),
                                    !0;
                                o.push({
                                    key: this.boxKeys[u],
                                    x1: n[c],
                                    y1: n[c + 1],
                                    x2: n[c + 2],
                                    y2: n[c + 3]
                                })
                            }
                        }
                }
                const u = this.circleCells[n];
                if (null !== u) {
                    const n = this.circles;
                    for (const c of u)
                        if (!l.circle[c]) {
                            l.circle[c] = !0;
                            const u = 3 * c;
                            if (this._circleAndRectCollide(n[u], n[u + 1], n[u + 2], t, e, i, r) && (!a || a(this.circleKeys[c]))) {
                                if (s.hitTest)
                                    return o.push(!0),
                                    !0;
                                {
                                    const t = n[u]
                                      , e = n[u + 1]
                                      , i = n[u + 2];
                                    o.push({
                                        key: this.circleKeys[c],
                                        x1: t - i,
                                        y1: e - i,
                                        x2: t + i,
                                        y2: e + i
                                    })
                                }
                            }
                        }
                }
            }
            _queryCellCircle(t, e, i, r, n, o, s, a) {
                const l = s.circle
                  , c = s.seenUids
                  , u = this.boxCells[n];
                if (null !== u) {
                    const t = this.bboxes;
                    for (const e of u)
                        if (!c.box[e]) {
                            c.box[e] = !0;
                            const i = 4 * e;
                            if (this._circleAndRectCollide(l.x, l.y, l.radius, t[i + 0], t[i + 1], t[i + 2], t[i + 3]) && (!a || a(this.boxKeys[e])))
                                return o.push(!0),
                                !0
                        }
                }
                const h = this.circleCells[n];
                if (null !== h) {
                    const t = this.circles;
                    for (const e of h)
                        if (!c.circle[e]) {
                            c.circle[e] = !0;
                            const i = 3 * e;
                            if (this._circlesCollide(t[i], t[i + 1], t[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[e])))
                                return o.push(!0),
                                !0
                        }
                }
            }
            _forEachCell(t, e, i, r, n, o, s, a) {
                const l = this._convertToXCellCoord(t)
                  , c = this._convertToYCellCoord(e)
                  , u = this._convertToXCellCoord(i)
                  , h = this._convertToYCellCoord(r);
                for (let d = l; d <= u; d++)
                    for (let l = c; l <= h; l++)
                        if (n.call(this, t, e, i, r, this.xCellCount * l + d, o, s, a))
                            return
            }
            _convertToXCellCoord(t) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)))
            }
            _convertToYCellCoord(t) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)))
            }
            _circlesCollide(t, e, i, r, n, o) {
                const s = r - t
                  , a = n - e
                  , l = i + o;
                return l * l > s * s + a * a
            }
            _circleAndRectCollide(t, e, i, r, n, o, s) {
                const a = (o - r) / 2
                  , l = Math.abs(t - (r + a));
                if (l > a + i)
                    return !1;
                const c = (s - n) / 2
                  , u = Math.abs(e - (n + c));
                if (u > c + i)
                    return !1;
                if (l <= a || u <= c)
                    return !0;
                const h = l - a
                  , d = u - c;
                return h * h + d * d <= i * i
            }
        }
        const te = Math.tan(85 * Math.PI / 180);
        function ee(e, i, r, n, o, s, a) {
            const l = t.create();
            if (r)
                if ("globe" === s.name) {
                    const e = t.calculateGlobeLabelMatrix(o, i);
                    t.multiply(l, l, e)
                } else {
                    const e = y([], a);
                    l[0] = e[0],
                    l[1] = e[1],
                    l[4] = e[2],
                    l[5] = e[3],
                    n || t.rotateZ(l, l, o.angle)
                }
            else
                t.multiply(l, o.labelPlaneMatrix, e);
            return l
        }
        function ie(t, e, i, r, n, o, s) {
            const a = ee(t, e, i, r, n, o, s);
            return "globe" === o.name && i || (a[2] = a[6] = a[10] = a[14] = 0),
            a
        }
        function re(e, i, r, n, o, s, a) {
            if (r) {
                if ("globe" === s.name) {
                    const l = ee(e, i, r, n, o, s, a);
                    return t.invert(l, l),
                    t.multiply(l, e, l),
                    l
                }
                {
                    const i = t.clone(e)
                      , r = t.identity([]);
                    return r[0] = a[0],
                    r[1] = a[1],
                    r[4] = a[2],
                    r[5] = a[3],
                    t.multiply(i, i, r),
                    n || t.rotateZ(i, i, -o.angle),
                    i
                }
            }
            return o.glCoordMatrix
        }
        function ne(e, i, r, n) {
            const o = [e, i, r, 1];
            r ? t.transformMat4$1(o, o, n) : fe(o, o, n);
            const s = o[3];
            return o[0] /= s,
            o[1] /= s,
            o[2] /= s,
            o
        }
        function oe(t, e) {
            return Math.min(.5 + t / e * .5, 1.5)
        }
        function se(t, e) {
            const i = t[0] / t[3]
              , r = t[1] / t[3];
            return i >= -e[0] && i <= e[0] && r >= -e[1] && r <= e[1]
        }
        function ae(e, i, r, n, o, s, a, l, c, u) {
            const h = r.transform
              , d = n ? e.textSizeData : e.iconSizeData
              , p = t.evaluateSizeForZoom(d, r.transform.zoom)
              , m = "globe" === h.projection.name
              , f = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1]
              , _ = n ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
            _.clear();
            let g = null;
            m && (g = n ? e.text.globeExtVertexArray : e.icon.globeExtVertexArray);
            const y = e.lineVertexArray
              , x = n ? e.text.placedSymbolArray : e.icon.placedSymbolArray
              , v = r.transform.width / r.transform.height;
            let b, w = !1;
            for (let n = 0; n < x.length; n++) {
                const m = x.get(n)
                  , {numGlyphs: z, writingMode: T} = m;
                if (T !== t.WritingMode.vertical || w || b === t.WritingMode.horizontal || (w = !0),
                b = T,
                (m.hidden || T === t.WritingMode.vertical) && !w) {
                    me(z, _);
                    continue
                }
                w = !1;
                const E = new t.pointGeometry(m.tileAnchorX,m.tileAnchorY);
                let {x: S, y: M, z: A} = h.projection.projectTilePoint(E.x, E.y, u.canonical);
                if (c) {
                    const [t,e,i] = c(E);
                    S += t,
                    M += e,
                    A += i
                }
                const I = [S, M, A, 1];
                if (t.transformMat4$1(I, I, i),
                !se(I, f)) {
                    me(z, _);
                    continue
                }
                const C = oe(r.transform.cameraToCenterDistance, I[3])
                  , D = t.evaluateSizeForFeature(d, p, m)
                  , k = a ? D / C : D * C
                  , P = ne(S, M, A, o);
                if (P[3] <= 0) {
                    me(z, _);
                    continue
                }
                let L = {};
                const O = a ? null : c
                  , R = ue(m, k, !1, l, i, o, s, e.glyphOffsetArray, y, _, g, P, E, L, v, O, h.projection, u, a);
                w = R.useVertical,
                O && R.needsFlipping && (L = {}),
                (R.notEnoughRoom || w || R.needsFlipping && ue(m, k, !0, l, i, o, s, e.glyphOffsetArray, y, _, g, P, E, L, v, O, h.projection, u, a).notEnoughRoom) && me(z, _)
            }
            n ? (e.text.dynamicLayoutVertexBuffer.updateData(_),
            g && e.text.globeExtVertexBuffer.updateData(g)) : (e.icon.dynamicLayoutVertexBuffer.updateData(_),
            g && e.icon.globeExtVertexBuffer.updateData(g))
        }
        function le(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f) {
            const {lineStartIndex: _, glyphStartIndex: g, segment: y} = a
              , x = g + a.numGlyphs
              , v = _ + a.lineLength
              , b = e.getoffsetX(g)
              , w = e.getoffsetX(x - 1)
              , z = pe(t * b, i, r, n, o, s, y, _, v, l, c, u, h, d, !0, p, m, f);
            if (!z)
                return null;
            const T = pe(t * w, i, r, n, o, s, y, _, v, l, c, u, h, d, !0, p, m, f);
            return T ? {
                first: z,
                last: T
            } : null
        }
        function ce(e, i, r, n) {
            return e === t.WritingMode.horizontal && Math.abs(n) > Math.abs(r) ? {
                useVertical: !0
            } : e === t.WritingMode.vertical ? n > 0 ? {
                needsFlipping: !0
            } : null : 0 !== i && (s = n,
            0 === (o = r) || Math.abs(s / o) > te) ? 1 === i ? {
                needsFlipping: !0
            } : null : r < 0 ? {
                needsFlipping: !0
            } : null;
            var o, s
        }
        function ue(e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y, x) {
            const v = i / 24
              , b = e.lineOffsetX * v
              , w = e.lineOffsetY * v
              , {lineStartIndex: z, glyphStartIndex: T, numGlyphs: E, segment: S, writingMode: M, flipState: A} = e
              , I = z + e.lineLength
              , C = e=>{
                if (h) {
                    const [i,r,n] = e.up
                      , o = u.length;
                    t.updateGlobeVertexNormal(h, o + 0, i, r, n),
                    t.updateGlobeVertexNormal(h, o + 1, i, r, n),
                    t.updateGlobeVertexNormal(h, o + 2, i, r, n),
                    t.updateGlobeVertexNormal(h, o + 3, i, r, n)
                }
                const [i,r,n] = e.point;
                t.addDynamicAttributes(u, i, r, n, e.angle)
            }
            ;
            if (E > 1) {
                const t = le(v, l, b, w, r, d, p, e, c, s, m, _, !1, g, y, x);
                if (!t)
                    return {
                        notEnoughRoom: !0
                    };
                if (n && !r) {
                    let[i,r,n] = t.first.point
                      , [o,s,l] = t.last.point;
                    [i,r] = ne(i, r, n, a),
                    [o,s] = ne(o, s, l, a);
                    const c = ce(M, A, (o - i) * f, s - r);
                    if (e.flipState = c && c.needsFlipping ? 1 : 2,
                    c)
                        return c
                }
                C(t.first);
                for (let t = T + 1; t < T + E - 1; t++) {
                    const e = pe(v * l.getoffsetX(t), b, w, r, d, p, S, z, I, c, s, m, _, !1, !1, g, y, x);
                    if (!e)
                        return u.length -= 4 * (t - T),
                        {
                            notEnoughRoom: !0
                        };
                    C(e)
                }
                C(t.last)
            } else {
                if (n && !r) {
                    const i = ne(p.x, p.y, 0, o)
                      , r = z + S + 1
                      , n = new t.pointGeometry(c.getx(r),c.gety(r))
                      , s = ne(n.x, n.y, 0, o)
                      , a = s[3] > 0 ? s : de(p, n, i, 1, o, void 0, g, y.canonical)
                      , l = ce(M, A, (a[0] - i[0]) * f, a[1] - i[1]);
                    if (e.flipState = l && l.needsFlipping ? 1 : 2,
                    l)
                        return l
                }
                const i = pe(v * l.getoffsetX(T), b, w, r, d, p, S, z, I, c, s, m, _, !1, !1, g, y, x);
                if (!i)
                    return {
                        notEnoughRoom: !0
                    };
                C(i)
            }
            return {}
        }
        function he(t, e, i, r, n) {
            const {x: o, y: s, z: a} = r.projectTilePoint(t.x, t.y, e);
            if (!n)
                return ne(o, s, a, i);
            const [l,c,u] = n(t);
            return ne(o + l, s + c, a + u, i)
        }
        function de(e, i, r, n, o, s, a, l) {
            const c = he(e.sub(i)._unit()._add(e), l, o, a, s);
            return t.sub(c, r, c),
            t.normalize(c, c),
            t.scaleAndAdd(c, r, c, n)
        }
        function pe(e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g, y) {
            const x = n ? e - i : e + i;
            let v = x > 0 ? 1 : -1
              , b = 0;
            n && (v *= -1,
            b = Math.PI),
            v < 0 && (b += Math.PI);
            let w = l + a + (v > 0 ? 0 : 1) | 0
              , z = o
              , T = o
              , E = 0
              , S = 0;
            const M = Math.abs(x)
              , A = []
              , I = [];
            let C = s
              , D = C;
            const k = ()=>de(D, C, T, M - E + 1, h, p, _, g.canonical);
            for (; E + S <= M; ) {
                if (w += v,
                w < l || w >= c)
                    return null;
                if (T = z,
                D = C,
                A.push(T),
                m && I.push(D),
                C = new t.pointGeometry(u.getx(w),u.gety(w)),
                z = d[w],
                !z) {
                    const t = he(C, g.canonical, h, _, p);
                    z = t[3] > 0 ? d[w] = t : k()
                }
                E += S,
                S = t.distance(T, z)
            }
            f && p && (d[w] && (z = k(),
            S = t.distance(T, z)),
            d[w] = z);
            const P = (M - E) / S
              , L = C.sub(D)._mult(P)._add(D)
              , O = t.sub([], z, T)
              , R = t.scaleAndAdd([], T, O, P);
            let B = [0, 0, 1]
              , F = O[0]
              , U = O[1];
            if (y && (B = _.upVector(g.canonical, L.x, L.y),
            0 !== B[0] || 0 !== B[1] || 1 !== B[2])) {
                const e = [B[2], 0, -B[0]]
                  , i = t.cross([], B, e);
                t.normalize(e, e),
                t.normalize(i, i),
                F = t.dot(O, e),
                U = t.dot(O, i)
            }
            if (r) {
                const e = t.cross([], B, O);
                t.normalize(e, e),
                t.scaleAndAdd(R, R, e, r * v)
            }
            const N = b + Math.atan2(U, F);
            return A.push(R),
            m && I.push(L),
            {
                point: R,
                angle: N,
                path: A,
                tilePath: I,
                up: B
            }
        }
        function me(t, e) {
            const i = e.length
              , r = i + 4 * t;
            e.resize(r),
            e.float32.fill(-1 / 0, 4 * i, 4 * r)
        }
        function fe(t, e, i) {
            const r = e[0]
              , n = e[1];
            return t[0] = i[0] * r + i[4] * n + i[12],
            t[1] = i[1] * r + i[5] * n + i[13],
            t[3] = i[3] * r + i[7] * n + i[15],
            t
        }
        const _e = 100;
        class ge {
            constructor(t, e, i=new Qt(t.width + 200,t.height + 200,25), r=new Qt(t.width + 200,t.height + 200,25)) {
                this.transform = t,
                this.grid = i,
                this.ignoredGrid = r,
                this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance,
                this.screenRightBoundary = t.width + _e,
                this.screenBottomBoundary = t.height + _e,
                this.gridRightBoundary = t.width + 200,
                this.gridBottomBoundary = t.height + 200,
                this.fogState = e
            }
            placeCollisionBox(t, e, i, r, n, o, s, a) {
                let l = i.projectedAnchorX
                  , c = i.projectedAnchorY
                  , u = i.projectedAnchorZ;
                const h = i.elevation
                  , d = i.tileID
                  , p = t.getProjection();
                if (h && d) {
                    const [t,e,r] = p.upVector(d.canonical, i.tileAnchorX, i.tileAnchorY)
                      , n = p.upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += t * h * n,
                    c += e * h * n,
                    u += r * h * n
                }
                const m = this.projectAndGetPerspectiveRatio(s, l, c, u, i.tileID, "globe" === p.name || !!h || this.transform.pitch > 0, p)
                  , f = o * m.perspectiveRatio
                  , _ = (i.x1 * e + r.x - i.padding) * f + m.point.x
                  , g = (i.y1 * e + r.y - i.padding) * f + m.point.y
                  , y = (i.x2 * e + r.x + i.padding) * f + m.point.x
                  , x = (i.y2 * e + r.y + i.padding) * f + m.point.y
                  , v = m.perspectiveRatio <= .55 || m.occluded;
                return !this.isInsideGrid(_, g, y, x) || !n && this.grid.hitTest(_, g, y, x, a) || v ? {
                    box: [],
                    offscreen: !1,
                    occluded: m.occluded
                } : {
                    box: [_, g, y, x],
                    offscreen: this.isOffscreen(_, g, y, x),
                    occluded: !1
                }
            }
            placeCollisionCircles(e, i, r, n, o, s, a, l, c, u, h, d, p, m, f) {
                const _ = []
                  , g = this.transform.elevation
                  , y = e.getProjection()
                  , x = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, y) : null
                  , v = new t.pointGeometry(r.tileAnchorX,r.tileAnchorY);
                let {x: b, y: w, z: z} = y.projectTilePoint(v.x, v.y, f.canonical);
                if (x) {
                    const [t,e,i] = x(v);
                    b += t,
                    w += e,
                    z += i
                }
                const T = "globe" === y.name
                  , E = this.projectAndGetPerspectiveRatio(a, b, w, z, f, T || !!g || this.transform.pitch > 0, y)
                  , {perspectiveRatio: S} = E
                  , M = (h ? s / S : s * S) / t.ONE_EM
                  , A = ne(b, w, z, l)
                  , I = E.signedDistanceFromCamera > 0 ? le(M, o, r.lineOffsetX * M, r.lineOffsetY * M, !1, A, v, r, n, l, {}, g && !h ? x : null, h && !!g, y, f, h) : null;
                let C = !1
                  , D = !1
                  , k = !0;
                if (I && !E.occluded) {
                    const e = .5 * p * S + m
                      , r = new t.pointGeometry(-100,-100)
                      , n = new t.pointGeometry(this.screenRightBoundary,this.screenBottomBoundary)
                      , o = new Kt
                      , {first: s, last: a} = I
                      , l = s.path.length;
                    let h = [];
                    for (let t = l - 1; t >= 1; t--)
                        h.push(s.path[t]);
                    for (let t = 1; t < a.path.length; t++)
                        h.push(a.path[t]);
                    const f = 2.5 * e;
                    c && (h = h.map((([t,e,i],r)=>(x && !T && (i = x(r < l - 1 ? s.tilePath[l - 1 - r] : a.tilePath[r - l + 2])[2]),
                    ne(t, e, i, c)))),
                    h.some((t=>t[3] <= 0)) && (h = []));
                    let g = [];
                    if (h.length > 0) {
                        let e = 1 / 0
                          , i = -1 / 0
                          , o = 1 / 0
                          , s = -1 / 0;
                        for (const t of h)
                            e = Math.min(e, t[0]),
                            o = Math.min(o, t[1]),
                            i = Math.max(i, t[0]),
                            s = Math.max(s, t[1]);
                        i >= r.x && e <= n.x && s >= r.y && o <= n.y && (g = [h.map((e=>new t.pointGeometry(e[0],e[1])))],
                        (e < r.x || i > n.x || o < r.y || s > n.y) && (g = t.clipLine(g, r.x, r.y, n.x, n.y)))
                    }
                    for (const t of g) {
                        o.reset(t, .25 * e);
                        let r = 0;
                        r = o.length <= .5 * e ? 1 : Math.ceil(o.paddedLength / f) + 1;
                        for (let t = 0; t < r; t++) {
                            const n = t / Math.max(r - 1, 1)
                              , s = o.lerp(n)
                              , a = s.x + _e
                              , l = s.y + _e;
                            _.push(a, l, e, 0);
                            const c = a - e
                              , h = l - e
                              , p = a + e
                              , m = l + e;
                            if (k = k && this.isOffscreen(c, h, p, m),
                            D = D || this.isInsideGrid(c, h, p, m),
                            !i && this.grid.hitTestCircle(a, l, e, d) && (C = !0,
                            !u))
                                return {
                                    circles: [],
                                    offscreen: !1,
                                    collisionDetected: C,
                                    occluded: !1
                                }
                        }
                    }
                }
                return {
                    circles: !u && C || !D ? [] : _,
                    offscreen: k,
                    collisionDetected: C,
                    occluded: E.occluded
                }
            }
            queryRenderedSymbols(e) {
                if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                    return {};
                const i = [];
                let r = 1 / 0
                  , n = 1 / 0
                  , o = -1 / 0
                  , s = -1 / 0;
                for (const a of e) {
                    const e = new t.pointGeometry(a.x + _e,a.y + _e);
                    r = Math.min(r, e.x),
                    n = Math.min(n, e.y),
                    o = Math.max(o, e.x),
                    s = Math.max(s, e.y),
                    i.push(e)
                }
                const a = this.grid.query(r, n, o, s).concat(this.ignoredGrid.query(r, n, o, s))
                  , l = {}
                  , c = {};
                for (const e of a) {
                    const r = e.key;
                    if (void 0 === l[r.bucketInstanceId] && (l[r.bucketInstanceId] = {}),
                    l[r.bucketInstanceId][r.featureIndex])
                        continue;
                    const n = [new t.pointGeometry(e.x1,e.y1), new t.pointGeometry(e.x2,e.y1), new t.pointGeometry(e.x2,e.y2), new t.pointGeometry(e.x1,e.y2)];
                    t.polygonIntersectsPolygon(i, n) && (l[r.bucketInstanceId][r.featureIndex] = !0,
                    void 0 === c[r.bucketInstanceId] && (c[r.bucketInstanceId] = []),
                    c[r.bucketInstanceId].push(r.featureIndex))
                }
                return c
            }
            insertCollisionBox(t, e, i, r, n) {
                (e ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: n
                }, t[0], t[1], t[2], t[3])
            }
            insertCollisionCircles(t, e, i, r, n) {
                const o = e ? this.ignoredGrid : this.grid
                  , s = {
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: n
                };
                for (let e = 0; e < t.length; e += 4)
                    o.insertCircle(s, t[e], t[e + 1], t[e + 2])
            }
            projectAndGetPerspectiveRatio(e, i, r, n, o, s, a) {
                const l = [i, r, n, 1];
                let c = !1;
                if (n || this.transform.pitch > 0) {
                    t.transformMat4$1(l, l, e);
                    const s = "globe" === a.name;
                    if (this.fogState && o && !s) {
                        c = function(e, i, r, n, o, s) {
                            const a = s.calculateFogTileMatrix(o)
                              , l = [i, r, n];
                            return t.transformMat4(l, l, a),
                            M(e, l, s.pitch, s._fov)
                        }(this.fogState, i, r, n, o.toUnwrapped(), this.transform) > .9
                    }
                } else
                    fe(l, l, e);
                const u = l[3];
                return {
                    point: new t.pointGeometry((l[0] / u + 1) / 2 * this.transform.width + _e,(-l[1] / u + 1) / 2 * this.transform.height + _e),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / u * .5, 1.5),
                    signedDistanceFromCamera: u,
                    occluded: s && l[2] > u || c
                }
            }
            isOffscreen(t, e, i, r) {
                return i < _e || t >= this.screenRightBoundary || r < _e || e > this.screenBottomBoundary
            }
            isInsideGrid(t, e, i, r) {
                return i >= 0 && t < this.gridRightBoundary && r >= 0 && e < this.gridBottomBoundary
            }
            getViewportMatrix() {
                const e = t.identity([]);
                return t.translate(e, e, [-100, -100, 0]),
                e
            }
        }
        function ye(e, i, r) {
            const n = i.createTileMatrix(e, e.worldSize, r.toUnwrapped());
            return t.multiply(new Float32Array(16), e.projMatrix, n)
        }
        function xe(t, e, i) {
            if (e.projection.name === i.projection.name)
                return t.projMatrix;
            const r = i.clone();
            return r.setProjection(e.projection),
            ye(r, e.getProjection(), t)
        }
        function ve(t, e, i) {
            return e.name === i.projection.name ? t.projMatrix : ye(i, e, t)
        }
        class be {
            constructor(t, e, i, r) {
                this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : r && i ? 1 : 0,
                this.placed = i
            }
            isHidden() {
                return 0 === this.opacity && !this.placed
            }
        }
        class we {
            constructor(t, e, i, r, n, o=!1) {
                this.text = new be(t ? t.text : null,e,i,n),
                this.icon = new be(t ? t.icon : null,e,r,n),
                this.clipped = o
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden()
            }
        }
        class ze {
            constructor(t, e, i, r=!1) {
                this.text = t,
                this.icon = e,
                this.skipFade = i,
                this.clipped = r
            }
        }
        class Te {
            constructor() {
                this.invProjMatrix = t.create(),
                this.viewportMatrix = t.create(),
                this.circles = []
            }
        }
        class Ee {
            constructor(t, e, i, r, n) {
                this.bucketInstanceId = t,
                this.featureIndex = e,
                this.sourceLayerIndex = i,
                this.bucketIndex = r,
                this.tileID = n
            }
        }
        class Se {
            constructor(t) {
                this.crossSourceCollisions = t,
                this.maxGroupID = 0,
                this.collisionGroups = {}
            }
            get(t) {
                if (this.crossSourceCollisions)
                    return {
                        ID: 0,
                        predicate: null
                    };
                if (!this.collisionGroups[t]) {
                    const e = ++this.maxGroupID;
                    this.collisionGroups[t] = {
                        ID: e,
                        predicate: t=>t.collisionGroupID === e
                    }
                }
                return this.collisionGroups[t]
            }
        }
        function Me(e, i, r, n, o) {
            const {horizontalAlign: s, verticalAlign: a} = t.getAnchorAlignment(e)
              , l = -(s - .5) * i
              , c = -(a - .5) * r
              , u = t.evaluateVariableOffset(e, n);
            return new t.pointGeometry(l + u[0] * o,c + u[1] * o)
        }
        function Ae(e, i, r, n, o) {
            const s = new t.pointGeometry(e,i);
            return r && s._rotate(n ? o : -o),
            s
        }
        class Ie {
            constructor(t, e, i, r, n) {
                this.transform = t.clone(),
                this.projection = t.projection.name,
                this.collisionIndex = new ge(this.transform,n),
                this.placements = {},
                this.opacities = {},
                this.variableOffsets = {},
                this.stale = !1,
                this.commitTime = 0,
                this.fadeDuration = e,
                this.retainedQueryData = {},
                this.collisionGroups = new Se(i),
                this.collisionCircleArrays = {},
                this.prevPlacement = r,
                r && (r.prevPlacement = void 0),
                this.placedOrientations = {}
            }
            getBucketParts(e, i, r, n) {
                const o = r.getBucket(i)
                  , s = r.latestFeatureIndex;
                if (!o || !s || i.id !== o.layerIds[0])
                    return;
                const a = o.layers[0].layout
                  , l = r.collisionBoxArray
                  , c = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ)
                  , u = r.tileSize / t.EXTENT
                  , h = r.tileID.toUnwrapped();
                this.transform.setProjection(o.projection);
                const d = (p = r.tileID,
                m = o.getProjection(),
                f = this.transform,
                m.name === this.projection ? f.calculateProjMatrix(p.toUnwrapped()) : ye(f, m, p));
                var p, m, f;
                const _ = "map" === a.get("text-pitch-alignment")
                  , g = "map" === a.get("text-rotation-alignment");
                i.compileFilter();
                const y = i.dynamicFilter()
                  , x = i.dynamicFilterNeedsFeature()
                  , v = this.transform.calculatePixelsToTileUnitsMatrix(r)
                  , b = ie(d, r.tileID.canonical, _, g, this.transform, o.getProjection(), v);
                let w = null;
                if (_) {
                    const e = re(d, r.tileID.canonical, _, g, this.transform, o.getProjection(), v);
                    w = t.multiply([], this.transform.labelPlaneMatrix, e)
                }
                let z = null;
                y && r.latestFeatureIndex && (z = {
                    unwrappedTileID: h,
                    dynamicFilter: y,
                    dynamicFilterNeedsFeature: x,
                    featureIndex: r.latestFeatureIndex
                }),
                this.retainedQueryData[o.bucketInstanceId] = new Ee(o.bucketInstanceId,s,o.sourceLayerIndex,o.index,r.tileID);
                const T = {
                    bucket: o,
                    layout: a,
                    posMatrix: d,
                    textLabelPlaneMatrix: b,
                    labelToScreenMatrix: w,
                    clippingData: z,
                    scale: c,
                    textPixelRatio: u,
                    holdingForFade: r.holdingForFade(),
                    collisionBoxArray: l,
                    partiallyEvaluatedTextSize: t.evaluateSizeForZoom(o.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: t.evaluateSizeForZoom(o.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(o.sourceID)
                };
                if (n)
                    for (const t of o.sortKeyRanges) {
                        const {sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: n} = t;
                        e.push({
                            sortKey: i,
                            symbolInstanceStart: r,
                            symbolInstanceEnd: n,
                            parameters: T
                        })
                    }
                else
                    e.push({
                        symbolInstanceStart: 0,
                        symbolInstanceEnd: o.symbolInstances.length,
                        parameters: T
                    })
            }
            attemptAnchorPlacement(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m, f, _, g) {
                const {textOffset0: y, textOffset1: x, crossTileID: v} = h
                  , b = [y, x]
                  , w = Me(t, i, r, b, n)
                  , z = this.collisionIndex.placeCollisionBox(p, n, e, Ae(w.x, w.y, o, s, this.transform.angle), u, a, l, c.predicate);
                if (f) {
                    const t = p.getSymbolInstanceIconSize(g, this.transform.zoom, h.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(p, t, f, Ae(w.x, w.y, o, s, this.transform.angle), u, a, l, c.predicate).box.length)
                        return
                }
                if (z.box.length > 0) {
                    let e;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[v] && this.prevPlacement.placements[v] && this.prevPlacement.placements[v].text && (e = this.prevPlacement.variableOffsets[v].anchor),
                    this.variableOffsets[v] = {
                        textOffset: b,
                        width: i,
                        height: r,
                        anchor: t,
                        textScale: n,
                        prevAnchor: e
                    },
                    this.markUsedJustification(p, t, h, m),
                    p.allowVerticalPlacement && (this.markUsedOrientation(p, m, h),
                    this.placedOrientations[v] = m),
                    {
                        shift: w,
                        placedGlyphBoxes: z
                    }
                }
            }
            placeLayerBucketPart(e, i, r, n) {
                const {bucket: o, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: u, textPixelRatio: h, holdingForFade: d, collisionBoxArray: p, partiallyEvaluatedTextSize: m, partiallyEvaluatedIconSize: f, collisionGroup: _} = e.parameters
                  , g = s.get("text-optional")
                  , y = s.get("icon-optional")
                  , x = s.get("text-allow-overlap")
                  , v = s.get("icon-allow-overlap")
                  , b = "map" === s.get("text-rotation-alignment")
                  , w = "map" === s.get("text-pitch-alignment")
                  , z = "none" !== s.get("icon-text-fit")
                  , T = "viewport-y" === s.get("symbol-z-order");
                this.transform.setProjection(o.projection);
                let E = x && (v || !o.hasIconData() || y)
                  , S = v && (x || !o.hasTextData() || g);
                !o.collisionArrays && p && o.deserializeCollisionBoxes(p),
                r && n && o.updateCollisionDebugBuffers(this.transform.zoom, p);
                const M = (e,n,p)=>{
                    const {crossTileID: T, numVerticalGlyphVertices: M} = e;
                    if (u) {
                        const r = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let n = null;
                        if (u.dynamicFilterNeedsFeature) {
                            const t = this.retainedQueryData[o.bucketInstanceId];
                            n = u.featureIndex.loadFeature({
                                featureIndex: e.featureIndex,
                                bucketIndex: t.bucketIndex,
                                sourceLayerIndex: t.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            })
                        }
                        if (!(0,
                        u.dynamicFilter)(r, n, this.retainedQueryData[o.bucketInstanceId].tileID.canonical, new t.pointGeometry(e.tileAnchorX,e.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID)))
                            return this.placements[T] = new ze(!1,!1,!1,!0),
                            void (i[T] = !0)
                    }
                    if (i[T])
                        return;
                    if (d)
                        return void (this.placements[T] = new ze(!1,!1,!1));
                    let A = !1
                      , I = !1
                      , C = !0
                      , D = !1
                      , k = !1
                      , P = null
                      , L = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }
                      , O = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }
                      , R = null
                      , B = null
                      , F = null
                      , U = 0
                      , N = 0
                      , G = 0;
                    p.textFeatureIndex ? U = p.textFeatureIndex : e.useRuntimeCollisionCircles && (U = e.featureIndex),
                    p.verticalTextFeatureIndex && (N = p.verticalTextFeatureIndex);
                    const j = t=>{
                        t.tileID = this.retainedQueryData[o.bucketInstanceId].tileID;
                        const e = this.transform.elevation;
                        (e || t.elevation) && (t.elevation = e ? e.getAtTileOffset(t.tileID, t.tileAnchorX, t.tileAnchorY) : 0)
                    }
                      , V = p.textBox;
                    if (V) {
                        j(V);
                        const i = i=>{
                            let r = t.WritingMode.horizontal;
                            if (o.allowVerticalPlacement && !i && this.prevPlacement) {
                                const t = this.prevPlacement.placedOrientations[T];
                                t && (this.placedOrientations[T] = t,
                                r = t,
                                this.markUsedOrientation(o, r, e))
                            }
                            return r
                        }
                          , r = (e,i)=>{
                            if (o.allowVerticalPlacement && M > 0 && p.verticalTextBox) {
                                for (const r of o.writingModes)
                                    if (r === t.WritingMode.vertical ? (L = i(),
                                    O = L) : L = e(),
                                    L && L.box && L.box.length)
                                        break
                            } else
                                L = e()
                        }
                        ;
                        if (s.get("text-variable-anchor")) {
                            let l = s.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[T]) {
                                const t = this.prevPlacement.variableOffsets[T];
                                l.indexOf(t.anchor) > 0 && (l = l.filter((e=>e !== t.anchor)),
                                l.unshift(t.anchor))
                            }
                            const c = (t,i,r)=>{
                                const s = o.getSymbolInstanceTextSize(m, e, this.transform.zoom, n)
                                  , c = (t.x2 - t.x1) * s + 2 * t.padding
                                  , u = (t.y2 - t.y1) * s + 2 * t.padding
                                  , d = z && !v ? i : null;
                                d && j(d);
                                let p = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g = x ? 2 * l.length : l.length;
                                for (let i = 0; i < g; ++i) {
                                    const g = this.attemptAnchorPlacement(l[i % l.length], t, c, u, s, b, w, h, a, _, i >= l.length, e, n, o, r, d, m, f);
                                    if (g && (p = g.placedGlyphBoxes,
                                    p && p.box && p.box.length)) {
                                        A = !0,
                                        P = g.shift;
                                        break
                                    }
                                }
                                return p
                            }
                            ;
                            r((()=>c(V, p.iconBox, t.WritingMode.horizontal)), (()=>{
                                const e = p.verticalTextBox;
                                return e && j(e),
                                o.allowVerticalPlacement && !(L && L.box && L.box.length) && M > 0 && e ? c(e, p.verticalIconBox, t.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                }
                            }
                            )),
                            L && (A = L.box,
                            C = L.offscreen,
                            D = L.occluded);
                            const u = i(L && L.box);
                            if (!A && this.prevPlacement) {
                                const t = this.prevPlacement.variableOffsets[T];
                                t && (this.variableOffsets[T] = t,
                                this.markUsedJustification(o, t.anchor, e, u))
                            }
                        } else {
                            const s = (i,r)=>{
                                const s = o.getSymbolInstanceTextSize(m, e, this.transform.zoom, n)
                                  , l = this.collisionIndex.placeCollisionBox(o, s, i, new t.pointGeometry(0,0), x, h, a, _.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(o, r, e),
                                this.placedOrientations[T] = r),
                                l
                            }
                            ;
                            r((()=>s(V, t.WritingMode.horizontal)), (()=>{
                                const e = p.verticalTextBox;
                                return o.allowVerticalPlacement && M > 0 && e ? (j(e),
                                s(e, t.WritingMode.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                }
                            }
                            )),
                            i(L && L.box && L.box.length)
                        }
                    }
                    if (R = L,
                    A = R && R.box && R.box.length > 0,
                    C = R && R.offscreen,
                    D = R && R.occluded,
                    e.useRuntimeCollisionCircles) {
                        const i = o.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex)
                          , n = t.evaluateSizeForFeature(o.textSizeData, m, i)
                          , u = s.get("text-padding");
                        B = this.collisionIndex.placeCollisionCircles(o, x, i, o.lineVertexArray, o.glyphOffsetArray, n, a, l, c, r, w, _.predicate, e.collisionCircleDiameter * n / t.ONE_EM, u, this.retainedQueryData[o.bucketInstanceId].tileID),
                        A = x || B.circles.length > 0 && !B.collisionDetected,
                        C = C && B.offscreen,
                        D = B.occluded
                    }
                    if (p.iconFeatureIndex && (G = p.iconFeatureIndex),
                    p.iconBox) {
                        const i = i=>{
                            j(i);
                            const r = z && P ? Ae(P.x, P.y, b, w, this.transform.angle) : new t.pointGeometry(0,0)
                              , n = o.getSymbolInstanceIconSize(f, this.transform.zoom, e.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(o, n, i, r, v, h, a, _.predicate)
                        }
                        ;
                        O && O.box && O.box.length && p.verticalIconBox ? (F = i(p.verticalIconBox),
                        I = F.box.length > 0) : (F = i(p.iconBox),
                        I = F.box.length > 0),
                        C = C && F.offscreen,
                        k = F.occluded
                    }
                    const Z = g || 0 === e.numHorizontalGlyphVertices && 0 === M
                      , J = y || 0 === e.numIconVertices;
                    if (Z || J ? J ? Z || (I = I && A) : A = I && A : I = A = I && A,
                    A && R && R.box && this.collisionIndex.insertCollisionBox(R.box, s.get("text-ignore-placement"), o.bucketInstanceId, O && O.box && N ? N : U, _.ID),
                    I && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), o.bucketInstanceId, G, _.ID),
                    B && (A && this.collisionIndex.insertCollisionCircles(B.circles, s.get("text-ignore-placement"), o.bucketInstanceId, U, _.ID),
                    r)) {
                        const t = o.bucketInstanceId;
                        let e = this.collisionCircleArrays[t];
                        void 0 === e && (e = this.collisionCircleArrays[t] = new Te);
                        for (let t = 0; t < B.circles.length; t += 4)
                            e.circles.push(B.circles[t + 0]),
                            e.circles.push(B.circles[t + 1]),
                            e.circles.push(B.circles[t + 2]),
                            e.circles.push(B.collisionDetected ? 1 : 0)
                    }
                    const X = "globe" !== o.projection.name;
                    E = E && (X || !D),
                    S = S && (X || !k),
                    this.placements[T] = new ze(A || E,I || S,C || o.justReloaded),
                    i[T] = !0
                }
                ;
                if (T) {
                    const t = o.getSortedSymbolIndexes(this.transform.angle);
                    for (let e = t.length - 1; e >= 0; --e) {
                        const i = t[e];
                        M(o.symbolInstances.get(i), i, o.collisionArrays[i])
                    }
                } else
                    for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++)
                        M(o.symbolInstances.get(t), t, o.collisionArrays[t]);
                if (r && o.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[o.bucketInstanceId];
                    t.invert(e.invProjMatrix, a),
                    e.viewportMatrix = this.collisionIndex.getViewportMatrix()
                }
                o.justReloaded = !1
            }
            markUsedJustification(e, i, r, n) {
                const {leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c} = r
                  , u = t.getAnchorJustification(i)
                  , h = n === t.WritingMode.vertical ? l : "left" === u ? o : "center" === u ? s : "right" === u ? a : -1;
                o >= 0 && (e.text.placedSymbolArray.get(o).crossTileID = h >= 0 && o !== h ? 0 : c),
                s >= 0 && (e.text.placedSymbolArray.get(s).crossTileID = h >= 0 && s !== h ? 0 : c),
                a >= 0 && (e.text.placedSymbolArray.get(a).crossTileID = h >= 0 && a !== h ? 0 : c),
                l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = h >= 0 && l !== h ? 0 : c)
            }
            markUsedOrientation(e, i, r) {
                const n = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0
                  , o = i === t.WritingMode.vertical ? i : 0
                  , {leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c} = r
                  , u = e.text.placedSymbolArray;
                s >= 0 && (u.get(s).placedOrientation = n),
                a >= 0 && (u.get(a).placedOrientation = n),
                l >= 0 && (u.get(l).placedOrientation = n),
                c >= 0 && (u.get(c).placedOrientation = o)
            }
            commit(t) {
                this.commitTime = t,
                this.zoomAtLastRecencyCheck = this.transform.zoom;
                const e = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;
                const r = e ? e.symbolFadeChange(t) : 1
                  , n = e ? e.opacities : {}
                  , o = e ? e.variableOffsets : {}
                  , s = e ? e.placedOrientations : {};
                for (const t in this.placements) {
                    const e = this.placements[t]
                      , o = n[t];
                    o ? (this.opacities[t] = new we(o,r,e.text,e.icon,null,e.clipped),
                    i = i || e.text !== o.text.placed || e.icon !== o.icon.placed) : (this.opacities[t] = new we(null,r,e.text,e.icon,e.skipFade,e.clipped),
                    i = i || e.text || e.icon)
                }
                for (const t in n) {
                    const e = n[t];
                    if (!this.opacities[t]) {
                        const n = new we(e,r,!1,!1);
                        n.isHidden() || (this.opacities[t] = n,
                        i = i || e.text.placed || e.icon.placed)
                    }
                }
                for (const t in o)
                    this.variableOffsets[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.variableOffsets[t] = o[t]);
                for (const t in s)
                    this.placedOrientations[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.placedOrientations[t] = s[t]);
                i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t)
            }
            updateLayerOpacities(t, e) {
                const i = {};
                for (const r of e) {
                    const e = r.getBucket(t);
                    e && r.latestFeatureIndex && t.id === e.layerIds[0] && this.updateBucketOpacities(e, i, r.collisionBoxArray)
                }
            }
            updateBucketOpacities(e, i, r) {
                e.hasTextData() && e.text.opacityVertexArray.clear(),
                e.hasIconData() && e.icon.opacityVertexArray.clear(),
                e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                const n = e.layers[0].layout
                  , o = !!e.layers[0].dynamicFilter()
                  , s = new we(null,0,!1,!1,!0)
                  , a = n.get("text-allow-overlap")
                  , l = n.get("icon-allow-overlap")
                  , c = n.get("text-variable-anchor")
                  , u = "map" === n.get("text-rotation-alignment")
                  , h = "map" === n.get("text-pitch-alignment")
                  , d = "none" !== n.get("icon-text-fit")
                  , p = new we(null,0,a && (l || !e.hasIconData() || n.get("icon-optional")),l && (a || !e.hasTextData() || n.get("text-optional")),!0);
                !e.collisionArrays && r && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(r);
                const m = (t,e,i)=>{
                    for (let r = 0; r < e / 4; r++)
                        t.opacityVertexArray.emplaceBack(i)
                }
                ;
                let f = 0;
                for (let r = 0; r < e.symbolInstances.length; r++) {
                    const n = e.symbolInstances.get(r)
                      , {numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, crossTileID: _, numIconVertices: g} = n;
                    let y = this.opacities[_];
                    i[_] ? y = s : y || (y = p,
                    this.opacities[_] = y),
                    i[_] = !0;
                    const x = a > 0 || l > 0
                      , v = g > 0
                      , b = this.placedOrientations[_]
                      , w = b === t.WritingMode.vertical
                      , z = b === t.WritingMode.horizontal || b === t.WritingMode.horizontalOnly;
                    if (!x && !v || y.isHidden() || f++,
                    x) {
                        const t = Fe(y.text);
                        m(e.text, a, w ? Ue : t),
                        m(e.text, l, z ? Ue : t);
                        const i = y.text.isHidden()
                          , {leftJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: o, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: c} = n
                          , u = e.text.placedSymbolArray
                          , h = i || w ? 1 : 0;
                        r >= 0 && (u.get(r).hidden = h),
                        o >= 0 && (u.get(o).hidden = h),
                        s >= 0 && (u.get(s).hidden = h),
                        c >= 0 && (u.get(c).hidden = i || z ? 1 : 0);
                        const d = this.variableOffsets[_];
                        d && this.markUsedJustification(e, d.anchor, n, b);
                        const p = this.placedOrientations[_];
                        p && (this.markUsedJustification(e, "left", n, p),
                        this.markUsedOrientation(e, p, n))
                    }
                    if (v) {
                        const t = Fe(y.icon)
                          , {placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: r} = n
                          , o = e.icon.placedSymbolArray
                          , s = y.icon.isHidden() ? 1 : 0;
                        i >= 0 && (m(e.icon, g, w ? Ue : t),
                        o.get(i).hidden = s),
                        r >= 0 && (m(e.icon, n.numVerticalIconVertices, z ? Ue : t),
                        o.get(r).hidden = s)
                    }
                    if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                        const i = e.collisionArrays[r];
                        if (i) {
                            let r = new t.pointGeometry(0,0)
                              , n = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (c) {
                                    const t = this.variableOffsets[_];
                                    t ? (r = Me(t.anchor, t.width, t.height, t.textOffset, t.textScale),
                                    u && r._rotate(h ? this.transform.angle : -this.transform.angle)) : n = !1
                                }
                                o && (n = !y.clipped),
                                i.textBox && Ce(e.textCollisionBox.collisionVertexArray, y.text.placed, !n || w, r.x, r.y),
                                i.verticalTextBox && Ce(e.textCollisionBox.collisionVertexArray, y.text.placed, !n || z, r.x, r.y)
                            }
                            const s = n && Boolean(!z && i.verticalIconBox);
                            i.iconBox && Ce(e.iconCollisionBox.collisionVertexArray, y.icon.placed, s, d ? r.x : 0, d ? r.y : 0),
                            i.verticalIconBox && Ce(e.iconCollisionBox.collisionVertexArray, y.icon.placed, !s, d ? r.x : 0, d ? r.y : 0)
                        }
                    }
                }
                if (e.fullyClipped = 0 === f,
                e.sortFeatures(this.transform.angle),
                this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                e.bucketInstanceId in this.collisionCircleArrays) {
                    const t = this.collisionCircleArrays[e.bucketInstanceId];
                    e.placementInvProjMatrix = t.invProjMatrix,
                    e.placementViewportMatrix = t.viewportMatrix,
                    e.collisionCircleArray = t.circles,
                    delete this.collisionCircleArrays[e.bucketInstanceId]
                }
            }
            symbolFadeChange(t) {
                return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
            }
            zoomAdjustment(t) {
                return Math.max(0, (this.transform.zoom - t) / 1.5)
            }
            hasTransitions(t) {
                return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
            }
            stillRecent(t, e) {
                const i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;
                return this.zoomAtLastRecencyCheck = e,
                this.commitTime + this.fadeDuration * i > t
            }
            setStale() {
                this.stale = !0
            }
        }
        function Ce(t, e, i, r, n) {
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0)
        }
        const De = Math.pow(2, 25)
          , ke = Math.pow(2, 24)
          , Pe = Math.pow(2, 17)
          , Le = Math.pow(2, 16)
          , Oe = Math.pow(2, 9)
          , Re = Math.pow(2, 8)
          , Be = Math.pow(2, 1);
        function Fe(t) {
            if (0 === t.opacity && !t.placed)
                return 0;
            if (1 === t.opacity && t.placed)
                return 4294967295;
            const e = t.placed ? 1 : 0
              , i = Math.floor(127 * t.opacity);
            return i * De + e * ke + i * Pe + e * Le + i * Oe + e * Re + i * Be + e
        }
        const Ue = 0;
        class Ne {
            constructor(t) {
                this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1),
                this._currentTileIndex = 0,
                this._currentPartIndex = 0,
                this._seenCrossTileIDs = {},
                this._bucketParts = []
            }
            continuePlacement(t, e, i, r, n) {
                const o = this._bucketParts;
                for (; this._currentTileIndex < t.length; )
                    if (e.getBucketParts(o, r, t[this._currentTileIndex], this._sortAcrossTiles),
                    this._currentTileIndex++,
                    n())
                        return !0;
                for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                o.sort(((t,e)=>t.sortKey - e.sortKey))); this._currentPartIndex < o.length; ) {
                    const t = o[this._currentPartIndex];
                    if (e.placeLayerBucketPart(t, this._seenCrossTileIDs, i, 0 === t.symbolInstanceStart),
                    this._currentPartIndex++,
                    n())
                        return !0
                }
                return !1
            }
        }
        class Ge {
            constructor(t, e, i, r, n, o, s, a) {
                this.placement = new Ie(t,n,o,s,a),
                this._currentPlacementIndex = e.length - 1,
                this._forceFullPlacement = i,
                this._showCollisionBoxes = r,
                this._done = !1
            }
            isDone() {
                return this._done
            }
            continuePlacement(e, i, r) {
                const n = t.exported.now()
                  , o = ()=>{
                    const e = t.exported.now() - n;
                    return !this._forceFullPlacement && e > 2
                }
                ;
                for (; this._currentPlacementIndex >= 0; ) {
                    const t = i[e[this._currentPlacementIndex]]
                      , n = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === t.type && (!t.minzoom || t.minzoom <= n) && (!t.maxzoom || t.maxzoom > n)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Ne(t)),
                        this._inProgressLayer.continuePlacement(r[t.source], this.placement, this._showCollisionBoxes, t, o))
                            return;
                        delete this._inProgressLayer
                    }
                    this._currentPlacementIndex--
                }
                this._done = !0
            }
            commit(t) {
                return this.placement.commit(t),
                this.placement
            }
        }
        const je = 512 / t.EXTENT / 2;
        class Ve {
            constructor(t, e, i) {
                this.tileID = t,
                this.indexedSymbolInstances = {},
                this.bucketInstanceId = i;
                for (let i = 0; i < e.length; i++) {
                    const r = e.get(i)
                      , n = r.key;
                    this.indexedSymbolInstances[n] || (this.indexedSymbolInstances[n] = []),
                    this.indexedSymbolInstances[n].push({
                        crossTileID: r.crossTileID,
                        coord: this.getScaledCoordinates(r, t)
                    })
                }
            }
            getScaledCoordinates(e, i) {
                const r = je / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
                return {
                    x: Math.floor((i.canonical.x * t.EXTENT + e.tileAnchorX) * r),
                    y: Math.floor((i.canonical.y * t.EXTENT + e.tileAnchorY) * r)
                }
            }
            findMatches(t, e, i) {
                const r = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z);
                for (let n = 0; n < t.length; n++) {
                    const o = t.get(n);
                    if (o.crossTileID)
                        continue;
                    const s = this.indexedSymbolInstances[o.key];
                    if (!s)
                        continue;
                    const a = this.getScaledCoordinates(o, e);
                    for (const t of s)
                        if (Math.abs(t.coord.x - a.x) <= r && Math.abs(t.coord.y - a.y) <= r && !i[t.crossTileID]) {
                            i[t.crossTileID] = !0,
                            o.crossTileID = t.crossTileID;
                            break
                        }
                }
            }
        }
        class Ze {
            constructor() {
                this.maxCrossTileID = 0
            }
            generate() {
                return ++this.maxCrossTileID
            }
        }
        class Je {
            constructor() {
                this.indexes = {},
                this.usedCrossTileIDs = {},
                this.lng = 0
            }
            handleWrapJump(t) {
                const e = Math.round((t - this.lng) / 360);
                if (0 !== e)
                    for (const t in this.indexes) {
                        const i = this.indexes[t]
                          , r = {};
                        for (const t in i) {
                            const n = i[t];
                            n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e),
                            r[n.tileID.key] = n
                        }
                        this.indexes[t] = r
                    }
                this.lng = t
            }
            addBucket(t, e, i) {
                if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
                    if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId)
                        return !1;
                    this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key])
                }
                for (let t = 0; t < e.symbolInstances.length; t++)
                    e.symbolInstances.get(t).crossTileID = 0;
                this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
                const r = this.usedCrossTileIDs[t.overscaledZ];
                for (const i in this.indexes) {
                    const n = this.indexes[i];
                    if (Number(i) > t.overscaledZ)
                        for (const i in n) {
                            const o = n[i];
                            o.tileID.isChildOf(t) && o.findMatches(e.symbolInstances, t, r)
                        }
                    else {
                        const o = n[t.scaledTo(Number(i)).key];
                        o && o.findMatches(e.symbolInstances, t, r)
                    }
                }
                for (let t = 0; t < e.symbolInstances.length; t++) {
                    const n = e.symbolInstances.get(t);
                    n.crossTileID || (n.crossTileID = i.generate(),
                    r[n.crossTileID] = !0)
                }
                return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}),
                this.indexes[t.overscaledZ][t.key] = new Ve(t,e.symbolInstances,e.bucketInstanceId),
                !0
            }
            removeBucketCrossTileIDs(t, e) {
                for (const i in e.indexedSymbolInstances)
                    for (const r of e.indexedSymbolInstances[i])
                        delete this.usedCrossTileIDs[t][r.crossTileID]
            }
            removeStaleBuckets(t) {
                let e = !1;
                for (const i in this.indexes) {
                    const r = this.indexes[i];
                    for (const n in r)
                        t[r[n].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, r[n]),
                        delete r[n],
                        e = !0)
                }
                return e
            }
        }
        class Xe {
            constructor() {
                this.layerIndexes = {},
                this.crossTileIDs = new Ze,
                this.maxBucketInstanceId = 0,
                this.bucketsInCurrentPlacement = {}
            }
            addLayer(t, e, i, r) {
                let n = this.layerIndexes[t.id];
                void 0 === n && (n = this.layerIndexes[t.id] = new Je);
                let o = !1;
                const s = {};
                "globe" !== r.name && n.handleWrapJump(i);
                for (const i of e) {
                    const e = i.getBucket(t);
                    e && t.id === e.layerIds[0] && (e.bucketInstanceId || (e.bucketInstanceId = ++this.maxBucketInstanceId),
                    n.addBucket(i.tileID, e, this.crossTileIDs) && (o = !0),
                    s[e.bucketInstanceId] = !0)
                }
                return n.removeStaleBuckets(s) && (o = !0),
                o
            }
            pruneUnusedLayers(t) {
                const e = {};
                t.forEach((t=>{
                    e[t] = !0
                }
                ));
                for (const t in this.layerIndexes)
                    e[t] || delete this.layerIndexes[t]
            }
        }
        const qe = (e,i)=>t.emitValidationErrors(e, i && i.filter((t=>"source.canvas" !== t.identifier)))
          , $e = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"])
          , Ye = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"])
          , We = {
            version: 8,
            layers: [],
            sources: {}
        }
          , He = {
            fill: !0,
            line: !0,
            background: !0,
            hillshade: !0,
            raster: !0
        };
        class Ke extends t.Evented {
            constructor(e, i={}) {
                super(),
                this.map = e,
                this.dispatcher = new k(Gt(),this),
                this.imageManager = new v,
                this.imageManager.setEventedParent(this),
                this.glyphManager = new t.GlyphManager(e._requestManager,i.localFontFamily ? t.LocalGlyphMode.all : i.localIdeographFontFamily ? t.LocalGlyphMode.ideographs : t.LocalGlyphMode.none,i.localFontFamily || i.localIdeographFontFamily),
                this.crossTileSymbolIndex = new Xe,
                this._layers = {},
                this._num3DLayers = 0,
                this._numSymbolLayers = 0,
                this._numCircleLayers = 0,
                this._serializedLayers = {},
                this._sourceCaches = {},
                this._otherSourceCaches = {},
                this._symbolSourceCaches = {},
                this._loaded = !1,
                this._availableImages = [],
                this._order = [],
                this._drapedFirstOrder = [],
                this._markersNeedUpdate = !1,
                this._resetUpdates(),
                this.dispatcher.broadcast("setReferrer", t.getReferrer());
                const r = this;
                this._rtlTextPluginCallback = Ke.registerForPluginStateChange((e=>{
                    r.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: e.pluginStatus,
                        pluginURL: e.pluginURL
                    }, ((e,i)=>{
                        if (t.triggerPluginCompletionEvent(e),
                        i && i.every((t=>t)))
                            for (const t in r._sourceCaches) {
                                const e = r._sourceCaches[t]
                                  , i = e.getSource().type;
                                "vector" !== i && "geojson" !== i || e.reload()
                            }
                    }
                    ))
                }
                )),
                this.on("data", (t=>{
                    if ("source" !== t.dataType || "metadata" !== t.sourceDataType)
                        return;
                    const e = this.getSource(t.sourceId);
                    if (e && e.vectorLayerIds)
                        for (const t in this._layers) {
                            const i = this._layers[t];
                            i.source === e.id && this._validateLayer(i)
                        }
                }
                ))
            }
            loadURL(e, i={}) {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                }));
                const r = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e);
                e = this.map._requestManager.normalizeStyleURL(e, i.accessToken);
                const n = this.map._requestManager.transformRequest(e, t.ResourceType.Style);
                this._request = t.getJSON(n, ((e,i)=>{
                    this._request = null,
                    e ? this.fire(new t.ErrorEvent(e)) : i && this._load(i, r)
                }
                ))
            }
            loadJSON(e, i={}) {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                })),
                this._request = t.exported.frame((()=>{
                    this._request = null,
                    this._load(e, !1 !== i.validate)
                }
                ))
            }
            loadEmpty() {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                })),
                this._load(We, !1)
            }
            _updateLayerCount(t, e) {
                const i = e ? 1 : -1;
                t.is3D() && (this._num3DLayers += i),
                "circle" === t.type && (this._numCircleLayers += i),
                "symbol" === t.type && (this._numSymbolLayers += i)
            }
            _load(e, i) {
                if (i && qe(this, t.validateStyle(e)))
                    return;
                this._loaded = !0,
                this.stylesheet = t.clone$1(e),
                this._updateMapProjection();
                for (const t in e.sources)
                    this.addSource(t, e.sources[t], {
                        validate: !1
                    });
                this._changed = !1,
                e.sprite ? this._loadSprite(e.sprite) : (this.imageManager.setLoaded(!0),
                this.dispatcher.broadcast("spriteLoaded", !0)),
                this.glyphManager.setURL(e.glyphs);
                const r = Vt(this.stylesheet.layers);
                this._order = r.map((t=>t.id)),
                this._layers = {},
                this._serializedLayers = {};
                for (let e of r)
                    e = t.createStyleLayer(e),
                    e.setEventedParent(this, {
                        layer: {
                            id: e.id
                        }
                    }),
                    this._layers[e.id] = e,
                    this._serializedLayers[e.id] = e.serialize(),
                    this._updateLayerCount(e, !0);
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)),
                this.light = new z(this.stylesheet.light),
                this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1),
                this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                this._updateDrapeFirstLayers(),
                this.fire(new t.Event("data",{
                    dataType: "style"
                })),
                this.fire(new t.Event("style.load"))
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode
            }
            setProjection(t) {
                t ? this.stylesheet.projection = t : delete this.stylesheet.projection,
                this._updateMapProjection()
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions),
                this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null))
            }
            _updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection)
            }
            _loadSprite(e) {
                this._spriteRequest = function(e, i, r) {
                    let n, o, s;
                    const a = t.exported.devicePixelRatio > 1 ? "@2x" : "";
                    let l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, a, ".json"), t.ResourceType.SpriteJSON), ((t,e)=>{
                        l = null,
                        s || (s = t,
                        n = e,
                        u())
                    }
                    ))
                      , c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, a, ".png"), t.ResourceType.SpriteImage), ((t,e)=>{
                        c = null,
                        s || (s = t,
                        o = e,
                        u())
                    }
                    ));
                    function u() {
                        if (s)
                            r(s);
                        else if (n && o) {
                            const e = t.exported.getImageData(o)
                              , i = {};
                            for (const r in n) {
                                const {width: o, height: s, x: a, y: l, sdf: c, pixelRatio: u, stretchX: h, stretchY: d, content: p} = n[r]
                                  , m = new t.RGBAImage({
                                    width: o,
                                    height: s
                                });
                                t.RGBAImage.copy(e, m, {
                                    x: a,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: o,
                                    height: s
                                }),
                                i[r] = {
                                    data: m,
                                    pixelRatio: u,
                                    sdf: c,
                                    stretchX: h,
                                    stretchY: d,
                                    content: p
                                }
                            }
                            r(null, i)
                        }
                    }
                    return {
                        cancel() {
                            l && (l.cancel(),
                            l = null),
                            c && (c.cancel(),
                            c = null)
                        }
                    }
                }(e, this.map._requestManager, ((e,i)=>{
                    if (this._spriteRequest = null,
                    e)
                        this.fire(new t.ErrorEvent(e));
                    else if (i)
                        for (const t in i)
                            this.imageManager.addImage(t, i[t]);
                    this.imageManager.setLoaded(!0),
                    this._availableImages = this.imageManager.listImages(),
                    this.dispatcher.broadcast("setImages", this._availableImages),
                    this.dispatcher.broadcast("spriteLoaded", !0),
                    this.fire(new t.Event("data",{
                        dataType: "style"
                    }))
                }
                ))
            }
            _validateLayer(e) {
                const i = this.getSource(e.source);
                if (!i)
                    return;
                const r = e.sourceLayer;
                r && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(r)) && this.fire(new t.ErrorEvent(new Error(`Source layer "${r}" does not exist on source "${i.id}" as specified by style layer "${e.id}"`)))
            }
            loaded() {
                if (!this._loaded)
                    return !1;
                if (Object.keys(this._updatedSources).length)
                    return !1;
                for (const t in this._sourceCaches)
                    if (!this._sourceCaches[t].loaded())
                        return !1;
                return !!this.imageManager.isLoaded()
            }
            _serializeLayers(t) {
                const e = [];
                for (const i of t) {
                    const t = this._layers[i];
                    "custom" !== t.type && e.push(t.serialize())
                }
                return e
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition())
                    return !0;
                if (this.fog && this.fog.hasTransition())
                    return !0;
                for (const t in this._sourceCaches)
                    if (this._sourceCaches[t].hasTransition())
                        return !0;
                for (const t in this._layers)
                    if (this._layers[t].hasTransition())
                        return !0;
                return !1
            }
            get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order
            }
            isLayerDraped(t) {
                return !!this.terrain && He[t.type]
            }
            _checkLoaded() {
                if (!this._loaded)
                    throw new Error("Style is not done loading")
            }
            update(e) {
                if (!this._loaded)
                    return;
                const i = this._changed;
                if (this._changed) {
                    const t = Object.keys(this._updatedLayers)
                      , i = Object.keys(this._removedLayers);
                    (t.length || i.length) && this._updateWorkerLayers(t, i);
                    for (const t in this._updatedSources) {
                        const e = this._updatedSources[t];
                        "reload" === e ? this._reloadSource(t) : "clear" === e && this._clearSource(t)
                    }
                    this._updateTilesForChangedImages();
                    for (const t in this._updatedPaintProps)
                        this._layers[t].updateTransitions(e);
                    this.light.updateTransitions(e),
                    this.fog && this.fog.updateTransitions(e),
                    this._resetUpdates()
                }
                const r = {};
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t];
                    r[t] = e.used,
                    e.used = !1
                }
                for (const t of this._order) {
                    const i = this._layers[t];
                    if (i.recalculate(e, this._availableImages),
                    !i.isHidden(e.zoom)) {
                        const t = this._getLayerSourceCache(i);
                        t && (t.used = !0)
                    }
                    const r = this.map.painter;
                    if (r) {
                        const t = i.getProgramIds();
                        if (!t)
                            continue;
                        const n = i.getProgramConfiguration(e.zoom);
                        for (const e of t)
                            r.useProgram(e, n)
                    }
                }
                for (const e in r) {
                    const i = this._sourceCaches[e];
                    r[e] !== i.used && i.getSource().fire(new t.Event("data",{
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }))
                }
                this.light.recalculate(e),
                this.terrain && this.terrain.recalculate(e),
                this.fog && this.fog.recalculate(e),
                this.z = e.zoom,
                this._markersNeedUpdate && (this._updateMarkersOpacity(),
                this._markersNeedUpdate = !1),
                i && this.fire(new t.Event("data",{
                    dataType: "style"
                }))
            }
            _updateTilesForChangedImages() {
                const t = Object.keys(this._changedImages);
                if (t.length) {
                    for (const e in this._sourceCaches)
                        this._sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);
                    this._changedImages = {}
                }
            }
            _updateWorkerLayers(t, e) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(t),
                    removedIds: e
                })
            }
            _resetUpdates() {
                this._changed = !1,
                this._updatedLayers = {},
                this._removedLayers = {},
                this._updatedSources = {},
                this._updatedPaintProps = {},
                this._changedImages = {}
            }
            setState(i) {
                if (this._checkLoaded(),
                qe(this, t.validateStyle(i)))
                    return !1;
                (i = t.clone$1(i)).layers = Vt(i.layers);
                const r = function(t, i) {
                    if (!t)
                        return [{
                            command: Zt.setStyle,
                            args: [i]
                        }];
                    let r = [];
                    try {
                        if (!e(t.version, i.version))
                            return [{
                                command: Zt.setStyle,
                                args: [i]
                            }];
                        e(t.center, i.center) || r.push({
                            command: Zt.setCenter,
                            args: [i.center]
                        }),
                        e(t.zoom, i.zoom) || r.push({
                            command: Zt.setZoom,
                            args: [i.zoom]
                        }),
                        e(t.bearing, i.bearing) || r.push({
                            command: Zt.setBearing,
                            args: [i.bearing]
                        }),
                        e(t.pitch, i.pitch) || r.push({
                            command: Zt.setPitch,
                            args: [i.pitch]
                        }),
                        e(t.sprite, i.sprite) || r.push({
                            command: Zt.setSprite,
                            args: [i.sprite]
                        }),
                        e(t.glyphs, i.glyphs) || r.push({
                            command: Zt.setGlyphs,
                            args: [i.glyphs]
                        }),
                        e(t.transition, i.transition) || r.push({
                            command: Zt.setTransition,
                            args: [i.transition]
                        }),
                        e(t.light, i.light) || r.push({
                            command: Zt.setLight,
                            args: [i.light]
                        }),
                        e(t.fog, i.fog) || r.push({
                            command: Zt.setFog,
                            args: [i.fog]
                        }),
                        e(t.projection, i.projection) || r.push({
                            command: Zt.setProjection,
                            args: [i.projection]
                        });
                        const n = {}
                          , o = [];
                        !function(t, i, r, n) {
                            let o;
                            for (o in i = i || {},
                            t = t || {})
                                t.hasOwnProperty(o) && (i.hasOwnProperty(o) || Xt(o, r, n));
                            for (o in i)
                                i.hasOwnProperty(o) && (t.hasOwnProperty(o) ? e(t[o], i[o]) || ("geojson" === t[o].type && "geojson" === i[o].type && $t(t, i, o) ? r.push({
                                    command: Zt.setGeoJSONSourceData,
                                    args: [o, i[o].data]
                                }) : qt(o, i, r, n)) : Jt(o, i, r))
                        }(t.sources, i.sources, o, n);
                        const s = [];
                        t.layers && t.layers.forEach((t=>{
                            t.source && n[t.source] ? r.push({
                                command: Zt.removeLayer,
                                args: [t.id]
                            }) : s.push(t)
                        }
                        ));
                        let a = t.terrain;
                        a && n[a.source] && (r.push({
                            command: Zt.setTerrain,
                            args: [void 0]
                        }),
                        a = void 0),
                        r = r.concat(o),
                        e(a, i.terrain) || r.push({
                            command: Zt.setTerrain,
                            args: [i.terrain]
                        }),
                        function(t, i, r) {
                            i = i || [];
                            const n = (t = t || []).map(Wt)
                              , o = i.map(Wt)
                              , s = t.reduce(Ht, {})
                              , a = i.reduce(Ht, {})
                              , l = n.slice()
                              , c = Object.create(null);
                            let u, h, d, p, m, f, _;
                            for (u = 0,
                            h = 0; u < n.length; u++)
                                d = n[u],
                                a.hasOwnProperty(d) ? h++ : (r.push({
                                    command: Zt.removeLayer,
                                    args: [d]
                                }),
                                l.splice(l.indexOf(d, h), 1));
                            for (u = 0,
                            h = 0; u < o.length; u++)
                                d = o[o.length - 1 - u],
                                l[l.length - 1 - u] !== d && (s.hasOwnProperty(d) ? (r.push({
                                    command: Zt.removeLayer,
                                    args: [d]
                                }),
                                l.splice(l.lastIndexOf(d, l.length - h), 1)) : h++,
                                f = l[l.length - u],
                                r.push({
                                    command: Zt.addLayer,
                                    args: [a[d], f]
                                }),
                                l.splice(l.length - u, 0, d),
                                c[d] = !0);
                            for (u = 0; u < o.length; u++)
                                if (d = o[u],
                                p = s[d],
                                m = a[d],
                                !c[d] && !e(p, m))
                                    if (e(p.source, m.source) && e(p["source-layer"], m["source-layer"]) && e(p.type, m.type)) {
                                        for (_ in Yt(p.layout, m.layout, r, d, null, Zt.setLayoutProperty),
                                        Yt(p.paint, m.paint, r, d, null, Zt.setPaintProperty),
                                        e(p.filter, m.filter) || r.push({
                                            command: Zt.setFilter,
                                            args: [d, m.filter]
                                        }),
                                        e(p.minzoom, m.minzoom) && e(p.maxzoom, m.maxzoom) || r.push({
                                            command: Zt.setLayerZoomRange,
                                            args: [d, m.minzoom, m.maxzoom]
                                        }),
                                        p)
                                            p.hasOwnProperty(_) && "layout" !== _ && "paint" !== _ && "filter" !== _ && "metadata" !== _ && "minzoom" !== _ && "maxzoom" !== _ && (0 === _.indexOf("paint.") ? Yt(p[_], m[_], r, d, _.slice(6), Zt.setPaintProperty) : e(p[_], m[_]) || r.push({
                                                command: Zt.setLayerProperty,
                                                args: [d, _, m[_]]
                                            }));
                                        for (_ in m)
                                            m.hasOwnProperty(_) && !p.hasOwnProperty(_) && "layout" !== _ && "paint" !== _ && "filter" !== _ && "metadata" !== _ && "minzoom" !== _ && "maxzoom" !== _ && (0 === _.indexOf("paint.") ? Yt(p[_], m[_], r, d, _.slice(6), Zt.setPaintProperty) : e(p[_], m[_]) || r.push({
                                                command: Zt.setLayerProperty,
                                                args: [d, _, m[_]]
                                            }))
                                    } else
                                        r.push({
                                            command: Zt.removeLayer,
                                            args: [d]
                                        }),
                                        f = l[l.lastIndexOf(d) + 1],
                                        r.push({
                                            command: Zt.addLayer,
                                            args: [m, f]
                                        })
                        }(s, i.layers, r)
                    } catch (t) {
                        console.warn("Unable to compute style diff:", t),
                        r = [{
                            command: Zt.setStyle,
                            args: [i]
                        }]
                    }
                    return r
                }(this.serialize(), i).filter((t=>!(t.command in Ye)));
                if (0 === r.length)
                    return !1;
                const n = r.filter((t=>!(t.command in $e)));
                if (n.length > 0)
                    throw new Error(`Unimplemented: ${n.map((t=>t.command)).join(", ")}.`);
                return r.forEach((t=>{
                    "setTransition" !== t.command && "setProjection" !== t.command && this[t.command].apply(this, t.args)
                }
                )),
                this.stylesheet = i,
                this._updateMapProjection(),
                !0
            }
            addImage(e, i) {
                return this.getImage(e) ? this.fire(new t.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(e, i),
                this._afterImageUpdated(e),
                this)
            }
            updateImage(t, e) {
                this.imageManager.updateImage(t, e)
            }
            getImage(t) {
                return this.imageManager.getImage(t)
            }
            removeImage(e) {
                return this.getImage(e) ? (this.imageManager.removeImage(e),
                this._afterImageUpdated(e),
                this) : this.fire(new t.ErrorEvent(new Error("No image with this name exists.")))
            }
            _afterImageUpdated(e) {
                this._availableImages = this.imageManager.listImages(),
                this._changedImages[e] = !0,
                this._changed = !0,
                this.dispatcher.broadcast("setImages", this._availableImages),
                this.fire(new t.Event("data",{
                    dataType: "style"
                }))
            }
            listImages() {
                return this._checkLoaded(),
                this._availableImages.slice()
            }
            addSource(e, i, r={}) {
                if (this._checkLoaded(),
                void 0 !== this.getSource(e))
                    throw new Error("There is already a source with this ID");
                if (!i.type)
                    throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateSource, `sources.${e}`, i, null, r))
                    return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const n = kt(e, i, this.dispatcher, this);
                n.setEventedParent(this, (()=>({
                    isSourceLoaded: this._isSourceCacheLoaded(e),
                    source: n.serialize(),
                    sourceId: e
                })));
                const o = i=>{
                    const r = (i ? "symbol:" : "other:") + e
                      , o = this._sourceCaches[r] = new t.SourceCache(r,n,i);
                    (i ? this._symbolSourceCaches : this._otherSourceCaches)[e] = o,
                    o.style = this,
                    o.onAdd(this.map)
                }
                ;
                o(!1),
                "vector" !== i.type && "geojson" !== i.type || o(!0),
                n.onAdd && n.onAdd(this.map),
                this._changed = !0
            }
            removeSource(e) {
                this._checkLoaded();
                const i = this.getSource(e);
                if (!i)
                    throw new Error("There is no source with this ID");
                for (const i in this._layers)
                    if (this._layers[i].source === e)
                        return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.get().source === e)
                    return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while terrain is using it.`)));
                const r = this._getSourceCaches(e);
                for (const e of r)
                    delete this._sourceCaches[e.id],
                    delete this._updatedSources[e.id],
                    e.fire(new t.Event("data",{
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: e.getSource().id
                    })),
                    e.setEventedParent(null),
                    e.clearTiles();
                return delete this._otherSourceCaches[e],
                delete this._symbolSourceCaches[e],
                i.setEventedParent(null),
                i.onRemove && i.onRemove(this.map),
                this._changed = !0,
                this
            }
            setGeoJSONSourceData(t, e) {
                this._checkLoaded(),
                this.getSource(t).setData(e),
                this._changed = !0
            }
            getSource(t) {
                const e = this._getSourceCache(t);
                return e && e.getSource()
            }
            _getSources() {
                const t = [];
                for (const e in this._otherSourceCaches) {
                    const i = this._getSourceCache(e);
                    i && t.push(i.getSource())
                }
                return t
            }
            addLayer(e, i, r={}) {
                this._checkLoaded();
                const n = e.id;
                if (this.getLayer(n))
                    return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${n}" already exists on this map`)));
                let o;
                if ("custom" === e.type) {
                    if (qe(this, t.validateCustomStyleLayer(e)))
                        return;
                    o = t.createStyleLayer(e)
                } else {
                    if ("object" == typeof e.source && (this.addSource(n, e.source),
                    e = t.clone$1(e),
                    e = t.extend(e, {
                        source: n
                    })),
                    this._validate(t.validateLayer, `layers.${n}`, e, {
                        arrayIndex: -1
                    }, r))
                        return;
                    o = t.createStyleLayer(e),
                    this._validateLayer(o),
                    o.setEventedParent(this, {
                        layer: {
                            id: n
                        }
                    }),
                    this._serializedLayers[o.id] = o.serialize(),
                    this._updateLayerCount(o, !0)
                }
                const s = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s)
                    return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                this._order.splice(s, 0, n),
                this._layerOrderChanged = !0,
                this._layers[n] = o;
                const a = this._getLayerSourceCache(o);
                if (this._removedLayers[n] && o.source && a && "custom" !== o.type) {
                    const t = this._removedLayers[n];
                    delete this._removedLayers[n],
                    t.type !== o.type ? this._updatedSources[o.source] = "clear" : (this._updatedSources[o.source] = "reload",
                    a.pause())
                }
                this._updateLayer(o),
                o.onAdd && o.onAdd(this.map),
                this._updateDrapeFirstLayers()
            }
            moveLayer(e, i) {
                if (this._checkLoaded(),
                this._changed = !0,
                !this._layers[e])
                    return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                if (e === i)
                    return;
                const r = this._order.indexOf(e);
                this._order.splice(r, 1);
                const n = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === n ? this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(n, 0, e),
                this._layerOrderChanged = !0,
                this._updateDrapeFirstLayers())
            }
            removeLayer(e) {
                this._checkLoaded();
                const i = this._layers[e];
                if (!i)
                    return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be removed.`)));
                i.setEventedParent(null),
                this._updateLayerCount(i, !1);
                const r = this._order.indexOf(e);
                this._order.splice(r, 1),
                this._layerOrderChanged = !0,
                this._changed = !0,
                this._removedLayers[e] = i,
                delete this._layers[e],
                delete this._serializedLayers[e],
                delete this._updatedLayers[e],
                delete this._updatedPaintProps[e],
                i.onRemove && i.onRemove(this.map),
                this._updateDrapeFirstLayers()
            }
            getLayer(t) {
                return this._layers[t]
            }
            hasLayer(t) {
                return t in this._layers
            }
            hasLayerType(t) {
                for (const e in this._layers)
                    if (this._layers[e].type === t)
                        return !0;
                return !1
            }
            setLayerZoomRange(e, i, r) {
                this._checkLoaded();
                const n = this.getLayer(e);
                n ? n.minzoom === i && n.maxzoom === r || (null != i && (n.minzoom = i),
                null != r && (n.maxzoom = r),
                this._updateLayer(n)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot have zoom extent.`)))
            }
            setFilter(i, r, n={}) {
                this._checkLoaded();
                const o = this.getLayer(i);
                if (o) {
                    if (!e(o.filter, r))
                        return null == r ? (o.filter = void 0,
                        void this._updateLayer(o)) : void (this._validate(t.validateFilter, `layers.${o.id}.filter`, r, {
                            layerType: o.type
                        }, n) || (o.filter = t.clone$1(r),
                        this._updateLayer(o)))
                } else
                    this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)))
            }
            getFilter(e) {
                const i = this.getLayer(e);
                return i && t.clone$1(i.filter)
            }
            setLayoutProperty(i, r, n, o={}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? e(s.getLayoutProperty(r), n) || (s.setLayoutProperty(r, n, o),
                this._updateLayer(s)) : this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)))
            }
            getLayoutProperty(e, i) {
                const r = this.getLayer(e);
                if (r)
                    return r.getLayoutProperty(i);
                this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style.`)))
            }
            setPaintProperty(i, r, n, o={}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? e(s.getPaintProperty(r), n) || (s.setPaintProperty(r, n, o) && this._updateLayer(s),
                this._changed = !0,
                this._updatedPaintProps[i] = !0) : this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)))
            }
            getPaintProperty(t, e) {
                const i = this.getLayer(t);
                return i && i.getPaintProperty(e)
            }
            setFeatureState(e, i) {
                this._checkLoaded();
                const r = e.source
                  , n = e.sourceLayer
                  , o = this.getSource(r);
                if (!o)
                    return void this.fire(new t.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`)));
                const s = o.type;
                if ("geojson" === s && n)
                    return void this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === s && !n)
                    return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided.")));
                const a = this._getSourceCaches(r);
                for (const t of a)
                    t.setFeatureState(n, e.id, i)
            }
            removeFeatureState(e, i) {
                this._checkLoaded();
                const r = e.source
                  , n = this.getSource(r);
                if (!n)
                    return void this.fire(new t.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`)));
                const o = n.type
                  , s = "vector" === o ? e.sourceLayer : void 0;
                if ("vector" === o && !s)
                    return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof e.id && "number" != typeof e.id)
                    return void this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                const a = this._getSourceCaches(r);
                for (const t of a)
                    t.removeFeatureState(s, e.id, i)
            }
            getFeatureState(e) {
                this._checkLoaded();
                const i = e.source
                  , r = e.sourceLayer
                  , n = this.getSource(i);
                if (n) {
                    if ("vector" !== n.type || r)
                        return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),
                        this._getSourceCaches(i)[0].getFeatureState(r, e.id);
                    this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")))
                } else
                    this.fire(new t.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)))
            }
            getTransition() {
                return t.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition)
            }
            serialize() {
                const e = {};
                for (const t in this._sourceCaches) {
                    const i = this._sourceCaches[t].getSource();
                    e[i.id] || (e[i.id] = i.serialize())
                }
                return t.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: e,
                    layers: this._serializeLayers(this._order)
                }, (t=>void 0 !== t))
            }
            _updateLayer(t) {
                this._updatedLayers[t.id] = !0;
                const e = this._getLayerSourceCache(t);
                t.source && !this._updatedSources[t.source] && e && "raster" !== e.getSource().type && (this._updatedSources[t.source] = "reload",
                e.pause()),
                this._changed = !0,
                t.invalidateCompiledFilter()
            }
            _flattenAndSortRenderedFeatures(t) {
                const e = t=>"fill-extrusion" === this._layers[t].type
                  , i = {}
                  , r = [];
                for (let n = this._order.length - 1; n >= 0; n--) {
                    const o = this._order[n];
                    if (e(o)) {
                        i[o] = n;
                        for (const e of t) {
                            const t = e[o];
                            if (t)
                                for (const e of t)
                                    r.push(e)
                        }
                    }
                }
                r.sort(((t,e)=>e.intersectionZ - t.intersectionZ));
                const n = [];
                for (let o = this._order.length - 1; o >= 0; o--) {
                    const s = this._order[o];
                    if (e(s))
                        for (let t = r.length - 1; t >= 0; t--) {
                            const e = r[t].feature;
                            if (i[e.layer.id] < o)
                                break;
                            n.push(e),
                            r.pop()
                        }
                    else
                        for (const e of t) {
                            const t = e[s];
                            if (t)
                                for (const e of t)
                                    n.push(e.feature)
                        }
                }
                return n
            }
            queryRenderedFeatures(e, i, r) {
                i && i.filter && this._validate(t.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                const n = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers))
                        return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),
                        [];
                    for (const e of i.layers) {
                        const i = this._layers[e];
                        if (!i)
                            return this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))),
                            [];
                        n[i.source] = !0
                    }
                }
                const o = [];
                i.availableImages = this._availableImages;
                const s = i && i.layers ? i.layers.some((t=>{
                    const e = this.getLayer(t);
                    return e && e.is3D()
                }
                )) : this.has3DLayers()
                  , a = L.createFromScreenPoints(e, r);
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t].getSource().id;
                    i.layers && !n[e] || o.push(Lt(this._sourceCaches[t], this._layers, this._serializedLayers, a, i, r, s, !!this.map._showQueryGeometry))
                }
                return this.placement && o.push(function(t, e, i, r, n, o, s) {
                    const a = {}
                      , l = o.queryRenderedSymbols(r)
                      , c = [];
                    for (const t of Object.keys(l).map(Number))
                        c.push(s[t]);
                    c.sort(Rt);
                    for (const i of c) {
                        const r = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, n.filter, n.layers, n.availableImages, t);
                        for (const t in r) {
                            const e = a[t] = a[t] || []
                              , n = r[t];
                            n.sort(((t,e)=>{
                                const r = i.featureSortOrder;
                                if (r) {
                                    const i = r.indexOf(t.featureIndex);
                                    return r.indexOf(e.featureIndex) - i
                                }
                                return e.featureIndex - t.featureIndex
                            }
                            ));
                            for (const t of n)
                                e.push(t)
                        }
                    }
                    for (const e in a)
                        a[e].forEach((r=>{
                            const n = r.feature
                              , o = i(t[e]).getFeatureState(n.layer["source-layer"], n.id);
                            n.source = n.layer.source,
                            n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]),
                            n.state = o
                        }
                        ));
                    return a
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)),
                this._flattenAndSortRenderedFeatures(o)
            }
            querySourceFeatures(e, i) {
                i && i.filter && this._validate(t.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                const r = this._getSourceCaches(e);
                let n = [];
                for (const t of r)
                    n = n.concat(Ot(t, i));
                return n
            }
            addSourceType(t, e, i) {
                return Ke.getSourceType(t) ? i(new Error(`A source type called "${t}" already exists.`)) : (Ke.setSourceType(t, e),
                e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: t,
                    url: e.workerSourceURL
                }, i) : i(null, null))
            }
            getLight() {
                return this.light.getLight()
            }
            setLight(t, i={}) {
                this._checkLoaded();
                const r = this.light.getLight();
                let n = !1;
                for (const i in t)
                    if (!e(t[i], r[i])) {
                        n = !0;
                        break
                    }
                if (!n)
                    return;
                const o = this._setTransitionParameters({
                    duration: 300,
                    delay: 0
                });
                this.light.setLight(t, i),
                this.light.updateTransitions(o)
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0)
            }
            setTerrain(i, r=1) {
                if (this._checkLoaded(),
                !i)
                    return delete this.terrain,
                    delete this.stylesheet.terrain,
                    this.dispatcher.broadcast("enableTerrain", !1),
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0);
                if (1 === r) {
                    if ("object" == typeof i.source) {
                        const e = "terrain-dem-src";
                        this.addSource(e, i.source),
                        i = t.clone$1(i),
                        i = t.extend(i, {
                            source: e
                        })
                    }
                    if (this._validate(t.validateTerrain, "terrain", i))
                        return
                }
                if (!this.terrain || this.terrain && r !== this.terrain.drapeRenderMode)
                    this._createTerrain(i, r);
                else {
                    const r = this.terrain
                      , n = r.get();
                    for (const e of Object.keys(t.spec.terrain))
                        !i.hasOwnProperty(e) && t.spec.terrain[e].default && (i[e] = t.spec.terrain[e].default);
                    for (const t in i)
                        if (!e(i[t], n[t])) {
                            r.set(i),
                            this.stylesheet.terrain = i;
                            const t = this._setTransitionParameters({
                                duration: 0
                            });
                            r.updateTransitions(t);
                            break
                        }
                }
                this._updateDrapeFirstLayers(),
                this._markersNeedUpdate = !0
            }
            _createFog(t) {
                const e = this.fog = new D(t,this.map.transform);
                this.stylesheet.fog = t;
                const i = this._setTransitionParameters({
                    duration: 0
                });
                e.updateTransitions(i)
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask((()=>{
                    for (const t of this.map._markers)
                        t._evaluateOpacity()
                }
                ))
            }
            getFog() {
                return this.fog ? this.fog.get() : null
            }
            setFog(t) {
                if (this._checkLoaded(),
                !t)
                    return delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog
                      , r = i.get();
                    0 === Object.keys(t).length && i.set(t);
                    for (const n in t)
                        if (!e(t[n], r[n])) {
                            i.set(t),
                            this.stylesheet.fog = t;
                            const e = this._setTransitionParameters({
                                duration: 0
                            });
                            i.updateTransitions(e);
                            break
                        }
                } else
                    this._createFog(t);
                this._markersNeedUpdate = !0
            }
            _setTransitionParameters(e) {
                return {
                    now: t.exported.now(),
                    transition: t.extend(e, this.stylesheet.transition)
                }
            }
            _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain)
                    return;
                const t = this._order.filter((t=>this.isLayerDraped(this._layers[t])))
                  , e = this._order.filter((t=>!this.isLayerDraped(this._layers[t])));
                this._drapedFirstOrder = [],
                this._drapedFirstOrder.push(...t),
                this._drapedFirstOrder.push(...e)
            }
            _createTerrain(t, e) {
                const i = this.terrain = new S(t,e);
                this.stylesheet.terrain = t,
                this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()),
                this._force3DLayerUpdate();
                const r = this._setTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(r)
            }
            _force3DLayerUpdate() {
                for (const t in this._layers) {
                    const e = this._layers[t];
                    "fill-extrusion" === e.type && this._updateLayer(e)
                }
            }
            _forceSymbolLayerUpdate() {
                for (const t in this._layers) {
                    const e = this._layers[t];
                    "symbol" === e.type && this._updateLayer(e)
                }
            }
            _validate(e, i, r, n, o={}) {
                return (!o || !1 !== o.validate) && qe(this, e.call(t.validateStyle, t.extend({
                    key: i,
                    style: this.serialize(),
                    value: r,
                    styleSpec: t.spec
                }, n)))
            }
            _remove() {
                this._request && (this._request.cancel(),
                this._request = null),
                this._spriteRequest && (this._spriteRequest.cancel(),
                this._spriteRequest = null),
                t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for (const t in this._layers)
                    this._layers[t].setEventedParent(null);
                for (const t in this._sourceCaches)
                    this._sourceCaches[t].clearTiles(),
                    this._sourceCaches[t].setEventedParent(null);
                this.imageManager.setEventedParent(null),
                this.setEventedParent(null),
                this.dispatcher.remove()
            }
            _clearSource(t) {
                const e = this._getSourceCaches(t);
                for (const t of e)
                    t.clearTiles()
            }
            _reloadSource(t) {
                const e = this._getSourceCaches(t);
                for (const t of e)
                    t.resume(),
                    t.reload()
            }
            _reloadSources() {
                for (const t of this._getSources())
                    t.reload && t.reload()
            }
            _updateSources(t) {
                for (const e in this._sourceCaches)
                    this._sourceCaches[e].update(t)
            }
            _generateCollisionBoxes() {
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t];
                    e.resume(),
                    e.reload()
                }
            }
            _updatePlacement(e, i, r, n, o=!1) {
                let s = !1
                  , a = !1;
                const l = {};
                for (const t of this._order) {
                    const i = this._layers[t];
                    if ("symbol" !== i.type)
                        continue;
                    if (!l[i.source]) {
                        const t = this._getLayerSourceCache(i);
                        if (!t)
                            continue;
                        l[i.source] = t.getRenderableIds(!0).map((e=>t.getTileByID(e))).sort(((t,e)=>e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1)))
                    }
                    const r = this.crossTileSymbolIndex.addLayer(i, l[i.source], e.center.lng, e.projection);
                    s = s || r
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                o = o || this._layerOrderChanged || 0 === r,
                this._layerOrderChanged && this.fire(new t.Event("neworder")),
                (o || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e.zoom)) && (this.pauseablePlacement = new Ge(e,this._order,o,i,r,n,this.placement,this.fog && e.projection.supportsFog ? this.fog.state : null),
                this._layerOrderChanged = !1),
                this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l),
                this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()),
                a = !0),
                s && this.pauseablePlacement.placement.setStale()),
                a || s)
                    for (const t of this._order) {
                        const e = this._layers[t];
                        "symbol" === e.type && this.placement.updateLayerOpacities(e, l[e.source])
                    }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now())
            }
            _releaseSymbolFadeTiles() {
                for (const t in this._sourceCaches)
                    this._sourceCaches[t].releaseSymbolFadeTiles()
            }
            getImages(t, e, i) {
                this.imageManager.getImages(e.icons, i),
                this._updateTilesForChangedImages();
                const r = t=>{
                    t && t.setDependencies(e.tileID.key, e.type, e.icons)
                }
                ;
                r(this._otherSourceCaches[e.source]),
                r(this._symbolSourceCaches[e.source])
            }
            getGlyphs(t, e, i) {
                this.glyphManager.getGlyphs(e.stacks, i)
            }
            getResource(e, i, r) {
                return t.makeRequest(i, r)
            }
            _getSourceCache(t) {
                return this._otherSourceCaches[t]
            }
            _getLayerSourceCache(t) {
                return "symbol" === t.type ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source]
            }
            _getSourceCaches(t) {
                const e = [];
                return this._otherSourceCaches[t] && e.push(this._otherSourceCaches[t]),
                this._symbolSourceCaches[t] && e.push(this._symbolSourceCaches[t]),
                e
            }
            _isSourceCacheLoaded(e) {
                const i = this._getSourceCaches(e);
                return 0 === i.length ? (this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e}'`))),
                !1) : i.every((t=>t.loaded()))
            }
            has3DLayers() {
                return this._num3DLayers > 0
            }
            hasSymbolLayers() {
                return this._numSymbolLayers > 0
            }
            hasCircleLayers() {
                return this._numCircleLayers > 0
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches")
            }
            destroy() {
                this._clearWorkerCaches(),
                this.terrainSetForDrapingOnly() && (delete this.terrain,
                delete this.stylesheet.terrain)
            }
        }
        Ke.getSourceType = function(t) {
            return Dt[t]
        }
        ,
        Ke.setSourceType = function(t, e) {
            Dt[t] = e
        }
        ,
        Ke.registerForPluginStateChange = t.registerForPluginStateChange;
        var Qe = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0"
          , ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}"
          , ei = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif"
          , ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif"
          , ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let ni = {}
          , oi = {};
        const si = [];
        hi(Qe, si),
        hi(ei, si),
        hi(ii, si),
        hi(ri, si),
        ni = di("", ei),
        oi = di(ri, ii);
        const ai = di("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.")
          , li = Qe
          , ci = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ui = {
            background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
            clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
            fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
            hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
            symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
            symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
            terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
            terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
            skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
            skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;\n#ifdef GLOBE_POLES\nvec3 up_vector=normalize(globe_pos)*u_tile_up_scale;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
            globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
        };
        function hi(t, e) {
            const i = t.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let t of i)
                if (t = t.trim(),
                "#" === t[0] && t.includes("if") && !t.includes("endif")) {
                    t = t.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                    const i = t.split(" ");
                    for (const t of i)
                        e.includes(t) || e.push(t)
                }
        }
        function di(t, e) {
            const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
              , r = e.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g)
              , n = {}
              , o = [...si];
            return hi(t, o),
            hi(e, o),
            {
                fragmentSource: t = t.replace(i, ((t,e,i,r,o)=>(n[o] = !0,
                "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nvarying ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = u_${o};\n#endif\n`))),
                vertexSource: e = e.replace(i, ((t,e,i,r,o)=>{
                    const s = "float" === r ? "vec2" : "vec4"
                      , a = o.match(/color/) ? "color" : s;
                    return n[o] ? "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${s} a_${o};\nvarying ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${s} a_${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n`
                }
                )),
                staticAttributes: r,
                usedDefines: o
            }
        }
        class pi {
            constructor() {
                this.boundProgram = null,
                this.boundLayoutVertexBuffer = null,
                this.boundPaintVertexBuffers = [],
                this.boundIndexBuffer = null,
                this.boundVertexOffset = null,
                this.boundDynamicVertexBuffers = [],
                this.vao = null
            }
            bind(t, e, i, r, n, o, s) {
                this.context = t;
                let a = this.boundPaintVertexBuffers.length !== r.length;
                for (let t = 0; !a && t < r.length; t++)
                    this.boundPaintVertexBuffers[t] !== r[t] && (a = !0);
                let l = this.boundDynamicVertexBuffers.length !== s.length;
                for (let t = 0; !l && t < s.length; t++)
                    this.boundDynamicVertexBuffers[t] !== s[t] && (l = !0);
                if (!t.extVertexArrayObject || !this.vao || this.boundProgram !== e || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== n || this.boundVertexOffset !== o)
                    this.freshBind(e, i, r, n, o, s);
                else {
                    t.bindVertexArrayOES.set(this.vao);
                    for (const t of s)
                        t && t.bind();
                    n && n.dynamicDraw && n.bind()
                }
            }
            freshBind(t, e, i, r, n, o) {
                let s;
                const a = t.numAttributes
                  , l = this.context
                  , c = l.gl;
                if (l.extVertexArrayObject)
                    this.vao && this.destroy(),
                    this.vao = l.extVertexArrayObject.createVertexArrayOES(),
                    l.bindVertexArrayOES.set(this.vao),
                    s = 0,
                    this.boundProgram = t,
                    this.boundLayoutVertexBuffer = e,
                    this.boundPaintVertexBuffers = i,
                    this.boundIndexBuffer = r,
                    this.boundVertexOffset = n,
                    this.boundDynamicVertexBuffers = o;
                else {
                    s = l.currentNumAttributes || 0;
                    for (let t = a; t < s; t++)
                        c.disableVertexAttribArray(t)
                }
                e.enableAttributes(c, t),
                e.bind(),
                e.setVertexAttribPointers(c, t, n);
                for (const e of i)
                    e.enableAttributes(c, t),
                    e.bind(),
                    e.setVertexAttribPointers(c, t, n);
                for (const e of o)
                    e && (e.enableAttributes(c, t),
                    e.bind(),
                    e.setVertexAttribPointers(c, t, n));
                r && r.bind(),
                l.currentNumAttributes = a
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),
                this.vao = null)
            }
        }
        function mi(e, i) {
            const r = Math.pow(2, i.canonical.z)
              , n = i.canonical.y;
            return [new t.MercatorCoordinate(0,n / r).toLngLat().lat, new t.MercatorCoordinate(0,(n + 1) / r).toLngLat().lat]
        }
        function fi(e, i, r, n, o, s, a) {
            const l = e.context
              , c = l.gl
              , u = r.fbo;
            if (!u)
                return;
            e.prepareDrawTile();
            const h = e.useProgram("hillshade");
            l.activeTexture.set(c.TEXTURE0),
            c.bindTexture(c.TEXTURE_2D, u.colorAttachment.get());
            const d = ((t,e,i,r)=>{
                const n = i.paint.get("hillshade-shadow-color")
                  , o = i.paint.get("hillshade-highlight-color")
                  , s = i.paint.get("hillshade-accent-color");
                let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= t.transform.angle);
                const l = !t.options.moving;
                return {
                    u_matrix: r || t.transform.calculateProjMatrix(e.tileID.toUnwrapped(), l),
                    u_image: 0,
                    u_latrange: mi(0, e.tileID),
                    u_light: [i.paint.get("hillshade-exaggeration"), a],
                    u_shadow: n,
                    u_highlight: o,
                    u_accent: s
                }
            }
            )(e, r, n, e.terrain ? i.projMatrix : null);
            e.prepareDrawProgram(l, h, i.toUnwrapped());
            const {tileBoundsBuffer: p, tileBoundsIndexBuffer: m, tileBoundsSegments: f} = e.getTileBoundsBuffers(r);
            h.draw(l, c.TRIANGLES, o, s, a, t.CullFaceMode.disabled, d, n.id, p, m, f)
        }
        function _i(e, i, r) {
            if (!i.needsDEMTextureUpload)
                return;
            const n = e.context
              , o = n.gl;
            n.pixelStoreUnpackPremultiplyAlpha.set(!1),
            i.demTexture = i.demTexture || e.getTileTexture(r.stride);
            const s = r.getPixels();
            i.demTexture ? i.demTexture.update(s, {
                premultiply: !1
            }) : i.demTexture = new t.Texture(n,s,o.RGBA,{
                premultiply: !1
            }),
            i.needsDEMTextureUpload = !1
        }
        function gi(e, i, r, n, o, s) {
            const a = e.context
              , l = a.gl;
            if (!i.dem)
                return;
            const c = i.dem;
            if (a.activeTexture.set(l.TEXTURE1),
            _i(e, i, c),
            !i.demTexture)
                return;
            i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
            const u = c.dim;
            a.activeTexture.set(l.TEXTURE0);
            let h = i.fbo;
            if (!h) {
                const e = new t.Texture(a,{
                    width: u,
                    height: u,
                    data: null
                },l.RGBA);
                e.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                h = i.fbo = a.createFramebuffer(u, u, !0),
                h.colorAttachment.set(e.texture)
            }
            a.bindFramebuffer.set(h.framebuffer),
            a.viewport.set([0, 0, u, u]);
            const {tileBoundsBuffer: d, tileBoundsIndexBuffer: p, tileBoundsSegments: m} = e.getMercatorTileBoundsBuffers();
            e.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, n, o, s, t.CullFaceMode.disabled, ((e,i)=>{
                const r = i.stride
                  , n = t.create();
                return t.ortho(n, 0, t.EXTENT, -t.EXTENT, 0, 0, 1),
                t.translate(n, n, [0, -t.EXTENT, 0]),
                {
                    u_matrix: n,
                    u_image: 1,
                    u_dimension: [r, r],
                    u_zoom: e.overscaledZ,
                    u_unpack: i.unpackVector
                }
            }
            )(i.tileID, c), r.id, d, p, m),
            i.needsHillshadePrepare = !1
        }
        const yi = e=>({
            u_matrix: new t.UniformMatrix4f(e),
            u_image0: new t.Uniform1i(e),
            u_skirt_height: new t.Uniform1f(e)
        })
          , xi = (t,e)=>({
            u_matrix: t,
            u_image0: 0,
            u_skirt_height: e
        })
          , vi = (t,e,i,r,n,o,s,a,l,c,u,h,d,p)=>({
            u_proj_matrix: Float32Array.from(t),
            u_globe_matrix: e,
            u_normalize_matrix: Float32Array.from(r),
            u_merc_matrix: i,
            u_zoom_transition: n,
            u_merc_center: o,
            u_image0: 0,
            u_frustum_tl: s,
            u_frustum_tr: a,
            u_frustum_br: l,
            u_frustum_bl: c,
            u_globe_pos: u,
            u_globe_radius: h,
            u_viewport: d,
            u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9)
        });
        function bi(t, e) {
            return null != t && null != e && !(!t.hasData() || !e.hasData()) && null != t.demTexture && null != e.demTexture && t.tileID.key !== e.tileID.key
        }
        const wi = new class {
            constructor() {
                this.operations = {}
            }
            newMorphing(t, e, i, r, n) {
                if (t in this.operations) {
                    const e = this.operations[t];
                    e.to.tileID.key !== i.tileID.key && (e.queued = i)
                } else
                    this.operations[t] = {
                        startTime: r,
                        phase: 0,
                        duration: n,
                        from: e,
                        to: i,
                        queued: null
                    }
            }
            getMorphValuesForProxy(t) {
                if (!(t in this.operations))
                    return null;
                const e = this.operations[t];
                return {
                    from: e.from,
                    to: e.to,
                    phase: e.phase
                }
            }
            update(t) {
                for (const e in this.operations) {
                    const i = this.operations[e];
                    for (i.phase = (t - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i); )
                        if (!this._nextOp(i, t)) {
                            delete this.operations[e];
                            break
                        }
                }
            }
            _nextOp(t, e) {
                return !!t.queued && (t.from = t.to,
                t.to = t.queued,
                t.queued = null,
                t.phase = 0,
                t.startTime = e,
                !0)
            }
            _validOp(t) {
                return t.from.hasData() && t.to.hasData()
            }
        }
          , zi = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING",
            2: "TERRAIN_WIREFRAME"
        };
        function Ti(t, e) {
            const i = 1 << t.z;
            return !e && (0 === t.x || t.x === i - 1) || 0 === t.y || t.y === i - 1
        }
        const Ei = t=>({
            u_matrix: t
        });
        function Si(e, i, r, n, o) {
            if (o > 0) {
                const s = t.exported.now()
                  , a = (s - e.timeAdded) / o
                  , l = i ? (s - i.timeAdded) / o : -1
                  , c = r.getSource()
                  , u = n.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                })
                  , h = !i || Math.abs(i.tileID.overscaledZ - u) > Math.abs(e.tileID.overscaledZ - u)
                  , d = h && e.refreshedUponExpiration ? 1 : t.clamp(h ? a : 1 - l, 0, 1);
                return e.refreshedUponExpiration && a >= 1 && (e.refreshedUponExpiration = !1),
                i ? {
                    opacity: 1,
                    mix: 1 - d
                } : {
                    opacity: d,
                    mix: 0
                }
            }
            return {
                opacity: 1,
                mix: 0
            }
        }
        class Mi extends t.SourceCache {
            constructor(t) {
                const e = {
                    type: "raster-dem",
                    maxzoom: t.transform.maxZoom
                }
                  , i = new k(Gt(),null)
                  , r = kt("mock-dem", e, i, t.style);
                super("mock-dem", r, !1),
                r.setEventedParent(this),
                this._sourceLoaded = !0
            }
            _loadTile(t, e) {
                t.state = "loaded",
                e(null)
            }
        }
        class Ai extends t.SourceCache {
            constructor(t) {
                const e = kt("proxy", {
                    type: "geojson",
                    maxzoom: t.transform.maxZoom
                }, new k(Gt(),null), t.style);
                super("proxy", e, !1),
                e.setEventedParent(this),
                this.map = this.getSource().map = t,
                this.used = this._sourceLoaded = !0,
                this.renderCache = [],
                this.renderCachePool = [],
                this.proxyCachedFBO = {}
            }
            update(e, i, r) {
                if (e.freezeTileCoverage)
                    return;
                this.transform = e;
                const n = e.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce(((i,r)=>{
                    if (i[r.key] = "",
                    !this._tiles[r.key]) {
                        const i = new t.Tile(r,this._source.tileSize * r.overscaleFactor(),e.tileZoom);
                        i.state = "loaded",
                        this._tiles[r.key] = i
                    }
                    return i
                }
                ), {});
                for (const t in this._tiles)
                    t in n || (this.freeFBO(t),
                    this._tiles[t].unloadVectorData(),
                    delete this._tiles[t])
            }
            freeFBO(t) {
                const e = this.proxyCachedFBO[t];
                if (void 0 !== e) {
                    const i = Object.values(e);
                    this.renderCachePool.push(...i),
                    delete this.proxyCachedFBO[t]
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((t=>t.fb.destroy())),
                this.renderCache = [],
                this.renderCachePool = [],
                this.proxyCachedFBO = {}
            }
        }
        class Ii extends t.OverscaledTileID {
            constructor(t, e, i) {
                super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y),
                this.proxyTileKey = e,
                this.projMatrix = i
            }
        }
        class Ci extends t.Elevation {
            constructor(e, i) {
                super(),
                this.painter = e,
                this.terrainTileForTile = {},
                this.prevTerrainTileForTile = {};
                const [r,n,o] = function(e) {
                    const i = new t.StructArrayLayout4i8
                      , r = new t.StructArrayLayout3ui6
                      , n = 131;
                    i.reserve(17161),
                    r.reserve(33800);
                    const o = t.EXTENT / 128
                      , s = t.EXTENT + o / 2
                      , a = s + o;
                    for (let e = -o; e < a; e += o)
                        for (let r = -o; r < a; r += o) {
                            const n = r < 0 || r > s || e < 0 || e > s ? 24575 : 0
                              , o = t.clamp(Math.round(r), 0, t.EXTENT)
                              , a = t.clamp(Math.round(e), 0, t.EXTENT);
                            i.emplaceBack(o + n, a, o, a)
                        }
                    const l = (t,e)=>{
                        const i = e * n + t;
                        r.emplaceBack(i + 1, i, i + n),
                        r.emplaceBack(i + n, i + n + 1, i + 1)
                    }
                    ;
                    for (let t = 1; t < 129; t++)
                        for (let e = 1; e < 129; e++)
                            l(e, t);
                    return [0, 129].forEach((t=>{
                        for (let e = 0; e < 130; e++)
                            l(e, t),
                            l(t, e)
                    }
                    )),
                    [i, r, 32768]
                }()
                  , s = e.context;
                this.gridBuffer = s.createVertexBuffer(r, t.boundsAttributes.members),
                this.gridIndexBuffer = s.createIndexBuffer(n),
                this.gridSegments = t.SegmentVector.simpleSegment(0, 0, r.length, n.length),
                this.gridNoSkirtSegments = t.SegmentVector.simpleSegment(0, 0, r.length, o),
                this.proxyCoords = [],
                this.proxiedCoords = {},
                this._visibleDemTiles = [],
                this._drapedRenderBatches = [],
                this._sourceTilesOverlap = {},
                this.proxySourceCache = new Ai(i.map),
                this.orthoMatrix = t.create(),
                t.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, t.EXTENT, 0, t.EXTENT, 0, 1);
                const a = s.gl;
                this._overlapStencilMode = new t.StencilMode({
                    func: a.GEQUAL,
                    mask: 255
                },0,255,a.KEEP,a.KEEP,a.REPLACE),
                this._previousZoom = e.transform.zoom,
                this.pool = [],
                this._findCoveringTileCache = {},
                this._tilesDirty = {},
                this.style = i,
                this._useVertexMorphing = !0,
                this._exaggeration = 1,
                this._mockSourceCache = new Mi(i.map)
            }
            set style(t) {
                t.on("data", this._onStyleDataEvent.bind(this)),
                t.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                this._style = t,
                this._checkRenderCacheEfficiency()
            }
            update(e, i, r) {
                if (e && e.terrain) {
                    this._style !== e && (this.style = e),
                    this.enabled = !0;
                    const n = e.terrain.properties;
                    this.sourceCache = 0 === e.terrain.drapeRenderMode ? this._mockSourceCache : e._getSourceCache(n.get("source")),
                    this._exaggeration = n.get("exaggeration");
                    const o = ()=>{
                        this.sourceCache.used && t.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const e = this.getScaledDemTileSize();
                        this.sourceCache.update(i, e, !0),
                        this.resetTileLookupCache(this.sourceCache.id)
                    }
                    ;
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id),
                    this.sourceCache.usedForTerrain = !0,
                    o(),
                    this._initializing = !0),
                    o(),
                    i.updateElevation(!0, r),
                    this.resetTileLookupCache(this.proxySourceCache.id),
                    this.proxySourceCache.update(i),
                    this._emptyDEMTextureDirty = !0
                } else
                    this._disable()
            }
            resetTileLookupCache(t) {
                this._findCoveringTileCache[t] = {}
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
            }
            _checkRenderCacheEfficiency() {
                const e = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain || 100 !== e.efficiency && t.warnOnce(`Terrain render cache efficiency is not optimal (${e.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${e.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`)
            }
            _onStyleDataEvent(t) {
                t.coord && "source" === t.dataType ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : "style" === t.dataType && (this._invalidateRenderCache = !0)
            }
            _disable() {
                if (this.enabled && (this.enabled = !1,
                this._sharedDepthStencil = void 0,
                this.proxySourceCache.deallocRenderCache(),
                this._style))
                    for (const t in this._style._sourceCaches)
                        this._style._sourceCaches[t].usedForTerrain = !1
            }
            destroy() {
                this._disable(),
                this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(),
                this.pool.forEach((t=>t.fb.destroy())),
                this.pool = [],
                this._depthFBO && (this._depthFBO.destroy(),
                this._depthFBO = void 0,
                this._depthTexture = void 0)
            }
            _source() {
                return this.enabled ? this.sourceCache : null
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache
            }
            exaggeration() {
                return this._exaggeration
            }
            get visibleDemTiles() {
                return this._visibleDemTiles
            }
            get drapeBufferSize() {
                const t = 2 * this.proxySourceCache.getSource().tileSize;
                return [t, t]
            }
            set useVertexMorphing(t) {
                this._useVertexMorphing = t
            }
            updateTileBinding(e) {
                if (!this.enabled)
                    return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache
                  , r = this.painter.transform;
                this._initializing && (this._initializing = 0 === r._centerAltitude && -1 === this.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(r.center), -1),
                this._emptyDEMTextureDirty = !this._initializing);
                const n = this.proxyCoords = i.getIds().map((t=>{
                    const e = i.getTileByID(t).tileID;
                    return e.projMatrix = r.calculateProjMatrix(e.toUnwrapped()),
                    e
                }
                ));
                !function(e, i) {
                    const r = i.transform.pointCoordinate(i.transform.getCameraPoint())
                      , n = new t.pointGeometry(r.x,r.y);
                    e.sort(((e,i)=>{
                        if (i.overscaledZ - e.overscaledZ)
                            return i.overscaledZ - e.overscaledZ;
                        const r = new t.pointGeometry(e.canonical.x + (1 << e.canonical.z) * e.wrap,e.canonical.y)
                          , o = new t.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap,i.canonical.y)
                          , s = n.mult(1 << e.canonical.z);
                        return s.x -= .5,
                        s.y -= .5,
                        s.distSqr(r) - s.distSqr(o)
                    }
                    ))
                }(n, this.painter),
                this._previousZoom = r.zoom;
                const o = this.proxyToSource || {};
                this.proxyToSource = {},
                n.forEach((t=>{
                    this.proxyToSource[t.key] = {}
                }
                )),
                this.terrainTileForTile = {};
                const s = this._style._sourceCaches;
                for (const t in s) {
                    const i = s[t];
                    if (!i.used)
                        continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id),
                    this._setupProxiedCoordsForOrtho(i, e[t], o),
                    i.usedForTerrain)
                        continue;
                    const r = e[t];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(r)
                }
                this.proxiedCoords[i.id] = n.map((t=>new Ii(t,t.key,this.orthoMatrix))),
                this._assignTerrainTiles(n),
                this._prepareDEMTextures(),
                this._setupDrapedRenderBatches(),
                this._initFBOPool(),
                this._setupRenderCache(o),
                this.renderingToTexture = !1,
                this._updateTimestamp = t.exported.now();
                const a = {};
                this._visibleDemTiles = [];
                for (const t of this.proxyCoords) {
                    const e = this.terrainTileForTile[t.key];
                    if (!e)
                        continue;
                    const i = e.tileID.key;
                    i in a || (this._visibleDemTiles.push(e),
                    a[i] = i)
                }
            }
            _assignTerrainTiles(t) {
                this._initializing || t.forEach((t=>{
                    if (this.terrainTileForTile[t.key])
                        return;
                    const e = this._findTileCoveringTileID(t, this.sourceCache);
                    e && (this.terrainTileForTile[t.key] = e)
                }
                ))
            }
            _prepareDEMTextures() {
                const t = this.painter.context
                  , e = t.gl;
                for (const i in this.terrainTileForTile) {
                    const r = this.terrainTileForTile[i]
                      , n = r.dem;
                    !n || r.demTexture && !r.needsDEMTextureUpload || (t.activeTexture.set(e.TEXTURE1),
                    _i(this.painter, r, n))
                }
            }
            _prepareDemTileUniforms(t, e, i, r) {
                if (!e || null == e.demTexture)
                    return !1;
                const n = t.tileID.canonical
                  , o = Math.pow(2, e.tileID.canonical.z - n.z)
                  , s = r || "";
                return i[`u_dem_tl${s}`] = [n.x * o % 1, n.y * o % 1],
                i[`u_dem_scale${s}`] = o,
                !0
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
            }
            get emptyDepthBufferTexture() {
                const e = this.painter.context
                  , i = e.gl;
                if (!this._emptyDepthBufferTexture) {
                    const r = new t.RGBAImage({
                        width: 1,
                        height: 1
                    },Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new t.Texture(e,r,i.RGBA,{
                        premultiply: !1
                    })
                }
                return this._emptyDepthBufferTexture
            }
            _getLoadedAreaMinimum() {
                let t = 0;
                const e = this._visibleDemTiles.reduce(((e,i)=>{
                    if (!i.dem)
                        return e;
                    const r = i.dem.tree.minimums[0];
                    return r > 0 && t++,
                    e + r
                }
                ), 0);
                return t ? e / t : 0
            }
            _updateEmptyDEMTexture() {
                const e = this.painter.context
                  , i = e.gl;
                e.activeTexture.set(i.TEXTURE2);
                const r = this._getLoadedAreaMinimum()
                  , n = new t.RGBAImage({
                    width: 1,
                    height: 1
                },new Uint8Array(t.DEMData.pack(r, this.sourceCache.getSource().encoding)));
                this._emptyDEMTextureDirty = !1;
                let o = this._emptyDEMTexture;
                return o ? o.update(n, {
                    premultiply: !1
                }) : o = this._emptyDEMTexture = new t.Texture(e,n,i.RGBA,{
                    premultiply: !1
                }),
                o
            }
            setupElevationDraw(e, i, r) {
                const n = this.painter.context
                  , o = n.gl
                  , s = (a = this.sourceCache.getSource().encoding,
                {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_unpack: t.DEMData.getUnpackVector(a),
                    u_dem_tl: [0, 0],
                    u_dem_tl_prev: [0, 0],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [0, 0],
                    u_exaggeration: 0
                });
                var a;
                s.u_dem_size = this.sourceCache.getSource().tileSize,
                s.u_exaggeration = this.exaggeration();
                let l = null
                  , c = null
                  , u = 1;
                if (r && r.morphing && this._useVertexMorphing) {
                    const t = r.morphing.srcDemTile
                      , i = r.morphing.dstDemTile;
                    u = r.morphing.phase,
                    t && i && (this._prepareDemTileUniforms(e, t, s, "_prev") && (c = t),
                    this._prepareDemTileUniforms(e, i, s) && (l = i))
                }
                if (c && l ? (n.activeTexture.set(o.TEXTURE2),
                l.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                n.activeTexture.set(o.TEXTURE4),
                c.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                s.u_dem_lerp = u) : (l = this.terrainTileForTile[e.tileID.key],
                n.activeTexture.set(o.TEXTURE2),
                (this._prepareDemTileUniforms(e, l, s) ? l.demTexture : this.emptyDEMTexture).bind(o.NEAREST, o.CLAMP_TO_EDGE)),
                n.activeTexture.set(o.TEXTURE3),
                r && r.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE),
                this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE),
                s.u_depth_size_inv = [1, 1]),
                r && r.useMeterToDem && l) {
                    const e = (1 << l.tileID.canonical.z) * t.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    s.u_meter_to_dem = e
                }
                if (r && r.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = r.labelPlaneMatrixInv),
                i.setTerrainUniformValues(n, s),
                "globe" === this.painter.transform.projection.name) {
                    const t = this.globeUniformValues(this.painter.transform, e.tileID.canonical, r && r.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(n, t)
                }
            }
            globeUniformValues(e, i, r) {
                const n = e.projection;
                return {
                    u_tile_tl_up: n.upVector(i, 0, 0),
                    u_tile_tr_up: n.upVector(i, t.EXTENT, 0),
                    u_tile_br_up: n.upVector(i, t.EXTENT, t.EXTENT),
                    u_tile_bl_up: n.upVector(i, 0, t.EXTENT),
                    u_tile_up_scale: r ? t.GLOBE_METERS_TO_ECEF : n.upVectorScale(i, e.center.lat, e.worldSize).metersToTile
                }
            }
            renderToBackBuffer(e) {
                const i = this.painter
                  , r = this.painter.context;
                0 !== e.length && (r.bindFramebuffer.set(null),
                r.viewport.set([0, 0, i.width, i.height]),
                i.gpuTimingDeferredRenderStart(),
                this.renderingToTexture = !1,
                function(e, i, r, n, o) {
                    if ("globe" === e.transform.projection.name)
                        !function(e, i, r, n, o) {
                            const s = e.context
                              , a = s.gl;
                            let l, c;
                            const u = e.options.showTerrainWireframe ? 2 : 0
                              , h = e.transform
                              , d = t.globeUseCustomAntiAliasing(e, s, h)
                              , p = (t,i)=>{
                                if (c === t)
                                    return;
                                const r = [zi[t], "PROJECTION_GLOBE_VIEW"];
                                d && r.push("CUSTOM_ANTIALIASING"),
                                i && r.push(zi[u]),
                                l = e.useProgram("globeRaster", null, r),
                                c = t
                            }
                              , m = e.colorModeForRenderPass()
                              , f = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                            wi.update(o);
                            const _ = t.calculateGlobeMercatorMatrix(h)
                              , g = [t.mercatorXfromLng(h.center.lng), t.mercatorYfromLat(h.center.lat)]
                              , y = u ? [!1, !0] : [!1]
                              , x = e.globeSharedBuffers
                              , v = [h.width * t.exported.devicePixelRatio, h.height * t.exported.devicePixelRatio]
                              , b = Float32Array.from(h.globeMatrix)
                              , w = {
                                useDenormalizedUpVectorScale: !0
                            };
                            if (y.forEach((u=>{
                                c = -1;
                                const d = u ? a.LINES : a.TRIANGLES;
                                for (const c of n) {
                                    const n = r.getTile(c)
                                      , y = t.StencilMode.disabled
                                      , z = i.prevTerrainTileForTile[c.key]
                                      , T = i.terrainTileForTile[c.key];
                                    bi(z, T) && wi.newMorphing(c.key, z, T, o, 250),
                                    s.activeTexture.set(a.TEXTURE0),
                                    n.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    const E = wi.getMorphValuesForProxy(c.key)
                                      , S = E ? 1 : 0;
                                    E && t.extend$1(w, {
                                        morphing: {
                                            srcDemTile: E.from,
                                            dstDemTile: E.to,
                                            phase: t.easeCubicInOut(E.phase)
                                        }
                                    });
                                    const M = t.tileCornersToBounds(c.canonical)
                                      , A = t.getLatitudinalLod(M.getCenter().lat)
                                      , I = t.getGridMatrix(c.canonical, M, A, h.worldSize / h._pixelsPerMercatorPixel)
                                      , C = t.globeNormalizeECEF(t.globeTileBounds(c.canonical))
                                      , D = vi(h.projMatrix, b, _, C, t.globeToMercatorTransition(h.zoom), g, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, I);
                                    if (p(S, u),
                                    i.setupElevationDraw(n, l, w),
                                    e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                    x) {
                                        const [i,r,n] = u ? x.getWirefameBuffers(e.context, A) : x.getGridBuffers(A);
                                        l.draw(s, d, f, y, m, t.CullFaceMode.backCCW, D, "globe_raster", i, r, n)
                                    }
                                }
                            }
                            )),
                            x) {
                                const o = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                d && o.push("CUSTOM_ANTIALIASING"),
                                l = e.useProgram("globeRaster", null, o);
                                for (const o of n) {
                                    const {x: n, y: c, z: u} = o.canonical
                                      , d = 0 === c
                                      , p = c === (1 << u) - 1
                                      , [_,y,b,z] = x.getPoleBuffers(u);
                                    if (z && (d || p)) {
                                        const c = r.getTile(o);
                                        s.activeTexture.set(a.TEXTURE0),
                                        c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                        let x = t.globePoleMatrixForTile(u, n, h);
                                        const T = t.globeNormalizeECEF(t.globeTileBounds(o.canonical))
                                          , E = (e,i)=>e.draw(s, a.TRIANGLES, f, t.StencilMode.disabled, m, t.CullFaceMode.disabled, vi(h.projMatrix, x, x, T, 0, g, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v), "globe_pole_raster", i, b, z);
                                        i.setupElevationDraw(c, l, w),
                                        e.prepareDrawProgram(s, l, o.toUnwrapped()),
                                        d && E(l, _),
                                        p && (x = t.scale(t.create(), x, [1, -1, 1]),
                                        E(l, y))
                                    }
                                }
                            }
                        }(e, i, r, n, o);
                    else {
                        const s = e.context
                          , a = s.gl;
                        let l, c;
                        const u = e.options.showTerrainWireframe ? 2 : 0
                          , h = (t,i)=>{
                            if (c === t)
                                return;
                            const r = [zi[t]];
                            i && r.push(zi[u]),
                            l = e.useProgram("terrainRaster", null, r),
                            c = t
                        }
                          , d = e.colorModeForRenderPass()
                          , p = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                        wi.update(o);
                        const m = e.transform
                          , f = 6 * Math.pow(1.5, 22 - m.zoom) * i.exaggeration();
                        (u ? [!1, !0] : [!1]).forEach((u=>{
                            c = -1;
                            const _ = u ? a.LINES : a.TRIANGLES
                              , [g,y] = u ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];
                            for (const c of n) {
                                const n = r.getTile(c)
                                  , x = t.StencilMode.disabled
                                  , v = i.prevTerrainTileForTile[c.key]
                                  , b = i.terrainTileForTile[c.key];
                                bi(v, b) && wi.newMorphing(c.key, v, b, o, 250),
                                s.activeTexture.set(a.TEXTURE0),
                                n.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                                const w = wi.getMorphValuesForProxy(c.key)
                                  , z = w ? 1 : 0;
                                let T;
                                w && (T = {
                                    morphing: {
                                        srcDemTile: w.from,
                                        dstDemTile: w.to,
                                        phase: t.easeCubicInOut(w.phase)
                                    }
                                });
                                const E = xi(c.projMatrix, Ti(c.canonical, m.renderWorldCopies) ? f / 10 : f);
                                h(z, u),
                                i.setupElevationDraw(n, l, T),
                                e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                l.draw(s, _, p, x, d, t.CullFaceMode.backCCW, E, "terrain_raster", i.gridBuffer, g, y)
                            }
                        }
                        ))
                    }
                }(i, this, this.proxySourceCache, e, this._updateTimestamp),
                this.renderingToTexture = !0,
                i.gpuTimingDeferredRenderEnd(),
                e.splice(0, e.length))
            }
            renderBatch(e) {
                if (0 === this._drapedRenderBatches.length)
                    return e + 1;
                this.renderingToTexture = !0;
                const i = this.painter
                  , r = this.painter.context
                  , n = this.proxySourceCache
                  , o = this.proxiedCoords[n.id]
                  , s = this._drapedRenderBatches.shift()
                  , a = []
                  , l = i.style.order;
                let c = 0;
                for (const u of o) {
                    const o = n.getTileByID(u.proxyTileKey)
                      , h = n.proxyCachedFBO[u.key] ? n.proxyCachedFBO[u.key][e] : void 0
                      , d = void 0 !== h ? n.renderCache[h] : this.pool[c++]
                      , p = void 0 !== h;
                    if (o.texture = d.tex,
                    p && !d.dirty) {
                        a.push(o.tileID);
                        continue
                    }
                    let m;
                    r.bindFramebuffer.set(d.fb.framebuffer),
                    this.renderedToTile = !1,
                    d.dirty && (r.clear({
                        color: t.Color.transparent,
                        stencil: 0
                    }),
                    d.dirty = !1);
                    for (let t = s.start; t <= s.end; ++t) {
                        const e = i.style._layers[l[t]];
                        if (e.isHidden(i.transform.zoom))
                            continue;
                        const n = i.style._getLayerSourceCache(e)
                          , o = n ? this.proxyToSource[u.key][n.id] : [u];
                        if (!o)
                            continue;
                        const s = o;
                        r.viewport.set([0, 0, d.fb.width, d.fb.height]),
                        m !== (n ? n.id : null) && (this._setupStencil(d, o, e, n),
                        m = n ? n.id : null),
                        i.renderLayer(i, n, e, s)
                    }
                    this.renderedToTile ? (d.dirty = !0,
                    a.push(o.tileID)) : p || --c,
                    5 === c && (c = 0,
                    this.renderToBackBuffer(a))
                }
                return this.renderToBackBuffer(a),
                this.renderingToTexture = !1,
                r.bindFramebuffer.set(null),
                r.viewport.set([0, 0, i.width, i.height]),
                s.end + 1
            }
            postRender() {}
            renderCacheEfficiency(t) {
                const e = t.order.length;
                if (0 === e)
                    return {
                        efficiency: 100
                    };
                let i, r = 0, n = 0, o = !1;
                for (let s = 0; s < e; ++s) {
                    const e = t._layers[t.order[s]];
                    this._style.isLayerDraped(e) ? (o && ++r,
                    ++n) : o || (o = !0,
                    i = e.id)
                }
                return 0 === n ? {
                    efficiency: 100
                } : {
                    efficiency: 100 * (1 - r / n),
                    firstUndrapedLayer: i
                }
            }
            getMinElevationBelowMSL() {
                let t = 0;
                return this._visibleDemTiles.filter((t=>t.dem)).forEach((e=>{
                    t = Math.min(t, e.dem.tree.minimums[0])
                }
                )),
                0 === t ? t : (t - 30) * this._exaggeration
            }
            raycast(t, e, i) {
                if (!this._visibleDemTiles)
                    return null;
                const r = this._visibleDemTiles.filter((t=>t.dem)).map((r=>{
                    const n = r.tileID
                      , o = 1 << n.overscaledZ
                      , {x: s, y: a} = n.canonical
                      , l = s / o
                      , c = (s + 1) / o
                      , u = a / o
                      , h = (a + 1) / o;
                    return {
                        minx: l,
                        miny: u,
                        maxx: c,
                        maxy: h,
                        t: r.dem.tree.raycastRoot(l, u, c, h, t, e, i),
                        tile: r
                    }
                }
                ));
                r.sort(((t,e)=>(null !== t.t ? t.t : Number.MAX_VALUE) - (null !== e.t ? e.t : Number.MAX_VALUE)));
                for (const n of r) {
                    if (null == n.t)
                        return null;
                    const r = n.tile.dem.tree.raycast(n.minx, n.miny, n.maxx, n.maxy, t, e, i);
                    if (null != r)
                        return r
                }
                return null
            }
            _createFBO() {
                const e = this.painter.context
                  , i = e.gl
                  , r = this.drapeBufferSize;
                e.activeTexture.set(i.TEXTURE0);
                const n = new t.Texture(e,{
                    width: r[0],
                    height: r[1],
                    data: null
                },i.RGBA);
                n.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const o = e.createFramebuffer(r[0], r[1], !1);
                return o.colorAttachment.set(n.texture),
                o.depthAttachment = new Tt(e,o.framebuffer),
                void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = e.createRenderbuffer(e.gl.DEPTH_STENCIL, r[0], r[1]),
                this._stencilRef = 0,
                o.depthAttachment.set(this._sharedDepthStencil),
                e.clear({
                    stencil: 0
                })) : o.depthAttachment.set(this._sharedDepthStencil),
                e.extTextureFilterAnisotropic && !e.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, e.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.extTextureFilterAnisotropicMax),
                {
                    fb: o,
                    tex: n,
                    dirty: !1
                }
            }
            _initFBOPool() {
                for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                    this.pool.push(this._createFBO())
            }
            _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition())
                    return !0;
                for (const t in this._style._sourceCaches)
                    if (this._style._sourceCaches[t].hasTransition())
                        return !0;
                return this._style.order.some((t=>{
                    const e = this._style._layers[t]
                      , i = e.isHidden(this.painter.transform.zoom);
                    return "custom" !== e.type && !i && e.hasTransition()
                }
                ))
            }
            _clearRasterFadeFromRenderCache() {
                let t = !1;
                for (const e in this._style._sourceCaches)
                    if (this._style._sourceCaches[e]._source instanceof Mt) {
                        t = !0;
                        break
                    }
                if (t)
                    for (let t = 0; t < this._style.order.length; ++t) {
                        const e = this._style._layers[this._style.order[t]]
                          , i = e.isHidden(this.painter.transform.zoom)
                          , r = this._style._getLayerSourceCache(e);
                        if ("raster" !== e.type || i || !r)
                            continue;
                        const n = e.paint.get("raster-fade-duration");
                        for (const t of this.proxyCoords) {
                            const e = this.proxyToSource[t.key][r.id];
                            if (e)
                                for (const t of e) {
                                    const e = Si(r.getTile(t), r.findLoadedParent(t, 0), r, this.painter.transform, n);
                                    (1 !== e.opacity || 0 !== e.mix) && this._clearRenderCacheForTile(r.id, t)
                                }
                        }
                    }
            }
            _setupDrapedRenderBatches() {
                const t = this._style.order
                  , e = t.length;
                if (0 === e)
                    return;
                const i = [];
                let r, n = 0, o = this._style._layers[t[n]];
                for (; !this._style.isLayerDraped(o) && o.isHidden(this.painter.transform.zoom) && ++n < e; )
                    o = this._style._layers[t[n]];
                for (; n < e; ++n) {
                    const e = this._style._layers[t[n]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === r && (r = n) : void 0 !== r && (i.push({
                        start: r,
                        end: n - 1
                    }),
                    r = void 0))
                }
                void 0 !== r && i.push({
                    start: r,
                    end: n - 1
                }),
                this._drapedRenderBatches = i
            }
            _setupRenderCache(t) {
                const e = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1,
                    e.renderCache.length > e.renderCachePool.length) {
                        const t = Object.values(e.proxyCachedFBO);
                        e.proxyCachedFBO = {};
                        for (let i = 0; i < t.length; ++i) {
                            const r = Object.values(t[i]);
                            e.renderCachePool.push(...r)
                        }
                    }
                    return
                }
                this._clearRasterFadeFromRenderCache();
                const i = this.proxyCoords
                  , r = this._tilesDirty;
                for (let n = i.length - 1; n >= 0; n--) {
                    const o = i[n];
                    if (e.getTileByID(o.key),
                    void 0 !== e.proxyCachedFBO[o.key]) {
                        const i = t[o.key]
                          , n = this.proxyToSource[o.key];
                        let s = 0;
                        for (const t in n) {
                            const e = n[t]
                              , o = i[t];
                            if (!o || o.length !== e.length || e.some(((e,i)=>e !== o[i] || r[t] && r[t].hasOwnProperty(e.key)))) {
                                s = -1;
                                break
                            }
                            ++s
                        }
                        for (const t in e.proxyCachedFBO[o.key])
                            e.renderCache[e.proxyCachedFBO[o.key][t]].dirty = s < 0 || s !== Object.values(i).length
                    }
                }
                const n = [...this._drapedRenderBatches];
                n.sort(((t,e)=>e.end - e.start - (t.end - t.start)));
                for (const t of n)
                    for (const r of i) {
                        if (e.proxyCachedFBO[r.key])
                            continue;
                        let i = e.renderCachePool.pop();
                        void 0 === i && e.renderCache.length < 50 && (i = e.renderCache.length,
                        e.renderCache.push(this._createFBO())),
                        void 0 !== i && (e.proxyCachedFBO[r.key] = {},
                        e.proxyCachedFBO[r.key][t.start] = i,
                        e.renderCache[i].dirty = !0)
                    }
                this._tilesDirty = {}
            }
            _setupStencil(t, e, i, r) {
                if (!r || !this._sourceTilesOverlap[r.id])
                    return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const n = this.painter.context
                  , o = n.gl;
                if (e.length <= 1)
                    return void (this._overlapStencilType = !1);
                let s;
                if (i.isTileClipped())
                    s = e.length,
                    this._overlapStencilMode.test = {
                        func: o.EQUAL,
                        mask: 255
                    },
                    this._overlapStencilType = "Clip";
                else {
                    if (!(e[0].overscaledZ > e[e.length - 1].overscaledZ))
                        return void (this._overlapStencilType = !1);
                    s = 1,
                    this._overlapStencilMode.test = {
                        func: o.GREATER,
                        mask: 255
                    },
                    this._overlapStencilType = "Mask"
                }
                this._stencilRef + s > 255 && (n.clear({
                    stencil: 0
                }),
                this._stencilRef = 0),
                this._stencilRef += s,
                this._overlapStencilMode.ref = this._stencilRef,
                i.isTileClipped() && this._renderTileClippingMasks(e, this._overlapStencilMode.ref)
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType
            }
            stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]),
                this._overlapStencilMode) : t.StencilMode.disabled
            }
            _renderTileClippingMasks(e, i) {
                const r = this.painter
                  , n = this.painter.context
                  , o = n.gl;
                r._tileClippingMaskIDs = {},
                n.setColorMode(t.ColorMode.disabled),
                n.setDepthMode(t.DepthMode.disabled);
                const s = r.useProgram("clippingMask");
                for (const a of e) {
                    const e = r._tileClippingMaskIDs[a.key] = --i;
                    s.draw(n, o.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                        func: o.ALWAYS,
                        mask: 0
                    },e,255,o.KEEP,o.KEEP,o.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, Ei(a.projMatrix), "$clipping", r.tileExtentBuffer, r.quadTriangleIndexBuffer, r.tileExtentSegments)
                }
            }
            pointCoordinate(e) {
                const i = this.painter.transform;
                if (e.x < 0 || e.x > i.width || e.y < 0 || e.y > i.height)
                    return null;
                const r = [e.x, e.y, 1, 1];
                t.transformMat4$1(r, r, i.pixelMatrixInverse),
                t.scale$1(r, r, 1 / r[3]),
                r[0] /= i.worldSize,
                r[1] /= i.worldSize;
                const n = i._camera.position
                  , o = t.mercatorZfromAltitude(1, i.center.lat)
                  , s = [n[0], n[1], n[2] / o, 0]
                  , a = t.subtract([], r.slice(0, 3), s);
                t.normalize(a, a);
                const l = this.raycast(s, a, this._exaggeration);
                return null !== l && l ? (t.scaleAndAdd(s, s, a, l),
                s[3] = s[2],
                s[2] *= o,
                s) : null
            }
            drawDepth() {
                const e = this.painter
                  , i = e.context
                  , r = this.proxySourceCache
                  , n = Math.ceil(e.width)
                  , o = Math.ceil(e.height);
                if (!this._depthFBO || this._depthFBO.width === n && this._depthFBO.height === o || (this._depthFBO.destroy(),
                this._depthFBO = void 0,
                this._depthTexture = void 0),
                !this._depthFBO) {
                    const e = i.gl
                      , r = i.createFramebuffer(n, o, !0);
                    i.activeTexture.set(e.TEXTURE0);
                    const s = new t.Texture(i,{
                        width: n,
                        height: o,
                        data: null
                    },e.RGBA);
                    s.bind(e.NEAREST, e.CLAMP_TO_EDGE),
                    r.colorAttachment.set(s.texture);
                    const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, n, o);
                    r.depthAttachment.set(a),
                    this._depthFBO = r,
                    this._depthTexture = s
                }
                i.bindFramebuffer.set(this._depthFBO.framebuffer),
                i.viewport.set([0, 0, n, o]),
                function(e, i, r, n) {
                    if ("globe" === e.transform.projection.name)
                        return;
                    const o = e.context
                      , s = o.gl;
                    o.clear({
                        depth: 1
                    });
                    const a = e.useProgram("terrainDepth")
                      , l = new t.DepthMode(s.LESS,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                    for (const e of n) {
                        const n = r.getTile(e)
                          , c = xi(e.projMatrix, 0);
                        i.setupElevationDraw(n, a),
                        a.draw(o, s.TRIANGLES, l, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments)
                    }
                }(e, this, r, this.proxyCoords)
            }
            _setupProxiedCoordsForOrtho(t, e, i) {
                if (t.getSource()instanceof Ct)
                    return this._setupProxiedCoordsForImageSource(t, e, i);
                this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
                const r = this.proxiedCoords[t.id] = []
                  , n = this.proxyCoords;
                for (let e = 0; e < n.length; e++) {
                    const o = n[e]
                      , s = this._findTileCoveringTileID(o, t);
                    if (s) {
                        const e = this._createProxiedId(o, s, i[o.key] && i[o.key][t.id]);
                        r.push(e),
                        this.proxyToSource[o.key][t.id] = [e]
                    }
                }
                let o = !1;
                for (let n = 0; n < e.length; n++) {
                    const s = t.getTile(e[n]);
                    if (!s || !s.hasData())
                        continue;
                    const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
                    if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                        const e = this.proxyToSource[a.tileID.key][t.id]
                          , n = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][t.id]);
                        e ? e.splice(e.length - 1, 0, n) : this.proxyToSource[a.tileID.key][t.id] = [n],
                        r.push(n),
                        o = !0
                    }
                }
                this._sourceTilesOverlap[t.id] = o
            }
            _setupProxiedCoordsForImageSource(e, i, r) {
                if (!e.getSource().loaded())
                    return;
                const n = this.proxiedCoords[e.id] = []
                  , o = this.proxyCoords
                  , s = e.getSource()
                  , a = new t.pointGeometry(s.tileID.x,s.tileID.y)._div(1 << s.tileID.z)
                  , l = s.coordinates.map(t.MercatorCoordinate.fromLngLat).reduce(((t,e)=>(t.min.x = Math.min(t.min.x, e.x - a.x),
                t.min.y = Math.min(t.min.y, e.y - a.y),
                t.max.x = Math.max(t.max.x, e.x - a.x),
                t.max.y = Math.max(t.max.y, e.y - a.y),
                t)), {
                    min: new t.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE),
                    max: new t.pointGeometry(-Number.MAX_VALUE,-Number.MAX_VALUE)
                })
                  , c = (e,i)=>{
                    const r = e.wrap + e.canonical.x / (1 << e.canonical.z)
                      , n = e.canonical.y / (1 << e.canonical.z)
                      , o = t.EXTENT / (1 << e.canonical.z)
                      , s = i.wrap + i.canonical.x / (1 << i.canonical.z)
                      , a = i.canonical.y / (1 << i.canonical.z);
                    return r + o < s + l.min.x || r > s + l.max.x || n + o < a + l.min.y || n > a + l.max.y
                }
                ;
                for (let t = 0; t < o.length; t++) {
                    const s = o[t];
                    for (let t = 0; t < i.length; t++) {
                        const o = e.getTile(i[t]);
                        if (!o || !o.hasData())
                            continue;
                        if (c(s, o.tileID))
                            continue;
                        const a = this._createProxiedId(s, o, r[s.key] && r[s.key][e.id])
                          , l = this.proxyToSource[s.key][e.id];
                        l ? l.push(a) : this.proxyToSource[s.key][e.id] = [a],
                        n.push(a)
                    }
                }
            }
            _createProxiedId(e, i, r) {
                let n = this.orthoMatrix;
                if (r) {
                    const t = r.find((t=>t.key === i.tileID.key));
                    if (t)
                        return t
                }
                if (i.tileID.key !== e.key) {
                    const r = e.canonical.z - i.tileID.canonical.z;
                    let o, s, a;
                    n = t.create();
                    const l = i.tileID.wrap - e.wrap << e.overscaledZ;
                    r > 0 ? (o = t.EXTENT >> r,
                    s = o * ((i.tileID.canonical.x << r) - e.canonical.x + l),
                    a = o * ((i.tileID.canonical.y << r) - e.canonical.y)) : (o = t.EXTENT << -r,
                    s = t.EXTENT * (i.tileID.canonical.x - (e.canonical.x + l << -r)),
                    a = t.EXTENT * (i.tileID.canonical.y - (e.canonical.y << -r))),
                    t.ortho(n, 0, o, 0, o, 0, 1),
                    t.translate(n, n, [s, a, 0])
                }
                return new Ii(i.tileID,e.key,n)
            }
            _findTileCoveringTileID(e, i) {
                let r = i.getTile(e);
                if (r && r.hasData())
                    return r;
                const n = this._findCoveringTileCache[i.id]
                  , o = n[e.key];
                if (r = o ? i.getTileByID(o) : null,
                r && r.hasData() || null === o)
                    return r;
                let s = r ? r.tileID : e
                  , a = s.overscaledZ;
                const l = i.getSource().minzoom
                  , c = [];
                if (!o) {
                    const n = i.getSource().maxzoom;
                    if (e.canonical.z >= n) {
                        const r = e.canonical.z - n;
                        i.getSource().reparseOverscaled ? (a = Math.max(e.canonical.z + 2, i.transform.tileZoom),
                        s = new t.OverscaledTileID(a,e.wrap,n,e.canonical.x >> r,e.canonical.y >> r)) : 0 !== r && (a = n,
                        s = new t.OverscaledTileID(a,e.wrap,n,e.canonical.x >> r,e.canonical.y >> r))
                    }
                    s.key !== e.key && (c.push(s.key),
                    r = i.getTile(s))
                }
                const u = t=>{
                    c.forEach((e=>{
                        n[e] = t
                    }
                    )),
                    c.length = 0
                }
                ;
                for (a -= 1; a >= l && (!r || !r.hasData()); a--) {
                    r && u(r.tileID.key);
                    const t = s.calculateScaledKey(a);
                    if (r = i.getTileByID(t),
                    r && r.hasData())
                        break;
                    const e = n[t];
                    if (null === e)
                        break;
                    void 0 === e ? c.push(t) : r = i.getTileByID(e)
                }
                return u(r ? r.tileID.key : null),
                r && r.hasData() ? r : null
            }
            findDEMTileFor(t) {
                return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null
            }
            prepareDrawTile() {
                this.renderedToTile = !0
            }
            _clearRenderCacheForTile(t, e) {
                let i = this._tilesDirty[t];
                i || (i = this._tilesDirty[t] = {}),
                i[e.key] = !0
            }
            getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const e = function(e) {
                        let i = 0;
                        const r = new t.StructArrayLayout2ui4
                          , n = 131;
                        for (let t = 1; t < 129; t++) {
                            for (let e = 1; e < 129; e++)
                                i = t * n + e,
                                r.emplaceBack(i, i + 1),
                                r.emplaceBack(i, i + n),
                                r.emplaceBack(i + 1, i + n),
                                128 === t && r.emplaceBack(i + n, i + n + 1);
                            r.emplaceBack(i + 1, i + 1 + n)
                        }
                        return r
                    }();
                    this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(e),
                    this.wireframeSegments = t.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, e.length)
                }
                return [this.wireframeIndexBuffer, this.wireframeSegments]
            }
        }
        class Di {
            static cacheKey(t, e, i, r) {
                let n = `${e}${r ? r.cacheKey : ""}`;
                for (const e of i)
                    t.usedDefines.includes(e) && (n += `/${e}`);
                return n
            }
            constructor(e, i, r, n, o, s) {
                const a = e.gl;
                this.program = a.createProgram();
                const l = function(t) {
                    const e = [];
                    for (let i = 0; i < t.length; i++) {
                        if (null === t[i])
                            continue;
                        const r = t[i].split(" ");
                        e.push(r.pop())
                    }
                    return e
                }(r.staticAttributes)
                  , c = n ? n.getBinderAttributes() : []
                  , u = l.concat(c);
                let h = n ? n.defines() : [];
                h = h.concat(s.map((t=>`#define ${t}`)));
                const d = h.concat(e.extStandardDerivatives ? "#extension GL_OES_standard_derivatives : enable\n".concat(ci) : ci, ci, li, ai.fragmentSource, oi.fragmentSource, r.fragmentSource).join("\n")
                  , p = h.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", li, ai.vertexSource, oi.vertexSource, ni.vertexSource, r.vertexSource).join("\n")
                  , m = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost())
                    return void (this.failedToCreate = !0);
                a.shaderSource(m, d),
                a.compileShader(m),
                a.attachShader(this.program, m);
                const f = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost())
                    this.failedToCreate = !0;
                else {
                    a.shaderSource(f, p),
                    a.compileShader(f),
                    a.attachShader(this.program, f),
                    this.attributes = {},
                    this.numAttributes = u.length;
                    for (let t = 0; t < this.numAttributes; t++)
                        u[t] && (a.bindAttribLocation(this.program, t, u[t]),
                        this.attributes[u[t]] = t);
                    a.linkProgram(this.program),
                    a.deleteShader(f),
                    a.deleteShader(m),
                    this.fixedUniforms = o(e),
                    this.binderUniforms = n ? n.getUniforms(e) : [],
                    s.includes("TERRAIN") && (this.terrainUniforms = (_ = e,
                    {
                        u_dem: new t.Uniform1i(_),
                        u_dem_prev: new t.Uniform1i(_),
                        u_dem_unpack: new t.Uniform4f(_),
                        u_dem_tl: new t.Uniform2f(_),
                        u_dem_scale: new t.Uniform1f(_),
                        u_dem_tl_prev: new t.Uniform2f(_),
                        u_dem_scale_prev: new t.Uniform1f(_),
                        u_dem_size: new t.Uniform1f(_),
                        u_dem_lerp: new t.Uniform1f(_),
                        u_exaggeration: new t.Uniform1f(_),
                        u_depth: new t.Uniform1i(_),
                        u_depth_size_inv: new t.Uniform2f(_),
                        u_meter_to_dem: new t.Uniform1f(_),
                        u_label_plane_matrix_inv: new t.UniformMatrix4f(_)
                    })),
                    s.includes("GLOBE") && (this.globeUniforms = (e=>({
                        u_tile_tl_up: new t.Uniform3f(e),
                        u_tile_tr_up: new t.Uniform3f(e),
                        u_tile_br_up: new t.Uniform3f(e),
                        u_tile_bl_up: new t.Uniform3f(e),
                        u_tile_up_scale: new t.Uniform1f(e)
                    }))(e)),
                    s.includes("FOG") && (this.fogUniforms = (e=>({
                        u_fog_matrix: new t.UniformMatrix4f(e),
                        u_fog_range: new t.Uniform2f(e),
                        u_fog_color: new t.Uniform4f(e),
                        u_fog_horizon_blend: new t.Uniform1f(e),
                        u_fog_temporal_offset: new t.Uniform1f(e),
                        u_frustum_tl: new t.Uniform3f(e),
                        u_frustum_tr: new t.Uniform3f(e),
                        u_frustum_br: new t.Uniform3f(e),
                        u_frustum_bl: new t.Uniform3f(e),
                        u_globe_pos: new t.Uniform3f(e),
                        u_globe_radius: new t.Uniform1f(e),
                        u_globe_transition: new t.Uniform1f(e),
                        u_is_globe: new t.Uniform1i(e),
                        u_viewport: new t.Uniform2f(e)
                    }))(e))
                }
                var _
            }
            setTerrainUniformValues(t, e) {
                if (!this.terrainUniforms)
                    return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const t in e)
                        i[t] && i[t].set(this.program, t, e[t])
                }
            }
            setGlobeUniformValues(t, e) {
                if (!this.globeUniforms)
                    return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const t in e)
                        i[t] && i[t].set(this.program, t, e[t])
                }
            }
            setFogUniformValues(t, e) {
                if (!this.fogUniforms)
                    return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const t in e)
                        i[t].set(this.program, t, e[t])
                }
            }
            draw(t, e, i, r, n, o, s, a, l, c, u, h, d, p, m) {
                const f = t.gl;
                if (this.failedToCreate)
                    return;
                t.program.set(this.program),
                t.setDepthMode(i),
                t.setStencilMode(r),
                t.setColorMode(n),
                t.setCullFace(o);
                for (const t of Object.keys(this.fixedUniforms))
                    this.fixedUniforms[t].set(this.program, t, s[t]);
                p && p.setUniforms(this.program, t, this.binderUniforms, h, {
                    zoom: d
                });
                const _ = {
                    [f.LINES]: 2,
                    [f.TRIANGLES]: 3,
                    [f.LINE_STRIP]: 1
                }[e];
                for (const i of u.get()) {
                    const r = i.vaos || (i.vaos = {});
                    (r[a] || (r[a] = new pi)).bind(t, this, l, p ? p.getPaintVertexBuffers() : [], c, i.vertexOffset, m || []),
                    f.drawElements(e, i.primitiveLength * _, f.UNSIGNED_SHORT, i.primitiveOffset * _ * 2)
                }
            }
        }
        function ki(t, e) {
            const i = Math.pow(2, e.tileID.overscaledZ)
              , r = e.tileSize * Math.pow(2, t.transform.tileZoom) / i
              , n = r * (e.tileID.canonical.x + e.tileID.wrap * i)
              , o = r * e.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: e.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / P(e, 1, t.transform.tileZoom),
                u_pixel_coord_upper: [n >> 16, o >> 16],
                u_pixel_coord_lower: [65535 & n, 65535 & o]
            }
        }
        const Pi = t.create()
          , Li = (e,i,r,n,o,s,a,l,c,u,h)=>{
            const d = i.style.light
              , p = d.properties.get("position")
              , m = [p.x, p.y, p.z]
              , f = t.create$1();
            "viewport" === d.properties.get("anchor") && (t.fromRotation(f, -i.transform.angle),
            t.transformMat3(m, m, f));
            const _ = d.properties.get("color")
              , g = i.transform
              , y = {
                u_matrix: e,
                u_lightpos: m,
                u_lightintensity: d.properties.get("intensity"),
                u_lightcolor: [_.r, _.g, _.b],
                u_vertical_gradient: +r,
                u_opacity: n,
                u_tile_id: [0, 0, 0],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Pi,
                u_merc_center: [0, 0],
                u_up_dir: [0, 0, 0],
                u_height_lift: 0,
                u_ao: o,
                u_edge_radius: s
            };
            return "globe" === g.projection.name && (y.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z],
            y.u_zoom_transition = c,
            y.u_inv_rot_matrix = h,
            y.u_merc_center = u,
            y.u_up_dir = g.projection.upVector(new t.CanonicalTileID(0,0,0), u[0] * t.EXTENT, u[1] * t.EXTENT),
            y.u_height_lift = l),
            y
        }
          , Oi = (e,i,r,n,o,s,a,l,c,u,h,d)=>{
            const p = Li(e, i, r, n, o, s, a, c, u, h, d)
              , m = {
                u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
            };
            return t.extend(p, ki(i, l), m)
        }
          , Ri = t=>({
            u_matrix: t
        })
          , Bi = (e,i,r)=>t.extend(Ri(e), ki(i, r))
          , Fi = (t,e)=>({
            u_matrix: t,
            u_world: e
        })
          , Ui = (e,i,r,n)=>t.extend(Bi(e, i, r), {
            u_world: n
        })
          , Ni = t.create()
          , Gi = (e,i,r,n,o,s)=>{
            const a = e.transform
              , l = "globe" === a.projection.name;
            let c;
            if ("map" === s.paint.get("circle-pitch-alignment"))
                if (l) {
                    const e = t.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
                    c = Float32Array.from([e, 0, 0, e])
                } else
                    c = a.calculatePixelsToTileUnitsMatrix(r);
            else
                c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);
            const u = {
                u_camera_to_center_distance: a.cameraToCenterDistance,
                u_matrix: e.translatePosMatrix(i.projMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: t.exported.devicePixelRatio,
                u_extrude_scale: c,
                u_inv_rot_matrix: Ni,
                u_merc_center: [0, 0],
                u_tile_id: [0, 0, 0],
                u_zoom_transition: 0,
                u_up_dir: [0, 0, 0]
            };
            if (l) {
                u.u_inv_rot_matrix = n,
                u.u_merc_center = o,
                u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z],
                u.u_zoom_transition = t.globeToMercatorTransition(a.zoom);
                const e = o[0] * t.EXTENT
                  , r = o[1] * t.EXTENT;
                u.u_up_dir = a.projection.upVector(new t.CanonicalTileID(0,0,0), e, r)
            }
            return u
        }
          , ji = t=>{
            const e = [];
            return "map" === t.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"),
            "map" === t.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"),
            e
        }
          , Vi = (e,i,r,n)=>{
            const o = t.EXTENT / r.tileSize;
            return {
                u_matrix: e,
                u_camera_to_center_distance: i.getCameraToCenterDistance(n),
                u_extrude_scale: [i.pixelsToGLUnits[0] / o, i.pixelsToGLUnits[1] / o]
            }
        }
          , Zi = (t,e,i=1)=>({
            u_matrix: t,
            u_color: e,
            u_overlay: 0,
            u_overlay_scale: i
        })
          , Ji = t.create()
          , Xi = (e,i,r,n,o,s,a)=>{
            const l = e.transform
              , c = "globe" === l.projection.name
              , u = c ? t.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : P(r, 1, s)
              , h = {
                u_matrix: i.projMatrix,
                u_extrude_scale: u,
                u_intensity: a,
                u_inv_rot_matrix: Ji,
                u_merc_center: [0, 0],
                u_tile_id: [0, 0, 0],
                u_zoom_transition: 0,
                u_up_dir: [0, 0, 0]
            };
            if (c) {
                h.u_inv_rot_matrix = n,
                h.u_merc_center = o,
                h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z],
                h.u_zoom_transition = t.globeToMercatorTransition(l.zoom);
                const e = o[0] * t.EXTENT
                  , r = o[1] * t.EXTENT;
                h.u_up_dir = l.projection.upVector(new t.CanonicalTileID(0,0,0), e, r)
            }
            return h
        }
          , qi = (t,e,i,r,n,o,s)=>{
            const a = t.transform
              , l = a.calculatePixelsToTileUnitsMatrix(e);
            return {
                u_matrix: Wi(t, e, i, r),
                u_pixels_to_tile_units: l,
                u_device_pixel_ratio: o,
                u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: n,
                u_texsize: Hi(i) ? e.lineAtlasTexture.size : [0, 0],
                u_tile_units_to_pixels: Yi(e, t.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: s
            }
        }
          , $i = (t,e,i,r,n)=>{
            const o = t.transform;
            return {
                u_matrix: Wi(t, e, i, r),
                u_texsize: e.imageAtlasTexture.size,
                u_pixels_to_tile_units: o.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: n,
                u_image: 0,
                u_tile_units_to_pixels: Yi(e, o),
                u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]],
                u_alpha_discard_threshold: 0
            }
        }
        ;
        function Yi(t, e) {
            return 1 / P(t, 1, e.tileZoom)
        }
        function Wi(t, e, i, r) {
            return t.translatePosMatrix(r || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        function Hi(t) {
            const e = t.paint.get("line-dasharray").value;
            return e.value || "constant" !== e.kind
        }
        const Ki = (t,e,i,r,n,o)=>{
            var s, a;
            return {
                u_matrix: t,
                u_tl_parent: e,
                u_scale_parent: i,
                u_fade_t: r.mix,
                u_opacity: r.opacity * n.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: n.paint.get("raster-brightness-min"),
                u_brightness_high: n.paint.get("raster-brightness-max"),
                u_saturation_factor: (a = n.paint.get("raster-saturation"),
                a > 0 ? 1 - 1 / (1.001 - a) : -a),
                u_contrast_factor: (s = n.paint.get("raster-contrast"),
                s > 0 ? 1 / (1 - s) : 1 + s),
                u_spin_weights: Qi(n.paint.get("raster-hue-rotate")),
                u_perspective_transform: o
            }
        }
        ;
        function Qi(t) {
            t *= Math.PI / 180;
            const e = Math.sin(t)
              , i = Math.cos(t);
            return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const tr = t.create()
          , er = (e,i,r,n,o,s,a,l,c,u,h,d,p,m,f,_)=>{
            const g = o.transform
              , y = {
                u_is_size_zoom_constant: +("constant" === e || "source" === e),
                u_is_size_feature_constant: +("constant" === e || "camera" === e),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: g.cameraToCenterDistance,
                u_rotate_symbol: +r,
                u_aspect_ratio: g.width / g.height,
                u_fade_change: o.options.fadeDuration ? o.symbolFadeChange : 1,
                u_matrix: s,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +c,
                u_pitch_with_map: +n,
                u_texsize: u,
                u_texture: 0,
                u_tile_id: [0, 0, 0],
                u_zoom_transition: 0,
                u_inv_rot_matrix: tr,
                u_merc_center: [0, 0],
                u_camera_forward: [0, 0, 0],
                u_ecef_origin: [0, 0, 0],
                u_tile_matrix: tr,
                u_up_vector: [0, -1, 0]
            };
            return "globe" === _.name && (y.u_tile_id = [h.canonical.x, h.canonical.y, 1 << h.canonical.z],
            y.u_zoom_transition = d,
            y.u_inv_rot_matrix = m,
            y.u_merc_center = p,
            y.u_camera_forward = g._camera.forward(),
            y.u_ecef_origin = t.globeECEFOrigin(g.globeMatrix, h.toUnwrapped()),
            y.u_tile_matrix = Float32Array.from(g.globeMatrix),
            y.u_up_vector = f),
            y
        }
          , ir = (e,i,r,n,o,s,a,l,c,u,h,d,p,m,f,_,g)=>t.extend(er(e, i, r, n, o, s, a, l, c, u, d, p, m, f, _, g), {
            u_gamma_scale: n ? o.transform.cameraToCenterDistance * Math.cos(o.terrain ? 0 : o.transform._pitch) : 1,
            u_device_pixel_ratio: t.exported.devicePixelRatio,
            u_is_halo: +h
        })
          , rr = (e,i,r,n,o,s,a,l,c,u,h,d,p,m,f,_)=>t.extend(ir(e, i, r, n, o, s, a, l, !0, c, !0, h, d, p, m, f, _), {
            u_texsize_icon: u,
            u_texture_icon: 1
        })
          , nr = (t,e,i)=>({
            u_matrix: t,
            u_opacity: e,
            u_color: i
        })
          , or = {
            fillExtrusion: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_lightpos: new t.Uniform3f(e),
                u_lightintensity: new t.Uniform1f(e),
                u_lightcolor: new t.Uniform3f(e),
                u_vertical_gradient: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_edge_radius: new t.Uniform1f(e),
                u_ao: new t.Uniform2f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_up_dir: new t.Uniform3f(e),
                u_height_lift: new t.Uniform1f(e)
            }),
            fillExtrusionPattern: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_lightpos: new t.Uniform3f(e),
                u_lightintensity: new t.Uniform1f(e),
                u_lightcolor: new t.Uniform3f(e),
                u_vertical_gradient: new t.Uniform1f(e),
                u_height_factor: new t.Uniform1f(e),
                u_edge_radius: new t.Uniform1f(e),
                u_ao: new t.Uniform2f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_up_dir: new t.Uniform3f(e),
                u_height_lift: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e)
            }),
            fill: e=>({
                u_matrix: new t.UniformMatrix4f(e)
            }),
            fillPattern: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e)
            }),
            fillOutline: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_world: new t.Uniform2f(e)
            }),
            fillOutlinePattern: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_world: new t.Uniform2f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e)
            }),
            circle: e=>({
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_extrude_scale: new t.UniformMatrix2f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_up_dir: new t.Uniform3f(e)
            }),
            collisionBox: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_extrude_scale: new t.Uniform2f(e)
            }),
            collisionCircle: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_matrix: new t.UniformMatrix4f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_viewport_size: new t.Uniform2f(e)
            }),
            debug: e=>({
                u_color: new t.UniformColor(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_overlay: new t.Uniform1i(e),
                u_overlay_scale: new t.Uniform1f(e)
            }),
            clippingMask: e=>({
                u_matrix: new t.UniformMatrix4f(e)
            }),
            heatmap: e=>({
                u_extrude_scale: new t.Uniform1f(e),
                u_intensity: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_up_dir: new t.Uniform3f(e)
            }),
            heatmapTexture: e=>({
                u_image: new t.Uniform1i(e),
                u_color_ramp: new t.Uniform1i(e),
                u_opacity: new t.Uniform1f(e)
            }),
            hillshade: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_latrange: new t.Uniform2f(e),
                u_light: new t.Uniform2f(e),
                u_shadow: new t.UniformColor(e),
                u_highlight: new t.UniformColor(e),
                u_accent: new t.UniformColor(e)
            }),
            hillshadePrepare: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_dimension: new t.Uniform2f(e),
                u_zoom: new t.Uniform1f(e),
                u_unpack: new t.Uniform4f(e)
            }),
            line: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_pixels_to_tile_units: new t.UniformMatrix2f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_units_to_pixels: new t.Uniform2f(e),
                u_dash_image: new t.Uniform1i(e),
                u_gradient_image: new t.Uniform1i(e),
                u_image_height: new t.Uniform1f(e),
                u_texsize: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e),
                u_alpha_discard_threshold: new t.Uniform1f(e),
                u_trim_offset: new t.Uniform2f(e)
            }),
            linePattern: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_texsize: new t.Uniform2f(e),
                u_pixels_to_tile_units: new t.UniformMatrix2f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_units_to_pixels: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e),
                u_alpha_discard_threshold: new t.Uniform1f(e)
            }),
            raster: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_tl_parent: new t.Uniform2f(e),
                u_scale_parent: new t.Uniform1f(e),
                u_fade_t: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_image0: new t.Uniform1i(e),
                u_image1: new t.Uniform1i(e),
                u_brightness_low: new t.Uniform1f(e),
                u_brightness_high: new t.Uniform1f(e),
                u_saturation_factor: new t.Uniform1f(e),
                u_contrast_factor: new t.Uniform1f(e),
                u_spin_weights: new t.Uniform3f(e),
                u_perspective_transform: new t.Uniform2f(e)
            }),
            symbolIcon: e=>({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_camera_forward: new t.Uniform3f(e),
                u_tile_matrix: new t.UniformMatrix4f(e),
                u_up_vector: new t.Uniform3f(e),
                u_ecef_origin: new t.Uniform3f(e),
                u_texture: new t.Uniform1i(e)
            }),
            symbolSDF: e=>({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_texture: new t.Uniform1i(e),
                u_gamma_scale: new t.Uniform1f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_tile_id: new t.Uniform3f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_camera_forward: new t.Uniform3f(e),
                u_tile_matrix: new t.UniformMatrix4f(e),
                u_up_vector: new t.Uniform3f(e),
                u_ecef_origin: new t.Uniform3f(e),
                u_is_halo: new t.Uniform1i(e)
            }),
            symbolTextAndIcon: e=>({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_texsize_icon: new t.Uniform2f(e),
                u_texture: new t.Uniform1i(e),
                u_texture_icon: new t.Uniform1i(e),
                u_gamma_scale: new t.Uniform1f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_is_halo: new t.Uniform1i(e)
            }),
            background: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_opacity: new t.Uniform1f(e),
                u_color: new t.UniformColor(e)
            }),
            backgroundPattern: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_opacity: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_pattern_tl: new t.Uniform2f(e),
                u_pattern_br: new t.Uniform2f(e),
                u_texsize: new t.Uniform2f(e),
                u_pattern_size: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e)
            }),
            terrainRaster: yi,
            terrainDepth: yi,
            skybox: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_sun_direction: new t.Uniform3f(e),
                u_cubemap: new t.Uniform1i(e),
                u_opacity: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e)
            }),
            skyboxGradient: e=>({
                u_matrix: new t.UniformMatrix4f(e),
                u_color_ramp: new t.Uniform1i(e),
                u_center_direction: new t.Uniform3f(e),
                u_radius: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e)
            }),
            skyboxCapture: e=>({
                u_matrix_3f: new t.UniformMatrix3f(e),
                u_sun_direction: new t.Uniform3f(e),
                u_sun_intensity: new t.Uniform1f(e),
                u_color_tint_r: new t.Uniform4f(e),
                u_color_tint_m: new t.Uniform4f(e),
                u_luminance: new t.Uniform1f(e)
            }),
            globeRaster: e=>({
                u_proj_matrix: new t.UniformMatrix4f(e),
                u_globe_matrix: new t.UniformMatrix4f(e),
                u_normalize_matrix: new t.UniformMatrix4f(e),
                u_merc_matrix: new t.UniformMatrix4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_merc_center: new t.Uniform2f(e),
                u_image0: new t.Uniform1i(e),
                u_grid_matrix: new t.UniformMatrix3f(e),
                u_frustum_tl: new t.Uniform3f(e),
                u_frustum_tr: new t.Uniform3f(e),
                u_frustum_br: new t.Uniform3f(e),
                u_frustum_bl: new t.Uniform3f(e),
                u_globe_pos: new t.Uniform3f(e),
                u_globe_radius: new t.Uniform1f(e),
                u_viewport: new t.Uniform2f(e)
            }),
            globeAtmosphere: e=>({
                u_frustum_tl: new t.Uniform3f(e),
                u_frustum_tr: new t.Uniform3f(e),
                u_frustum_br: new t.Uniform3f(e),
                u_frustum_bl: new t.Uniform3f(e),
                u_horizon: new t.Uniform1f(e),
                u_transition: new t.Uniform1f(e),
                u_fadeout_range: new t.Uniform1f(e),
                u_color: new t.Uniform4f(e),
                u_high_color: new t.Uniform4f(e),
                u_space_color: new t.Uniform4f(e),
                u_star_intensity: new t.Uniform1f(e),
                u_star_density: new t.Uniform1f(e),
                u_star_size: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e),
                u_horizon_angle: new t.Uniform1f(e),
                u_rotation_matrix: new t.UniformMatrix4f(e)
            })
        };
        let sr;
        function ar(e, i, r, n, o, s, a) {
            const l = e.context
              , c = l.gl
              , u = e.transform
              , h = e.useProgram("collisionBox")
              , d = [];
            let p = 0
              , m = 0;
            for (let f = 0; f < n.length; f++) {
                const _ = n[f]
                  , g = i.getTile(_)
                  , y = g.getBucket(r);
                if (!y)
                    continue;
                const x = xe(_, y, u);
                let v = x;
                0 === o[0] && 0 === o[1] || (v = e.translatePosMatrix(x, g, o, s));
                const b = a ? y.textCollisionBox : y.iconCollisionBox
                  , w = y.collisionCircleArray;
                if (w.length > 0) {
                    const e = t.create()
                      , i = v;
                    t.mul(e, y.placementInvProjMatrix, u.glCoordMatrix),
                    t.mul(e, e, y.placementViewportMatrix),
                    d.push({
                        circleArray: w,
                        circleOffset: m,
                        transform: i,
                        invTransform: e,
                        projection: y.getProjection()
                    }),
                    p += w.length / 4,
                    m = p
                }
                b && (e.terrain && e.terrain.setupElevationDraw(g, h),
                h.draw(l, c.LINES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, Vi(v, u, g, y.getProjection()), r.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, u.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt]))
            }
            if (!a || !d.length)
                return;
            const f = e.useProgram("collisionCircle")
              , _ = new t.StructArrayLayout2f1f2i16;
            _.resize(4 * p),
            _._trim();
            let g = 0;
            for (const t of d)
                for (let e = 0; e < t.circleArray.length / 4; e++) {
                    const i = 4 * e
                      , r = t.circleArray[i + 0]
                      , n = t.circleArray[i + 1]
                      , o = t.circleArray[i + 2]
                      , s = t.circleArray[i + 3];
                    _.emplace(g++, r, n, o, s, 0),
                    _.emplace(g++, r, n, o, s, 1),
                    _.emplace(g++, r, n, o, s, 2),
                    _.emplace(g++, r, n, o, s, 3)
                }
            (!sr || sr.length < 2 * p) && (sr = function(e) {
                const i = 2 * e
                  , r = new t.StructArrayLayout3ui6;
                r.resize(i),
                r._trim();
                for (let t = 0; t < i; t++) {
                    const e = 6 * t;
                    r.uint16[e + 0] = 4 * t + 0,
                    r.uint16[e + 1] = 4 * t + 1,
                    r.uint16[e + 2] = 4 * t + 2,
                    r.uint16[e + 3] = 4 * t + 2,
                    r.uint16[e + 4] = 4 * t + 3,
                    r.uint16[e + 5] = 4 * t + 0
                }
                return r
            }(p));
            const y = l.createIndexBuffer(sr, !0)
              , x = l.createVertexBuffer(_, t.collisionCircleLayout.members, !0);
            for (const i of d) {
                const n = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (v = u).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [v.width, v.height]
                };
                f.draw(l, c.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, n, r.id, x, y, t.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, u.zoom)
            }
            var v;
            x.destroy(),
            y.destroy()
        }
        const lr = t.create();
        function cr({width: e, height: i, anchor: r, textOffset: n, textScale: o}, s) {
            const {horizontalAlign: a, verticalAlign: l} = t.getAnchorAlignment(r)
              , c = -(a - .5) * e
              , u = -(l - .5) * i
              , h = t.evaluateVariableOffset(r, n);
            return new t.pointGeometry((c / o + h[0]) * s,(u / o + h[1]) * s)
        }
        function ur(e, i, r, n, o, s, a, l, c, u, h) {
            const d = e.text.placedSymbolArray
              , p = e.text.dynamicLayoutVertexArray
              , m = e.icon.dynamicLayoutVertexArray
              , f = {}
              , _ = e.getProjection()
              , g = ve(l, _, s)
              , y = s.elevation
              , x = _.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;
            p.clear();
            for (let m = 0; m < d.length; m++) {
                const v = d.get(m)
                  , {tileAnchorX: b, tileAnchorY: w, numGlyphs: z} = v
                  , T = e.allowVerticalPlacement && !v.placedOrientation
                  , E = v.hidden || !v.crossTileID || T ? null : n[v.crossTileID];
                if (E) {
                    let n = 0
                      , d = 0
                      , m = 0;
                    if (y) {
                        const t = y ? y.getAtTileOffset(l, b, w) : 0
                          , [e,i,r] = _.upVector(l.canonical, b, w);
                        n = t * e * x,
                        d = t * i * x,
                        m = t * r * x
                    }
                    let[T,S,M,A] = ne(v.projectedAnchorX + n, v.projectedAnchorY + d, v.projectedAnchorZ + m, r ? g : a);
                    const I = oe(s.getCameraToCenterDistance(_), A);
                    let C = o.evaluateSizeForFeature(e.textSizeData, u, v) * I / t.ONE_EM;
                    r && (C *= e.tilePixelRatio / c);
                    const D = cr(E, C);
                    r ? (({x: T, y: S, z: M} = _.projectTilePoint(b + D.x, w + D.y, l.canonical)),
                    [T,S,M] = ne(T + n, S + d, M + m, a)) : (i && D._rotate(-s.angle),
                    T += D.x,
                    S += D.y,
                    M = 0);
                    const k = e.allowVerticalPlacement && v.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                    for (let e = 0; e < z; e++)
                        t.addDynamicAttributes(p, T, S, M, k);
                    h && v.associatedIconIndex >= 0 && (f[v.associatedIconIndex] = {
                        x: T,
                        y: S,
                        z: M,
                        angle: k
                    })
                } else
                    me(z, p)
            }
            if (h) {
                m.clear();
                const i = e.icon.placedSymbolArray;
                for (let e = 0; e < i.length; e++) {
                    const r = i.get(e)
                      , {numGlyphs: n} = r
                      , o = f[e];
                    if (r.hidden || !o)
                        me(n, m);
                    else {
                        const {x: e, y: i, z: r, angle: s} = o;
                        for (let o = 0; o < n; o++)
                            t.addDynamicAttributes(m, e, i, r, s)
                    }
                }
                e.icon.dynamicLayoutVertexBuffer.updateData(m)
            }
            e.text.dynamicLayoutVertexBuffer.updateData(p)
        }
        function hr(e, i, r, n, o, s, a, l, c, u, h, d) {
            const p = e.context
              , m = p.gl
              , f = e.transform
              , _ = "map" === l
              , g = "map" === c
              , y = _ && "point" !== r.layout.get("symbol-placement")
              , x = _ && !g && !y
              , v = void 0 !== r.layout.get("symbol-sort-key").constantOr(1);
            let b = !1;
            const w = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
              , z = [t.mercatorXfromLng(f.center.lng), t.mercatorYfromLat(f.center.lat)]
              , T = r.layout.get("text-variable-anchor")
              , E = "globe" === f.projection.name
              , S = []
              , M = [0, -1, 0];
            let A = M;
            !E && !f.mercatorFromTransition || _ || (A = function(e) {
                const i = e._camera.getWorldToCamera(e.worldSize, 1)
                  , r = t.multiply([], i, e.globeMatrix);
                t.invert(r, r);
                const n = [0, 0, 0]
                  , o = [0, 1, 0, 0];
                return t.transformMat4$1(o, o, r),
                n[0] = o[0],
                n[1] = o[1],
                n[2] = o[2],
                t.normalize(n, n),
                n
            }(f));
            for (const l of n) {
                const n = i.getTile(l)
                  , c = n.getBucket(r);
                if (!c)
                    continue;
                if ("mercator" === c.projection.name && E)
                    continue;
                const h = o ? c.text : c.icon;
                if (!h || c.fullyClipped || !h.segments.get().length)
                    continue;
                const d = h.programConfigurations.get(r.id)
                  , p = o || c.sdfIcons
                  , w = o ? c.textSizeData : c.iconSizeData
                  , k = g || 0 !== f.pitch
                  , P = t.evaluateSizeForZoom(w, f.zoom);
                let L, O, R, B, F = [0, 0], U = null;
                if (o) {
                    if (O = n.glyphAtlasTexture,
                    R = m.LINEAR,
                    L = n.glyphAtlasTexture.size,
                    c.iconsInText) {
                        F = n.imageAtlasTexture.size,
                        U = n.imageAtlasTexture;
                        const t = "composite" === w.kind || "camera" === w.kind;
                        B = k || e.options.rotating || e.options.zooming || t ? m.LINEAR : m.NEAREST
                    }
                } else {
                    const t = 1 !== r.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                    O = n.imageAtlasTexture,
                    R = p || e.options.rotating || e.options.zooming || t || k ? m.LINEAR : m.NEAREST,
                    L = n.imageAtlasTexture.size
                }
                const N = "globe" === c.projection.name
                  , G = N ? A : M
                  , j = N ? t.globeToMercatorTransition(f.zoom) : 0
                  , V = ve(l, c.getProjection(), f)
                  , Z = f.calculatePixelsToTileUnitsMatrix(n)
                  , J = ee(V, n.tileID.canonical, g, _, f, c.getProjection(), Z)
                  , X = e.terrain && g && y ? t.invert(t.create(), J) : lr
                  , q = re(V, n.tileID.canonical, g, _, f, c.getProjection(), Z)
                  , $ = T && c.hasTextData()
                  , Y = "none" !== r.layout.get("icon-text-fit") && $ && c.hasIconData();
                if (y) {
                    const t = f.elevation
                      , i = t ? t.getAtTileOffsetFunc(l, f.center.lat, f.worldSize, c.getProjection()) : null
                      , r = ie(V, n.tileID.canonical, g, _, f, c.getProjection(), Z);
                    ae(c, V, e, o, r, q, g, u, i, l)
                }
                const W = y || o && T || Y
                  , H = e.translatePosMatrix(V, n, s, a)
                  , K = W ? lr : J
                  , Q = e.translatePosMatrix(q, n, s, a, !0)
                  , tt = c.getProjection().createInversionMatrix(f, l.canonical)
                  , et = [];
                e.terrainRenderModeElevated() && g && et.push("PITCH_WITH_MAP_TERRAIN"),
                N && et.push("PROJECTION_GLOBE_VIEW"),
                W && et.push("PROJECTED_POS_ON_VIEWPORT");
                const it = p && 0 !== r.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let rt;
                rt = p ? c.iconsInText ? rr(w.kind, P, x, g, e, H, K, Q, L, F, l, j, z, tt, G, c.getProjection()) : ir(w.kind, P, x, g, e, H, K, Q, o, L, !0, l, j, z, tt, G, c.getProjection()) : er(w.kind, P, x, g, e, H, K, Q, o, L, l, j, z, tt, G, c.getProjection());
                const nt = {
                    program: e.useProgram((I = p,
                    C = o,
                    D = c,
                    D.iconsInText && C ? "symbolTextAndIcon" : I ? "symbolSDF" : "symbolIcon"), d, et),
                    buffers: h,
                    uniformValues: rt,
                    atlasTexture: O,
                    atlasTextureIcon: U,
                    atlasInterpolation: R,
                    atlasInterpolationIcon: B,
                    isSDF: p,
                    hasHalo: it,
                    tile: n,
                    labelPlaneMatrixInv: X
                };
                if (v && c.canOverlap) {
                    b = !0;
                    const e = h.segments.get();
                    for (const i of e)
                        S.push({
                            segments: new t.SegmentVector([i]),
                            sortKey: i.sortKey,
                            state: nt
                        })
                } else
                    S.push({
                        segments: h.segments,
                        sortKey: 0,
                        state: nt
                    })
            }
            var I, C, D;
            b && S.sort(((t,e)=>t.sortKey - e.sortKey));
            for (const t of S) {
                const i = t.state;
                if (e.terrain && e.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: !E,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }),
                p.activeTexture.set(m.TEXTURE0),
                i.atlasTexture.bind(i.atlasInterpolation, m.CLAMP_TO_EDGE),
                i.atlasTextureIcon && (p.activeTexture.set(m.TEXTURE1),
                i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, m.CLAMP_TO_EDGE)),
                i.isSDF) {
                    const n = i.uniformValues;
                    i.hasHalo && (n.u_is_halo = 1,
                    dr(i.buffers, t.segments, r, e, i.program, w, h, d, n)),
                    n.u_is_halo = 0
                }
                dr(i.buffers, t.segments, r, e, i.program, w, h, d, i.uniformValues)
            }
        }
        function dr(e, i, r, n, o, s, a, l, c) {
            const u = n.context
              , h = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.globeExtVertexBuffer];
            o.draw(u, u.gl.TRIANGLES, s, a, l, t.CullFaceMode.disabled, c, r.id, e.layoutVertexBuffer, e.indexBuffer, i, r.paint, n.transform.zoom, e.programConfigurations.get(r.id), h)
        }
        function pr(e, i, r, n, o, s, a) {
            const l = e.context.gl
              , c = r.paint.get("fill-pattern")
              , u = c && c.constantOr(1);
            let h, d, p, m, f;
            a ? (d = u && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
            h = l.LINES) : (d = u ? "fillPattern" : "fill",
            h = l.TRIANGLES);
            for (const _ of n) {
                const n = i.getTile(_);
                if (u && !n.patternsLoaded())
                    continue;
                const g = n.getBucket(r);
                if (!g)
                    continue;
                e.prepareDrawTile();
                const y = g.programConfigurations.get(r.id)
                  , x = e.useProgram(d, y);
                u && (e.context.activeTexture.set(l.TEXTURE0),
                n.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                y.updatePaintBuffers());
                const v = c.constantOr(null);
                if (v && n.imageAtlas) {
                    const t = n.imageAtlas.patternPositions[v.toString()];
                    t && y.setConstantPatternPositions(t)
                }
                const b = e.translatePosMatrix(_.projMatrix, n, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
                if (a) {
                    m = g.indexBuffer2,
                    f = g.segments2;
                    const t = e.terrain && e.terrain.renderingToTexture ? e.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
                    p = "fillOutlinePattern" === d && u ? Ui(b, e, n, t) : Fi(b, t)
                } else
                    m = g.indexBuffer,
                    f = g.segments,
                    p = u ? Bi(b, e, n) : Ri(b);
                e.prepareDrawProgram(e.context, x, _.toUnwrapped()),
                x.draw(e.context, h, o, e.stencilModeForClipping(_), s, t.CullFaceMode.disabled, p, r.id, g.layoutVertexBuffer, m, f, r.paint, e.transform.zoom, y)
            }
        }
        function mr(e, i, r, n, o, s, a) {
            const l = e.context
              , c = l.gl
              , u = e.transform
              , h = r.paint.get("fill-extrusion-pattern")
              , d = h.constantOr(1)
              , p = r.paint.get("fill-extrusion-opacity")
              , m = [r.paint.get("fill-extrusion-ambient-occlusion-intensity"), r.paint.get("fill-extrusion-ambient-occlusion-radius")]
              , f = r.layout.get("fill-extrusion-edge-radius")
              , _ = "globe" === u.projection.name ? t.fillExtrusionHeightLift() : 0
              , g = "globe" === u.projection.name
              , y = g ? t.globeToMercatorTransition(u.zoom) : 0
              , x = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
              , v = [];
            g && (v.push("PROJECTION_GLOBE_VIEW"),
            e.style.terrainSetForDrapingOnly() && v.push("TERRAIN")),
            m[0] > 0 && v.push("FAUX_AO");
            for (const b of n) {
                const n = i.getTile(b)
                  , w = n.getBucket(r);
                if (!w || w.projection.name !== u.projection.name)
                    continue;
                const z = w.programConfigurations.get(r.id)
                  , T = e.useProgram(d ? "fillExtrusionPattern" : "fillExtrusion", z, v);
                if (e.terrain) {
                    const t = e.terrain;
                    if (e.style.terrainSetForDrapingOnly())
                        t.setupElevationDraw(n, T, {
                            useMeterToDem: !0
                        });
                    else {
                        if (!w.enableTerrain)
                            continue;
                        if (t.setupElevationDraw(n, T, {
                            useMeterToDem: !0
                        }),
                        fr(l, i, b, w, r, t),
                        !w.centroidVertexBuffer) {
                            const t = T.attributes.a_centroid_pos;
                            void 0 !== t && c.vertexAttrib2f(t, 0, 0)
                        }
                    }
                }
                d && (e.context.activeTexture.set(c.TEXTURE0),
                n.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                z.updatePaintBuffers());
                const E = h.constantOr(null);
                if (E && n.imageAtlas) {
                    const t = n.imageAtlas.patternPositions[E.toString()];
                    t && z.setConstantPatternPositions(t)
                }
                const S = e.translatePosMatrix(b.projMatrix, n, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor"))
                  , M = u.projection.createInversionMatrix(u, b.canonical)
                  , A = r.paint.get("fill-extrusion-vertical-gradient")
                  , I = d ? Oi(S, e, A, p, m, f, b, n, _, y, x, M) : Li(S, e, A, p, m, f, b, _, y, x, M);
                e.prepareDrawProgram(l, T, b.toUnwrapped());
                const C = [];
                e.terrain && C.push(w.centroidVertexBuffer),
                g && C.push(w.layoutVertexExtBuffer),
                T.draw(l, l.gl.TRIANGLES, o, s, a, t.CullFaceMode.backCCW, I, r.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, r.paint, e.transform.zoom, z, C)
            }
        }
        function fr(e, i, r, n, o, s) {
            const a = [e=>{
                let i = e.canonical.x - 1
                  , r = e.wrap;
                return i < 0 && (i = (1 << e.canonical.z) - 1,
                r--),
                new t.OverscaledTileID(e.overscaledZ,r,e.canonical.z,i,e.canonical.y)
            }
            , e=>{
                let i = e.canonical.x + 1
                  , r = e.wrap;
                return i === 1 << e.canonical.z && (i = 0,
                r++),
                new t.OverscaledTileID(e.overscaledZ,r,e.canonical.z,i,e.canonical.y)
            }
            , e=>new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,(0 === e.canonical.y ? 1 << e.canonical.z : e.canonical.y) - 1), e=>new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y === (1 << e.canonical.z) - 1 ? 0 : e.canonical.y + 1)]
              , l = t=>{
                const e = i.getSource().minzoom
                  , r = t=>{
                    const e = i.getTileByID(t);
                    if (e && e.hasData())
                        return e.getBucket(o)
                }
                  , n = [0, -1, 1];
                for (const i of n) {
                    if (t.overscaledZ + i < e)
                        continue;
                    const n = r(t.calculateScaledKey(t.overscaledZ + i));
                    if (n)
                        return n
                }
            }
              , c = [0, 0, 0]
              , u = (e,i)=>(c[0] = Math.min(e.min.y, i.min.y),
            c[1] = Math.max(e.max.y, i.max.y),
            c[2] = t.EXTENT - i.min.x > e.max.x ? i.min.x - t.EXTENT : e.max.x,
            c)
              , h = (e,i)=>(c[0] = Math.min(e.min.x, i.min.x),
            c[1] = Math.max(e.max.x, i.max.x),
            c[2] = t.EXTENT - i.min.y > e.max.y ? i.min.y - t.EXTENT : e.max.y,
            c)
              , d = [(t,e)=>u(t, e), (t,e)=>u(e, t), (t,e)=>h(t, e), (t,e)=>h(e, t)]
              , p = new t.pointGeometry(0,0);
            let m, f, _;
            const g = (e,i,n,o,a)=>{
                const l = [[o ? n : e, o ? e : n, 0], [o ? n : i, o ? i : n, 0]]
                  , c = a < 0 ? t.EXTENT + a : a
                  , u = [o ? c : (e + i) / 2, o ? (e + i) / 2 : c, 0];
                return 0 === n && a < 0 || 0 !== n && a > 0 ? s.getForTilePoints(_, [u], !0, f) : l.push(u),
                s.getForTilePoints(r, l, !0, m),
                Math.max(l[0][2], l[1][2], u[2]) / s.exaggeration()
            }
            ;
            for (let e = 0; e < 4; e++) {
                const i = (e < 2 ? 1 : 5) - e
                  , o = n.borders[e];
                if (0 === o.length)
                    continue;
                const c = _ = a[e](r)
                  , u = l(c);
                if (!(u && u instanceof t.FillExtrusionBucket && u.enableTerrain))
                    continue;
                if (n.borderDoneWithNeighborZ[e] === u.canonical.z && u.borderDoneWithNeighborZ[i] === n.canonical.z)
                    continue;
                if (f = s.findDEMTileFor(c),
                !f || !f.dem)
                    continue;
                if (!m) {
                    const t = s.findDEMTileFor(r);
                    if (!t || !t.dem)
                        return;
                    m = t
                }
                const h = u.borders[i];
                let y = 0;
                const x = u.borderDoneWithNeighborZ[i] !== n.canonical.z;
                if (n.canonical.z === u.canonical.z) {
                    for (let r = 0; r < o.length; r++) {
                        const s = n.featuresOnBorder[o[r]]
                          , a = s.borders[e];
                        let l;
                        for (; y < h.length && (l = u.featuresOnBorder[h[y]],
                        !(l.borders[i][1] > a[0] + 3)); )
                            x && u.encodeCentroid(void 0, l, !1),
                            y++;
                        if (l && y < h.length) {
                            const r = y;
                            let o = 0;
                            for (; !(l.borders[i][0] > a[1] - 3) && (o++,
                            ++y !== h.length); )
                                l = u.featuresOnBorder[h[y]];
                            if (l = u.featuresOnBorder[h[r]],
                            s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== o) {
                                1 !== o && (y = r),
                                n.encodeCentroid(void 0, s, !1),
                                x && u.encodeCentroid(void 0, l, !1);
                                continue
                            }
                            const c = d[e](s, l)
                              , m = e % 2 ? t.EXTENT - 1 : 0;
                            p.x = g(c[0], Math.min(t.EXTENT - 1, c[1]), m, e < 2, c[2]),
                            p.y = 0,
                            n.encodeCentroid(p, s, !1),
                            x && u.encodeCentroid(p, l, !1)
                        } else
                            n.encodeCentroid(void 0, s, !1)
                    }
                    n.borderDoneWithNeighborZ[e] = u.canonical.z,
                    n.needsCentroidUpdate = !0,
                    x && (u.borderDoneWithNeighborZ[i] = n.canonical.z,
                    u.needsCentroidUpdate = !0)
                } else {
                    for (const t of o)
                        n.encodeCentroid(void 0, n.featuresOnBorder[t], !1);
                    if (x) {
                        for (const t of h)
                            u.encodeCentroid(void 0, u.featuresOnBorder[t], !1);
                        u.borderDoneWithNeighborZ[i] = n.canonical.z,
                        u.needsCentroidUpdate = !0
                    }
                    n.borderDoneWithNeighborZ[e] = u.canonical.z,
                    n.needsCentroidUpdate = !0
                }
            }
            (n.needsCentroidUpdate || !n.centroidVertexBuffer && 0 !== n.centroidVertexArray.length) && n.uploadCentroid(e)
        }
        const _r = new t.Color(1,0,0,1)
          , gr = new t.Color(0,1,0,1)
          , yr = new t.Color(0,0,1,1)
          , xr = new t.Color(1,0,1,1)
          , vr = new t.Color(0,1,1,1);
        function br(e, i, r) {
            const n = e.context
              , o = e.transform
              , s = n.gl
              , a = "globe" === o.projection.name
              , l = a ? ["PROJECTION_GLOBE_VIEW"] : null;
            let c = r.projMatrix;
            if (a && t.globeToMercatorTransition(o.zoom) > 0) {
                const e = t.transitionTileAABBinECEF(r.canonical, o)
                  , i = t.globeDenormalizeECEF(e);
                c = t.multiply(new Float32Array(16), o.globeMatrix, i),
                t.multiply(c, o.projMatrix, c)
            }
            const u = e.useProgram("debug", null, l)
              , h = i.getTileByID(r.key);
            e.terrain && e.terrain.setupElevationDraw(h, u);
            const d = t.DepthMode.disabled
              , p = t.StencilMode.disabled
              , m = e.colorModeForRenderPass()
              , f = "$debug";
            n.activeTexture.set(s.TEXTURE0),
            e.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE),
            a ? h._makeGlobeTileDebugBuffers(e.context, o) : h._makeDebugTileBoundsBuffers(e.context, o.projection);
            const _ = h._tileDebugBuffer || e.debugBuffer
              , g = h._tileDebugIndexBuffer || e.debugIndexBuffer
              , y = h._tileDebugSegments || e.debugSegments;
            u.draw(n, s.LINE_STRIP, d, p, m, t.CullFaceMode.disabled, Zi(c, t.Color.red), f, _, g, y, null, null, null, [h._globeTileDebugBorderBuffer]);
            const x = h.latestRawTileData
              , v = Math.floor((x && x.byteLength || 0) / 1024)
              , b = i.getTile(r).tileSize
              , w = 512 / Math.min(b, 512) * (r.overscaledZ / o.zoom) * .5;
            let z = r.canonical.toString();
            r.overscaledZ !== r.canonical.z && (z += ` => ${r.overscaledZ}`),
            z += ` ${v}kb`,
            function(t, e) {
                t.initDebugOverlayCanvas();
                const i = t.debugOverlayCanvas
                  , r = t.context.gl
                  , n = t.debugOverlayCanvas.getContext("2d");
                n.clearRect(0, 0, i.width, i.height),
                n.shadowColor = "white",
                n.shadowBlur = 2,
                n.lineWidth = 1.5,
                n.strokeStyle = "white",
                n.textBaseline = "top",
                n.font = "bold 36px Open Sans, sans-serif",
                n.fillText(e, 5, 5),
                n.strokeText(e, 5, 5),
                t.debugOverlayTexture.update(i),
                t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE)
            }(e, z);
            const T = h._tileDebugTextBuffer || e.debugBuffer
              , E = h._tileDebugTextIndexBuffer || e.quadTriangleIndexBuffer
              , S = h._tileDebugTextSegments || e.debugSegments;
            u.draw(n, s.TRIANGLES, d, p, t.ColorMode.alphaBlended, t.CullFaceMode.disabled, Zi(c, t.Color.transparent, w), f, T, E, S, null, null, null, [h._globeTileDebugTextBuffer])
        }
        function wr(t, e, i, r) {
            Tr(t, 0, e + i / 2, t.transform.width, i, r)
        }
        function zr(t, e, i, r) {
            Tr(t, e - i / 2, 0, i, t.transform.height, r)
        }
        function Tr(e, i, r, n, o, s) {
            const a = e.context
              , l = a.gl;
            l.enable(l.SCISSOR_TEST),
            l.scissor(i * t.exported.devicePixelRatio, r * t.exported.devicePixelRatio, n * t.exported.devicePixelRatio, o * t.exported.devicePixelRatio),
            a.clear({
                color: s
            }),
            l.disable(l.SCISSOR_TEST)
        }
        const Er = t.createLayout([{
            name: "a_pos_3f",
            components: 3,
            type: "Float32"
        }])
          , {members: Sr} = Er;
        function Mr(t, e, i, r) {
            t.emplaceBack(e, i, r)
        }
        class Ar {
            constructor(e) {
                this.vertexArray = new t.StructArrayLayout3f12,
                this.indices = new t.StructArrayLayout3ui6,
                Mr(this.vertexArray, -1, -1, 1),
                Mr(this.vertexArray, 1, -1, 1),
                Mr(this.vertexArray, -1, 1, 1),
                Mr(this.vertexArray, 1, 1, 1),
                Mr(this.vertexArray, -1, -1, -1),
                Mr(this.vertexArray, 1, -1, -1),
                Mr(this.vertexArray, -1, 1, -1),
                Mr(this.vertexArray, 1, 1, -1),
                this.indices.emplaceBack(5, 1, 3),
                this.indices.emplaceBack(3, 7, 5),
                this.indices.emplaceBack(6, 2, 0),
                this.indices.emplaceBack(0, 4, 6),
                this.indices.emplaceBack(2, 6, 7),
                this.indices.emplaceBack(7, 3, 2),
                this.indices.emplaceBack(5, 4, 0),
                this.indices.emplaceBack(0, 1, 5),
                this.indices.emplaceBack(0, 2, 3),
                this.indices.emplaceBack(3, 1, 0),
                this.indices.emplaceBack(7, 6, 4),
                this.indices.emplaceBack(4, 5, 7),
                this.vertexBuffer = e.createVertexBuffer(this.vertexArray, Sr),
                this.indexBuffer = e.createIndexBuffer(this.indices),
                this.segment = t.SegmentVector.simpleSegment(0, 0, 36, 12)
            }
        }
        function Ir(e, i, r, n, o, s) {
            const a = e.gl
              , l = i.paint.get("sky-atmosphere-color")
              , c = i.paint.get("sky-atmosphere-halo-color")
              , u = i.paint.get("sky-atmosphere-sun-intensity")
              , h = (d = t.fromMat4(t.create$1(), n),
            m = c,
            {
                u_matrix_3f: d,
                u_sun_direction: o,
                u_sun_intensity: u,
                u_color_tint_r: [(p = l).r, p.g, p.b, p.a],
                u_color_tint_m: [m.r, m.g, m.b, m.a],
                u_luminance: 5e-5
            });
            var d, p, m;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0),
            r.draw(e, a.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.frontCW, h, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
        }
        const Cr = t.createLayout([{
            type: "Float32",
            name: "a_pos",
            components: 3
        }, {
            type: "Float32",
            name: "a_uv",
            components: 2
        }]);
        class Dr {
            constructor(e) {
                const i = new t.StructArrayLayout5f20;
                i.emplaceBack(-1, 1, 1, 0, 0),
                i.emplaceBack(1, 1, 1, 1, 0),
                i.emplaceBack(1, -1, 1, 1, 1),
                i.emplaceBack(-1, -1, 1, 0, 1);
                const r = new t.StructArrayLayout3ui6;
                r.emplaceBack(0, 1, 2),
                r.emplaceBack(2, 3, 0),
                this.vertexBuffer = e.createVertexBuffer(i, Cr.members),
                this.indexBuffer = e.createIndexBuffer(r),
                this.segments = t.SegmentVector.simpleSegment(0, 0, 4, 2)
            }
            destroy() {
                this.vertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.segments.destroy()
            }
        }
        const kr = {
            symbol: function(e, i, r, n, o) {
                if ("translucent" !== e.renderPass)
                    return;
                const s = t.StencilMode.disabled
                  , a = e.colorModeForRenderPass();
                r.layout.get("text-variable-anchor") && function(e, i, r, n, o, s, a) {
                    const l = i.transform
                      , c = "map" === o
                      , u = "map" === s;
                    for (const i of e) {
                        const e = n.getTile(i)
                          , o = e.getBucket(r);
                        if (!o || !o.text || !o.text.segments.get().length)
                            continue;
                        const s = t.evaluateSizeForZoom(o.textSizeData, l.zoom)
                          , h = ve(i, o.getProjection(), l)
                          , d = l.calculatePixelsToTileUnitsMatrix(e)
                          , p = ee(h, e.tileID.canonical, u, c, l, o.getProjection(), d)
                          , m = "none" !== r.layout.get("icon-text-fit") && o.hasIconData();
                        if (s) {
                            const r = Math.pow(2, l.zoom - e.tileID.overscaledZ);
                            ur(o, c, u, a, t.symbolSize, l, p, i, r, s, m)
                        }
                    }
                }(n, e, r, i, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), o),
                0 !== r.paint.get("icon-opacity").constantOr(1) && hr(e, i, r, n, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), s, a),
                0 !== r.paint.get("text-opacity").constantOr(1) && hr(e, i, r, n, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), s, a),
                i.map.showCollisionBoxes && (ar(e, i, r, n, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), !0),
                ar(e, i, r, n, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), !1))
            },
            circle: function(e, i, r, n) {
                if ("translucent" !== e.renderPass)
                    return;
                const o = r.paint.get("circle-opacity")
                  , s = r.paint.get("circle-stroke-width")
                  , a = r.paint.get("circle-stroke-opacity")
                  , l = void 0 !== r.layout.get("circle-sort-key").constantOr(1);
                if (0 === o.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1)))
                    return;
                const c = e.context
                  , u = c.gl
                  , h = e.transform
                  , d = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , p = t.StencilMode.disabled
                  , m = e.colorModeForRenderPass()
                  , f = "globe" === h.projection.name
                  , _ = [t.mercatorXfromLng(h.center.lng), t.mercatorYfromLat(h.center.lat)]
                  , g = [];
                for (let o = 0; o < n.length; o++) {
                    const s = n[o]
                      , a = i.getTile(s)
                      , c = a.getBucket(r);
                    if (!c || c.projection.name !== h.projection.name)
                        continue;
                    const u = c.programConfigurations.get(r.id)
                      , d = ji(r);
                    f && d.push("PROJECTION_GLOBE_VIEW");
                    const p = e.useProgram("circle", u, d)
                      , m = c.layoutVertexBuffer
                      , y = c.globeExtVertexBuffer
                      , x = c.indexBuffer
                      , v = h.projection.createInversionMatrix(h, s.canonical)
                      , b = {
                        programConfiguration: u,
                        program: p,
                        layoutVertexBuffer: m,
                        globeExtVertexBuffer: y,
                        indexBuffer: x,
                        uniformValues: Gi(e, s, a, v, _, r),
                        tile: a
                    };
                    if (l) {
                        const e = c.segments.get();
                        for (const i of e)
                            g.push({
                                segments: new t.SegmentVector([i]),
                                sortKey: i.sortKey,
                                state: b
                            })
                    } else
                        g.push({
                            segments: c.segments,
                            sortKey: 0,
                            state: b
                        })
                }
                l && g.sort(((t,e)=>t.sortKey - e.sortKey));
                const y = {
                    useDepthForOcclusion: !f
                };
                for (const i of g) {
                    const {programConfiguration: n, program: o, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: f, tile: _} = i.state
                      , g = i.segments;
                    e.terrain && e.terrain.setupElevationDraw(_, o, y),
                    e.prepareDrawProgram(c, o, _.tileID.toUnwrapped()),
                    o.draw(c, u.TRIANGLES, d, p, m, t.CullFaceMode.disabled, f, r.id, s, l, g, r.paint, h.zoom, n, [a])
                }
            },
            heatmap: function(e, i, r, n) {
                if (0 !== r.paint.get("heatmap-opacity"))
                    if ("offscreen" === e.renderPass) {
                        const o = e.context
                          , s = o.gl
                          , a = t.StencilMode.disabled
                          , l = new t.ColorMode([s.ONE, s.ONE],t.Color.transparent,[!0, !0, !0, !0]);
                        !function(t, e, i, r) {
                            const n = t.gl
                              , o = e.width * r
                              , s = e.height * r;
                            t.activeTexture.set(n.TEXTURE1),
                            t.viewport.set([0, 0, o, s]);
                            let a = i.heatmapFbo;
                            if (!a || a && (a.width !== o || a.height !== s)) {
                                a && a.destroy();
                                const e = n.createTexture();
                                n.bindTexture(n.TEXTURE_2D, e),
                                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
                                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
                                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR),
                                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR),
                                a = i.heatmapFbo = t.createFramebuffer(o, s, !1),
                                function(t, e, i, r, n, o) {
                                    const s = t.gl;
                                    s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, n, o, 0, s.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null),
                                    r.colorAttachment.set(i)
                                }(t, 0, e, a, o, s)
                            } else
                                n.bindTexture(n.TEXTURE_2D, a.colorAttachment.get()),
                                t.bindFramebuffer.set(a.framebuffer)
                        }(o, e, r, "globe" === e.transform.projection.name ? .5 : .25),
                        o.clear({
                            color: t.Color.transparent
                        });
                        const c = e.transform
                          , u = "globe" === c.projection.name
                          , h = u ? ["PROJECTION_GLOBE_VIEW"] : null
                          , d = u ? t.CullFaceMode.frontCCW : t.CullFaceMode.disabled
                          , p = [t.mercatorXfromLng(c.center.lng), t.mercatorYfromLat(c.center.lat)];
                        for (let m = 0; m < n.length; m++) {
                            const f = n[m];
                            if (i.hasRenderableParent(f))
                                continue;
                            const _ = i.getTile(f)
                              , g = _.getBucket(r);
                            if (!g || g.projection.name !== c.projection.name)
                                continue;
                            const y = g.programConfigurations.get(r.id)
                              , x = e.useProgram("heatmap", y, h)
                              , {zoom: v} = e.transform;
                            e.terrain && e.terrain.setupElevationDraw(_, x),
                            e.prepareDrawProgram(o, x, f.toUnwrapped());
                            const b = c.projection.createInversionMatrix(c, f.canonical);
                            x.draw(o, s.TRIANGLES, t.DepthMode.disabled, a, l, d, Xi(e, f, _, b, p, v, r.paint.get("heatmap-intensity")), r.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, r.paint, e.transform.zoom, y, u ? [g.globeExtVertexBuffer] : null)
                        }
                        o.viewport.set([0, 0, e.width, e.height])
                    } else
                        "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()),
                        function(e, i) {
                            const r = e.context
                              , n = r.gl
                              , o = i.heatmapFbo;
                            if (!o)
                                return;
                            r.activeTexture.set(n.TEXTURE0),
                            n.bindTexture(n.TEXTURE_2D, o.colorAttachment.get()),
                            r.activeTexture.set(n.TEXTURE1);
                            let s = i.colorRampTexture;
                            var a;
                            s || (s = i.colorRampTexture = new t.Texture(r,i.colorRamp,n.RGBA)),
                            s.bind(n.LINEAR, n.CLAMP_TO_EDGE),
                            e.useProgram("heatmapTexture").draw(r, n.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, (a = i,
                            {
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: a.paint.get("heatmap-opacity")
                            }), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom)
                        }(e, r))
            },
            line: function(e, i, r, n) {
                if ("translucent" !== e.renderPass)
                    return;
                const o = r.paint.get("line-opacity")
                  , s = r.paint.get("line-width");
                if (0 === o.constantOr(1) || 0 === s.constantOr(1))
                    return;
                const a = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , l = e.colorModeForRenderPass()
                  , c = e.terrain && e.terrain.renderingToTexture ? 1 : t.exported.devicePixelRatio
                  , u = r.paint.get("line-dasharray")
                  , h = u.constantOr(1)
                  , d = r.layout.get("line-cap")
                  , p = r.paint.get("line-pattern")
                  , m = p.constantOr(1)
                  , f = r.paint.get("line-gradient")
                  , _ = m ? "linePattern" : "line"
                  , g = e.context
                  , y = g.gl
                  , x = (t=>{
                    const e = [];
                    Hi(t) && e.push("RENDER_LINE_DASH"),
                    t.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
                    const i = t.paint.get("line-trim-offset");
                    0 === i[0] && 0 === i[1] || e.push("RENDER_LINE_TRIM_OFFSET");
                    const r = t.paint.get("line-pattern").constantOr(1)
                      , n = 1 !== t.paint.get("line-opacity").constantOr(1);
                    return !r && n && e.push("RENDER_LINE_ALPHA_DISCARD"),
                    e
                }
                )(r);
                let v = x.includes("RENDER_LINE_ALPHA_DISCARD");
                e.terrain && e.terrain.clipOrMaskOverlapStencilType() && (v = !1);
                for (const o of n) {
                    const n = i.getTile(o);
                    if (m && !n.patternsLoaded())
                        continue;
                    const s = n.getBucket(r);
                    if (!s)
                        continue;
                    e.prepareDrawTile();
                    const b = s.programConfigurations.get(r.id)
                      , w = e.useProgram(_, b, x)
                      , z = p.constantOr(null);
                    if (z && n.imageAtlas) {
                        const t = n.imageAtlas.patternPositions[z.toString()];
                        t && b.setConstantPatternPositions(t)
                    }
                    const T = u.constantOr(null)
                      , E = d.constantOr(null);
                    if (!m && T && E && n.lineAtlas) {
                        const t = n.lineAtlas.getDash(T, E);
                        t && b.setConstantPatternPositions(t)
                    }
                    let[S,M] = r.paint.get("line-trim-offset");
                    if ("round" === E || "square" === E) {
                        const t = 1;
                        S !== M && (0 === S && (S -= t),
                        1 === M && (M += t))
                    }
                    const A = e.terrain ? o.projMatrix : null
                      , I = m ? $i(e, n, r, A, c) : qi(e, n, r, A, s.lineClipsArray.length, c, [S, M]);
                    if (f) {
                        const n = s.gradients[r.id];
                        let a = n.texture;
                        if (r.gradientVersion !== n.version) {
                            let l = 256;
                            if (r.stepInterpolant) {
                                const r = i.getSource().maxzoom
                                  , n = o.canonical.z === r ? Math.ceil(1 << e.transform.maxZoom - o.canonical.z) : 1;
                                l = t.clamp(t.nextPowerOfTwo(s.maxLineLength / t.EXTENT * 1024 * n), 256, g.maxTextureSize)
                            }
                            n.gradient = t.renderColorRamp({
                                expression: r.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l,
                                image: n.gradient || void 0,
                                clips: s.lineClipsArray
                            }),
                            n.texture ? n.texture.update(n.gradient) : n.texture = new t.Texture(g,n.gradient,y.RGBA),
                            n.version = r.gradientVersion,
                            a = n.texture
                        }
                        g.activeTexture.set(y.TEXTURE1),
                        a.bind(r.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE)
                    }
                    h && (g.activeTexture.set(y.TEXTURE0),
                    n.lineAtlasTexture.bind(y.LINEAR, y.REPEAT),
                    b.updatePaintBuffers()),
                    m && (g.activeTexture.set(y.TEXTURE0),
                    n.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE),
                    b.updatePaintBuffers()),
                    e.prepareDrawProgram(g, w, o.toUnwrapped());
                    const C = i=>{
                        w.draw(g, y.TRIANGLES, a, i, l, t.CullFaceMode.disabled, I, r.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, r.paint, e.transform.zoom, b, [s.layoutVertexBuffer2])
                    }
                    ;
                    if (v) {
                        const i = e.stencilModeForClipping(o).ref;
                        0 === i && e.terrain && g.clear({
                            stencil: 0
                        });
                        const r = {
                            func: y.EQUAL,
                            mask: 255
                        };
                        I.u_alpha_discard_threshold = .8,
                        C(new t.StencilMode(r,i,255,y.KEEP,y.KEEP,y.INVERT)),
                        I.u_alpha_discard_threshold = 0,
                        C(new t.StencilMode(r,i,255,y.KEEP,y.KEEP,y.KEEP))
                    } else
                        C(e.stencilModeForClipping(o))
                }
                v && (e.resetStencilClippingMasks(),
                e.terrain && g.clear({
                    stencil: 0
                }))
            },
            fill: function(e, i, r, n) {
                const o = r.paint.get("fill-color")
                  , s = r.paint.get("fill-opacity");
                if (0 === s.constantOr(1))
                    return;
                const a = e.colorModeForRenderPass()
                  , l = r.paint.get("fill-pattern")
                  , c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === o.constantOr(t.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
                if (e.renderPass === c) {
                    const o = e.depthModeForSublayer(1, "opaque" === e.renderPass ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly);
                    pr(e, i, r, n, o, a, !1)
                }
                if ("translucent" === e.renderPass && r.paint.get("fill-antialias")) {
                    const o = e.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, t.DepthMode.ReadOnly);
                    pr(e, i, r, n, o, a, !0)
                }
            },
            "fill-extrusion": function(e, i, r, n) {
                const o = r.paint.get("fill-extrusion-opacity");
                if (0 !== o && "translucent" === e.renderPass) {
                    const s = new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                    if (1 !== o || r.paint.get("fill-extrusion-pattern").constantOr(1))
                        mr(e, i, r, n, s, t.StencilMode.disabled, t.ColorMode.disabled),
                        mr(e, i, r, n, s, e.stencilModeFor3D(), e.colorModeForRenderPass()),
                        e.resetStencilClippingMasks();
                    else {
                        const o = e.colorModeForRenderPass();
                        mr(e, i, r, n, s, t.StencilMode.disabled, o)
                    }
                }
            },
            hillshade: function(e, i, r, n) {
                if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass)
                    return;
                const o = e.context
                  , s = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , a = e.colorModeForRenderPass()
                  , l = e.terrain && e.terrain.renderingToTexture
                  , [c,u] = "translucent" !== e.renderPass || l ? [{}, n] : e.stencilConfigForOverlap(n);
                for (const n of u) {
                    const o = i.getTile(n);
                    if (o.needsHillshadePrepare && "offscreen" === e.renderPass)
                        gi(e, o, r, s, t.StencilMode.disabled, a);
                    else if ("translucent" === e.renderPass) {
                        const t = l && e.terrain ? e.terrain.stencilModeForRTTOverlap(n) : c[n.overscaledZ];
                        fi(e, n, o, r, s, t, a)
                    }
                }
                o.viewport.set([0, 0, e.width, e.height]),
                e.resetStencilClippingMasks()
            },
            raster: function(e, i, r, n, o, s) {
                if ("translucent" !== e.renderPass)
                    return;
                if (0 === r.paint.get("raster-opacity"))
                    return;
                if (!n.length)
                    return;
                const a = e.context
                  , l = a.gl
                  , c = i.getSource()
                  , u = e.useProgram("raster")
                  , h = e.colorModeForRenderPass()
                  , d = e.terrain && e.terrain.renderingToTexture
                  , [p,m] = c instanceof Ct || d ? [{}, n] : e.stencilConfigForOverlap(n)
                  , f = m[m.length - 1].overscaledZ
                  , _ = !e.options.moving;
                for (const n of m) {
                    const o = d ? t.DepthMode.disabled : e.depthModeForSublayer(n.overscaledZ - f, 1 === r.paint.get("raster-opacity") ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly, l.LESS)
                      , m = n.toUnwrapped()
                      , g = i.getTile(n);
                    if (d && (!g || !g.hasData()))
                        continue;
                    const y = d ? n.projMatrix : e.transform.calculateProjMatrix(m, _)
                      , x = e.terrain && d ? e.terrain.stencilModeForRTTOverlap(n) : p[n.overscaledZ]
                      , v = s ? 0 : r.paint.get("raster-fade-duration");
                    g.registerFadeDuration(v);
                    const b = i.findLoadedParent(n, 0)
                      , w = Si(g, b, i, e.transform, v);
                    let z, T;
                    e.terrain && e.terrain.prepareDrawTile();
                    const E = "nearest" === r.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                    a.activeTexture.set(l.TEXTURE0),
                    g.texture.bind(E, l.CLAMP_TO_EDGE),
                    a.activeTexture.set(l.TEXTURE1),
                    b ? (b.texture.bind(E, l.CLAMP_TO_EDGE),
                    z = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ),
                    T = [g.tileID.canonical.x * z % 1, g.tileID.canonical.y * z % 1]) : g.texture.bind(E, l.CLAMP_TO_EDGE);
                    const S = Ki(y, T || [0, 0], z || 1, w, r, c instanceof Ct ? c.perspectiveTransform : [0, 0]);
                    if (e.prepareDrawProgram(a, u, m),
                    c instanceof Ct)
                        c.boundsBuffer && c.boundsSegments && u.draw(a, l.TRIANGLES, o, t.StencilMode.disabled, h, t.CullFaceMode.disabled, S, r.id, c.boundsBuffer, e.quadTriangleIndexBuffer, c.boundsSegments);
                    else {
                        const {tileBoundsBuffer: i, tileBoundsIndexBuffer: n, tileBoundsSegments: s} = e.getTileBoundsBuffers(g);
                        u.draw(a, l.TRIANGLES, o, x, h, t.CullFaceMode.disabled, S, r.id, i, n, s)
                    }
                }
                e.resetStencilClippingMasks()
            },
            background: function(e, i, r, n) {
                const o = r.paint.get("background-color")
                  , s = r.paint.get("background-opacity");
                if (0 === s)
                    return;
                const a = e.context
                  , l = a.gl
                  , c = e.transform
                  , u = c.tileSize
                  , h = r.paint.get("background-pattern");
                if (e.isPatternMissing(h))
                    return;
                const d = !h && 1 === o.a && 1 === s && e.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (e.renderPass !== d)
                    return;
                const p = t.StencilMode.disabled
                  , m = e.depthModeForSublayer(0, "opaque" === d ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly)
                  , f = e.colorModeForRenderPass()
                  , _ = e.useProgram(h ? "backgroundPattern" : "background");
                let g, y = n;
                y || (g = e.getBackgroundTiles(),
                y = Object.values(g).map((t=>t.tileID))),
                h && (a.activeTexture.set(l.TEXTURE0),
                e.imageManager.bind(e.context));
                for (const d of y) {
                    const y = d.toUnwrapped()
                      , T = n ? d.projMatrix : e.transform.calculateProjMatrix(y);
                    e.prepareDrawTile();
                    const E = i ? i.getTile(d) : g ? g[d.key] : new t.Tile(d,u,c.zoom,e)
                      , S = h ? (x = T,
                    v = s,
                    b = e,
                    w = h,
                    z = {
                        tileID: d,
                        tileSize: u
                    },
                    t.extend(function(t, e, i) {
                        const r = e.imageManager.getPattern(t.toString())
                          , {width: n, height: o} = e.imageManager.getPixelSize()
                          , s = Math.pow(2, i.tileID.overscaledZ)
                          , a = i.tileSize * Math.pow(2, e.transform.tileZoom) / s
                          , l = a * (i.tileID.canonical.x + i.tileID.wrap * s)
                          , c = a * i.tileID.canonical.y;
                        return {
                            u_image: 0,
                            u_pattern_tl: r.tl,
                            u_pattern_br: r.br,
                            u_texsize: [n, o],
                            u_pattern_size: r.displaySize,
                            u_tile_units_to_pixels: 1 / P(i, 1, e.transform.tileZoom),
                            u_pixel_coord_upper: [l >> 16, c >> 16],
                            u_pixel_coord_lower: [65535 & l, 65535 & c]
                        }
                    }(w, b, z), {
                        u_matrix: x,
                        u_opacity: v
                    })) : nr(T, s, o);
                    e.prepareDrawProgram(a, _, y);
                    const {tileBoundsBuffer: M, tileBoundsIndexBuffer: A, tileBoundsSegments: I} = e.getTileBoundsBuffers(E);
                    _.draw(a, l.TRIANGLES, m, p, f, t.CullFaceMode.disabled, S, r.id, M, A, I)
                }
                var x, v, b, w, z
            },
            sky: function(e, i, r) {
                const n = e.transform
                  , o = "mercator" === n.projection.name || "globe" === n.projection.name ? 1 : t.smoothstep(7, 8, n.zoom)
                  , s = r.paint.get("sky-opacity") * o;
                if (0 === s)
                    return;
                const a = e.context
                  , l = r.paint.get("sky-type")
                  , c = new t.DepthMode(a.gl.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                  , u = e.frameCounter / 1e3 % 1;
                "atmosphere" === l ? "offscreen" === e.renderPass ? r.needsSkyboxCapture(e) && (function(e, i, r, n) {
                    const o = e.context
                      , s = o.gl;
                    let a = i.skyboxFbo;
                    if (!a) {
                        a = i.skyboxFbo = o.createFramebuffer(32, 32, !1),
                        i.skyboxGeometry = new Ar(o),
                        i.skyboxTexture = o.gl.createTexture(),
                        s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                        for (let t = 0; t < 6; ++t)
                            s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null)
                    }
                    o.bindFramebuffer.set(a.framebuffer),
                    o.viewport.set([0, 0, 32, 32]);
                    const l = i.getCenter(e, !0)
                      , c = e.useProgram("skyboxCapture")
                      , u = new Float64Array(16);
                    t.identity(u),
                    t.rotateY(u, u, .5 * -Math.PI),
                    Ir(o, i, c, u, l, 0),
                    t.identity(u),
                    t.rotateY(u, u, .5 * Math.PI),
                    Ir(o, i, c, u, l, 1),
                    t.identity(u),
                    t.rotateX(u, u, .5 * -Math.PI),
                    Ir(o, i, c, u, l, 2),
                    t.identity(u),
                    t.rotateX(u, u, .5 * Math.PI),
                    Ir(o, i, c, u, l, 3),
                    t.identity(u),
                    Ir(o, i, c, u, l, 4),
                    t.identity(u),
                    t.rotateY(u, u, Math.PI),
                    Ir(o, i, c, u, l, 5),
                    o.viewport.set([0, 0, e.width, e.height])
                }(e, r),
                r.markSkyboxValid(e)) : "sky" === e.renderPass && function(e, i, r, n, o) {
                    const s = e.context
                      , a = s.gl
                      , l = e.transform
                      , c = e.useProgram("skybox");
                    s.activeTexture.set(a.TEXTURE0),
                    a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
                    const u = (h = l.skyboxMatrix,
                    d = i.getCenter(e, !1),
                    {
                        u_matrix: h,
                        u_sun_direction: d,
                        u_cubemap: 0,
                        u_opacity: n,
                        u_temporal_offset: o
                    });
                    var h, d;
                    e.prepareDrawProgram(s, c),
                    c.draw(s, a.TRIANGLES, r, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, u, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
                }(e, r, c, s, u) : "gradient" === l && "sky" === e.renderPass && function(e, i, r, n, o) {
                    const s = e.context
                      , a = s.gl
                      , l = e.transform
                      , c = e.useProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new Ar(s)),
                    s.activeTexture.set(a.TEXTURE0);
                    let u = i.colorRampTexture;
                    u || (u = i.colorRampTexture = new t.Texture(s,i.colorRamp,a.RGBA)),
                    u.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const h = (d = l.skyboxMatrix,
                    p = i.getCenter(e, !1),
                    m = i.paint.get("sky-gradient-radius"),
                    f = n,
                    _ = o,
                    {
                        u_matrix: d,
                        u_color_ramp: 0,
                        u_center_direction: p,
                        u_radius: t.degToRad(m),
                        u_opacity: f,
                        u_temporal_offset: _
                    });
                    var d, p, m, f, _;
                    e.prepareDrawProgram(s, c),
                    c.draw(s, a.TRIANGLES, r, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, h, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
                }(e, r, c, s, u)
            },
            debug: function(t, e, i) {
                for (let r = 0; r < i.length; r++)
                    br(t, e, i[r])
            },
            custom: function(e, i, r) {
                const n = e.context
                  , o = r.implementation;
                if (e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes("custom"))
                    t.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
                else if ("offscreen" === e.renderPass) {
                    const t = o.prerender;
                    t && (e.setCustomLayerDefaults(),
                    n.setColorMode(e.colorModeForRenderPass()),
                    t.call(o, n.gl, e.transform.customLayerMatrix()),
                    n.setDirty(),
                    e.setBaseState())
                } else if ("translucent" === e.renderPass) {
                    e.setCustomLayerDefaults(),
                    n.setColorMode(e.colorModeForRenderPass()),
                    n.setStencilMode(t.StencilMode.disabled);
                    const i = "3d" === o.renderingMode ? new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D) : e.depthModeForSublayer(0, t.DepthMode.ReadOnly);
                    n.setDepthMode(i),
                    o.render(n.gl, e.transform.customLayerMatrix()),
                    n.setDirty(),
                    e.setBaseState(),
                    n.bindFramebuffer.set(null)
                }
            }
        };
        class Pr {
            constructor(e, i) {
                this.context = new St(e),
                this.transform = i,
                this._tileTextures = {},
                this.frameCopies = [],
                this.loadTimeStamps = [],
                this.setup(),
                this.numSublayers = t.SourceCache.maxUnderzooming + t.SourceCache.maxOverzooming + 1,
                this.depthEpsilon = 1 / Math.pow(2, 16),
                this.crossTileSymbolIndex = new Xe,
                this.deferredRenderGpuTimeQueries = [],
                this.gpuTimers = {},
                this.frameCounter = 0,
                this._backgroundTiles = {}
            }
            updateTerrain(t, e) {
                const i = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled))
                    return;
                this._terrain || (this._terrain = new Ci(this,t));
                const r = this._terrain;
                this.transform.elevation = i ? r : null,
                r.update(t, this.transform, e)
            }
            _updateFog(t) {
                const e = t.fog;
                if (!e || "globe" === this.transform.projection.name || e.getOpacity(this.transform.pitch) < 1 || e.properties.get("horizon-blend") < .03)
                    return void (this.transform.fogCullDistSq = null);
                const [i,r] = e.getFovAdjustedRange(this.transform._fov);
                if (i > r)
                    return void (this.transform.fogCullDistSq = null);
                const n = i + .78 * (r - i);
                this.transform.fogCullDistSq = n * n
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null
            }
            resize(e, i) {
                if (this.width = e * t.exported.devicePixelRatio,
                this.height = i * t.exported.devicePixelRatio,
                this.context.viewport.set([0, 0, this.width, this.height]),
                this.style)
                    for (const t of this.style.order)
                        this.style._layers[t].resize()
            }
            setup() {
                const e = this.context
                  , i = new t.StructArrayLayout2i4;
                i.emplaceBack(0, 0),
                i.emplaceBack(t.EXTENT, 0),
                i.emplaceBack(0, t.EXTENT),
                i.emplaceBack(t.EXTENT, t.EXTENT),
                this.tileExtentBuffer = e.createVertexBuffer(i, t.posAttributes.members),
                this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const r = new t.StructArrayLayout2i4;
                r.emplaceBack(0, 0),
                r.emplaceBack(t.EXTENT, 0),
                r.emplaceBack(0, t.EXTENT),
                r.emplaceBack(t.EXTENT, t.EXTENT),
                this.debugBuffer = e.createVertexBuffer(r, t.posAttributes.members),
                this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
                const n = new t.StructArrayLayout2i4;
                n.emplaceBack(-1, -1),
                n.emplaceBack(1, -1),
                n.emplaceBack(-1, 1),
                n.emplaceBack(1, 1),
                this.viewportBuffer = e.createVertexBuffer(n, t.posAttributes.members),
                this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const o = new t.StructArrayLayout4i8;
                o.emplaceBack(0, 0, 0, 0),
                o.emplaceBack(t.EXTENT, 0, t.EXTENT, 0),
                o.emplaceBack(0, t.EXTENT, 0, t.EXTENT),
                o.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT),
                this.mercatorBoundsBuffer = e.createVertexBuffer(o, t.boundsAttributes.members),
                this.mercatorBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s = new t.StructArrayLayout3ui6;
                s.emplaceBack(0, 1, 2),
                s.emplaceBack(2, 1, 3),
                this.quadTriangleIndexBuffer = e.createIndexBuffer(s);
                const a = new t.StructArrayLayout1ui2;
                for (const t of [0, 1, 3, 2, 0])
                    a.emplaceBack(t);
                this.debugIndexBuffer = e.createIndexBuffer(a),
                this.emptyTexture = new t.Texture(e,new t.RGBAImage({
                    width: 1,
                    height: 1
                },Uint8Array.of(0, 0, 0, 0)),e.gl.RGBA),
                this.identityMat = t.create();
                const l = this.context.gl;
                this.stencilClearMode = new t.StencilMode({
                    func: l.ALWAYS,
                    mask: 0
                },0,255,l.ZERO,l.ZERO,l.ZERO),
                this.loadTimeStamps.push(t.window.performance.now()),
                this.atmosphereBuffer = new Dr(this.context)
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                }
            }
            getTileBoundsBuffers(t) {
                return t._makeTileBoundsBuffers(this.context, this.transform.projection),
                t._tileBoundsBuffer ? {
                    tileBoundsBuffer: t._tileBoundsBuffer,
                    tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                    tileBoundsSegments: t._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers()
            }
            clearStencil() {
                const e = this.context
                  , i = e.gl;
                this.nextStencilID = 1,
                this.currentStencilSource = void 0,
                this._tileClippingMaskIDs = {},
                this.useProgram("clippingMask").draw(e, i.TRIANGLES, t.DepthMode.disabled, this.stencilClearMode, t.ColorMode.disabled, t.CullFaceMode.disabled, Ei(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0,
                this._tileClippingMaskIDs = {})
            }
            _renderTileClippingMasks(e, i, r) {
                if (!i || this.currentStencilSource === i.id || !e.isTileClipped() || !r || 0 === r.length)
                    return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let t = !1;
                    for (const e of r)
                        if (void 0 === this._tileClippingMaskIDs[e.key]) {
                            t = !0;
                            break
                        }
                    if (!t)
                        return
                }
                this.currentStencilSource = i.id;
                const n = this.context
                  , o = n.gl;
                this.nextStencilID + r.length > 256 && this.clearStencil(),
                n.setColorMode(t.ColorMode.disabled),
                n.setDepthMode(t.DepthMode.disabled);
                const s = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e of r) {
                    const r = i.getTile(e)
                      , a = this._tileClippingMaskIDs[e.key] = this.nextStencilID++
                      , {tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: u} = this.getTileBoundsBuffers(r);
                    s.draw(n, o.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                        func: o.ALWAYS,
                        mask: 0
                    },a,255,o.KEEP,o.KEEP,o.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, Ei(e.projMatrix), "$clipping", l, c, u)
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0,
                this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++
                  , i = this.context.gl;
                return new t.StencilMode({
                    func: i.NOTEQUAL,
                    mask: 255
                },e,255,i.KEEP,i.KEEP,i.REPLACE)
            }
            stencilModeForClipping(e) {
                if (this.terrain)
                    return this.terrain.stencilModeForRTTOverlap(e);
                const i = this.context.gl;
                return new t.StencilMode({
                    func: i.EQUAL,
                    mask: 255
                },this._tileClippingMaskIDs[e.key],0,i.KEEP,i.KEEP,i.REPLACE)
            }
            stencilConfigForOverlap(e) {
                const i = this.context.gl
                  , r = e.sort(((t,e)=>e.overscaledZ - t.overscaledZ))
                  , n = r[r.length - 1].overscaledZ
                  , o = r[0].overscaledZ - n + 1;
                if (o > 1) {
                    this.currentStencilSource = void 0,
                    this.nextStencilID + o > 256 && this.clearStencil();
                    const e = {};
                    for (let r = 0; r < o; r++)
                        e[r + n] = new t.StencilMode({
                            func: i.GEQUAL,
                            mask: 255
                        },r + this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);
                    return this.nextStencilID += o,
                    [e, r]
                }
                return [{
                    [n]: t.StencilMode.disabled
                }, r]
            }
            colorModeForRenderPass() {
                const e = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new t.ColorMode([e.CONSTANT_COLOR, e.ONE],new t.Color(i,i,i,0),[!0, !0, !0, !0])
                }
                return "opaque" === this.renderPass ? t.ColorMode.unblended : t.ColorMode.alphaBlended
            }
            depthModeForSublayer(e, i, r) {
                if (!this.opaquePassEnabledForLayer())
                    return t.DepthMode.disabled;
                const n = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                return new t.DepthMode(r || this.context.gl.LEQUAL,i,[n, n])
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff
            }
            render(e, i) {
                this.style = e,
                this.options = i,
                this.imageManager = e.imageManager,
                this.glyphManager = e.glyphManager,
                this.symbolFadeChange = e.placement.symbolFadeChange(t.exported.now()),
                this.imageManager.beginFrame();
                const r = this.style.order
                  , n = this.style._sourceCaches;
                for (const t in n) {
                    const e = n[t];
                    e.used && e.prepare(this.context)
                }
                const o = {}
                  , s = {}
                  , a = {};
                for (const t in n) {
                    const e = n[t];
                    o[t] = e.getVisibleCoordinates(),
                    s[t] = o[t].slice().reverse(),
                    a[t] = e.getVisibleCoordinates(!0).reverse()
                }
                this.opaquePassCutoff = 1 / 0;
                for (let t = 0; t < r.length; t++)
                    if (this.style._layers[r[t]].is3D()) {
                        this.opaquePassCutoff = t;
                        break
                    }
                if (this.terrain && (this.terrain.updateTileBinding(a),
                this.opaquePassCutoff = 0),
                "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new t.GlobeSharedBuffers(this.context)),
                t.isMapAuthenticated(this.context.gl)) {
                    this.renderPass = "offscreen";
                    for (const t of r) {
                        const i = this.style._layers[t]
                          , r = e._getLayerSourceCache(i);
                        if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom))
                            continue;
                        const n = r ? s[r.id] : void 0;
                        ("custom" === i.type || i.isSky() || n && n.length) && this.renderLayer(this, r, i, n)
                    }
                    if (this.depthRangeFor3D = [0, 1 - (e.order.length + 2) * this.numSublayers * this.depthEpsilon],
                    this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(),
                    this.context.bindFramebuffer.set(null),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.context.clear({
                        color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,
                        depth: 1
                    }),
                    this.clearStencil(),
                    this._showOverdrawInspector = i.showOverdrawInspector,
                    this.renderPass = "opaque",
                    !this.terrain)
                        for (this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                            const t = this.style._layers[r[this.currentLayer]]
                              , i = e._getLayerSourceCache(t);
                            if (t.isSky())
                                continue;
                            const n = i ? s[i.id] : void 0;
                            this._renderTileClippingMasks(t, i, n),
                            this.renderLayer(this, i, t, n)
                        }
                    if (this.style.fog && this.transform.projection.supportsFog && function(e, i) {
                        const r = e.context
                          , n = r.gl
                          , o = e.transform
                          , s = new t.DepthMode(n.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                          , a = e.useProgram("globeAtmosphere", null, "globe" === o.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"])
                          , l = t.globeToMercatorTransition(o.zoom)
                          , c = i.properties.get("color").toArray01()
                          , u = i.properties.get("high-color").toArray01()
                          , h = i.properties.get("space-color").toArray01PremultipliedAlpha()
                          , d = t.identity$1([]);
                        t.rotateY$1(d, d, -t.degToRad(o._center.lng)),
                        t.rotateX$1(d, d, t.degToRad(o._center.lat)),
                        t.rotateZ$1(d, d, o.angle),
                        t.rotateX$1(d, d, -o._pitch);
                        const p = t.fromQuat(new Float32Array(16), d)
                          , m = t.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25)
                          , f = 5e-4
                          , _ = t.mapValue(i.properties.get("horizon-blend"), 0, 1, f, .25)
                          , g = t.globeUseCustomAntiAliasing(e, r, o) && _ === f ? o.worldSize / (2 * Math.PI * 1.025) - 1 : o.globeRadius
                          , y = e.frameCounter / 1e3 % 1
                          , x = t.length(o.globeCenterInViewSpace)
                          , v = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2))
                          , b = Math.acos(v / x)
                          , w = (z = o.frustumCorners.TL,
                        T = o.frustumCorners.TR,
                        E = o.frustumCorners.BR,
                        S = o.frustumCorners.BL,
                        M = o.frustumCorners.horizon,
                        A = y,
                        I = b,
                        C = p,
                        {
                            u_frustum_tl: z,
                            u_frustum_tr: T,
                            u_frustum_br: E,
                            u_frustum_bl: S,
                            u_horizon: M,
                            u_transition: l,
                            u_fadeout_range: _,
                            u_color: c,
                            u_high_color: u,
                            u_space_color: h,
                            u_star_intensity: m,
                            u_star_size: 5 * t.exported.devicePixelRatio,
                            u_star_density: 0,
                            u_temporal_offset: A,
                            u_horizon_angle: I,
                            u_rotation_matrix: C
                        });
                        var z, T, E, S, M, A, I, C;
                        e.prepareDrawProgram(r, a);
                        const D = e.atmosphereBuffer;
                        D && a.draw(r, n.TRIANGLES, s, t.StencilMode.disabled, t.ColorMode.alphaBlended, t.CullFaceMode.backCW, w, "skybox", D.vertexBuffer, D.indexBuffer, D.segments)
                    }(this, this.style.fog),
                    this.renderPass = "sky",
                    (t.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
                        for (this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {
                            const t = this.style._layers[r[this.currentLayer]]
                              , i = e._getLayerSourceCache(t);
                            t.isSky() && this.renderLayer(this, i, t, i ? s[i.id] : void 0)
                        }
                    for (this.renderPass = "translucent",
                    this.currentLayer = 0; this.currentLayer < r.length; ) {
                        const t = this.style._layers[r[this.currentLayer]]
                          , i = e._getLayerSourceCache(t);
                        if (t.isSky()) {
                            ++this.currentLayer;
                            continue
                        }
                        if (this.terrain && this.style.isLayerDraped(t)) {
                            if (t.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;
                                continue
                            }
                            this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                            continue
                        }
                        const n = i ? ("symbol" === t.type ? a : s)[i.id] : void 0;
                        this._renderTileClippingMasks(t, i, i ? o[i.id] : void 0),
                        this.renderLayer(this, i, t, n),
                        ++this.currentLayer
                    }
                    if (this.terrain && this.terrain.postRender(),
                    this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                        let i = null;
                        t.values(this.style._layers).forEach((t=>{
                            const r = e._getLayerSourceCache(t);
                            r && !t.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < r.getSource().maxzoom) && (i = r)
                        }
                        )),
                        i && this.options.showTileBoundaries && kr.debug(this, i, i.getVisibleCoordinates())
                    }
                    this.options.showPadding && function(t) {
                        const e = t.transform.padding;
                        wr(t, t.transform.height - (e.top || 0), 3, _r),
                        wr(t, e.bottom || 0, 3, gr),
                        zr(t, e.left || 0, 3, yr),
                        zr(t, t.transform.width - (e.right || 0), 3, xr);
                        const i = t.transform.centerPoint;
                        var r, n, o, s;
                        r = t,
                        n = i.x,
                        o = t.transform.height - i.y,
                        Tr(r, n - 1, o - 10, 2, 20, s = vr),
                        Tr(r, n - 10, o - 1, 20, 2, s)
                    }(this),
                    this.context.setDefault(),
                    this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER,
                    this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(t.window.performance.now()),
                    this.saveCanvasCopy())
                }
            }
            renderLayer(t, e, i, r) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || r && r.length) && (this.id = i.id,
                this.gpuTimingStart(i),
                t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(i.type) || kr[i.type](t, e, i, r, this.style.placement.variableOffsets, this.options.isInitialLoad),
                this.gpuTimingEnd())
            }
            gpuTimingStart(t) {
                if (!this.options.gpuTiming)
                    return;
                const e = this.context.extTimerQuery;
                let i = this.gpuTimers[t.id];
                i || (i = this.gpuTimers[t.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: e.createQueryEXT()
                }),
                i.calls++,
                e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query)
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const t = this.context.extTimerQuery
                      , e = t.createQueryEXT();
                    this.deferredRenderGpuTimeQueries.push(e),
                    t.beginQueryEXT(t.TIME_ELAPSED_EXT, e)
                }
            }
            gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender)
                    return;
                const t = this.context.extTimerQuery;
                t.endQueryEXT(t.TIME_ELAPSED_EXT)
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming)
                    return;
                const t = this.context.extTimerQuery;
                t.endQueryEXT(t.TIME_ELAPSED_EXT)
            }
            collectGpuTimers() {
                const t = this.gpuTimers;
                return this.gpuTimers = {},
                t
            }
            collectDeferredRenderGpuQueries() {
                const t = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [],
                t
            }
            queryGpuTimers(t) {
                const e = {};
                for (const i in t) {
                    const r = t[i]
                      , n = this.context.extTimerQuery
                      , o = n.getQueryObjectEXT(r.query, n.QUERY_RESULT_EXT) / 1e6;
                    n.deleteQueryEXT(r.query),
                    e[i] = o
                }
                return e
            }
            queryGpuTimeDeferredRender(t) {
                if (!this.options.gpuTimingDeferredRender)
                    return 0;
                const e = this.context.extTimerQuery;
                let i = 0;
                for (const r of t)
                    i += e.getQueryObjectEXT(r, e.QUERY_RESULT_EXT) / 1e6,
                    e.deleteQueryEXT(r);
                return i
            }
            translatePosMatrix(e, i, r, n, o) {
                if (!r[0] && !r[1])
                    return e;
                const s = o ? "map" === n ? this.transform.angle : 0 : "viewport" === n ? -this.transform.angle : 0;
                if (s) {
                    const t = Math.sin(s)
                      , e = Math.cos(s);
                    r = [r[0] * e - r[1] * t, r[0] * t + r[1] * e]
                }
                const a = [o ? r[0] : P(i, r[0], this.transform.zoom), o ? r[1] : P(i, r[1], this.transform.zoom), 0]
                  , l = new Float32Array(16);
                return t.translate(l, e, a),
                l
            }
            saveTileTexture(t) {
                const e = this._tileTextures[t.size[0]];
                e ? e.push(t) : this._tileTextures[t.size[0]] = [t]
            }
            getTileTexture(t) {
                const e = this._tileTextures[t];
                return e && e.length > 0 ? e.pop() : null
            }
            isPatternMissing(t) {
                return null === t || void 0 !== t && !this.imageManager.getPattern(t.toString())
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture
            }
            currentGlobalDefines() {
                const t = this.terrain && this.terrain.renderingToTexture
                  , e = this.terrain && 0 === this.terrain.exaggeration()
                  , i = this.style && this.style.fog
                  , r = [];
                return this.terrainRenderModeElevated() && r.push("TERRAIN"),
                "globe" === this.transform.projection.name && r.push("GLOBE"),
                e && r.push("ZERO_EXAGGERATION"),
                i && !t && 0 !== i.getOpacity(this.transform.pitch) && r.push("FOG"),
                t && r.push("RENDER_TO_TEXTURE"),
                this._showOverdrawInspector && r.push("OVERDRAW_INSPECTOR"),
                r
            }
            useProgram(t, e, i) {
                this.cache = this.cache || {};
                const r = i || []
                  , n = this.currentGlobalDefines().concat(r)
                  , o = Di.cacheKey(ui[t], t, n, e);
                return this.cache[o] || (this.cache[o] = new Di(this.context,t,ui[t],e,or[t],n)),
                this.cache[o]
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(),
                this.context.cullFace.setDefault(),
                this.context.frontFace.setDefault(),
                this.context.cullFaceSide.setDefault(),
                this.context.activeTexture.setDefault(),
                this.context.pixelStoreUnpack.setDefault(),
                this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                this.context.pixelStoreUnpackFlipY.setDefault()
            }
            setBaseState() {
                const t = this.context.gl;
                this.context.cullFace.set(!1),
                this.context.viewport.set([0, 0, this.width, this.height]),
                this.context.blendEquation.set(t.FUNC_ADD)
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"),
                this.debugOverlayCanvas.width = 512,
                this.debugOverlayCanvas.height = 512,
                this.debugOverlayTexture = new t.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
            }
            destroy() {
                this._terrain && this._terrain.destroy(),
                this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                this.emptyTexture.destroy(),
                this.debugOverlayTexture && this.debugOverlayTexture.destroy(),
                this.atmosphereBuffer && this.atmosphereBuffer.destroy()
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile()
            }
            prepareDrawProgram(e, i, r) {
                if (this.terrain && this.terrain.renderingToTexture)
                    return;
                const n = this.style.fog;
                if (n) {
                    const o = n.getOpacity(this.transform.pitch)
                      , s = ((e,i,r,n,o,s,a,l,c,u,h)=>{
                        const d = e.transform
                          , p = i.properties.get("color").toArray01();
                        p[3] = n;
                        const m = e.frameCounter / 1e3 % 1;
                        return {
                            u_fog_matrix: r ? d.calculateFogTileMatrix(r) : e.identityMat,
                            u_fog_range: i.getFovAdjustedRange(d._fov),
                            u_fog_color: p,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_temporal_offset: m,
                            u_frustum_tl: o,
                            u_frustum_tr: s,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: u,
                            u_viewport: h,
                            u_globe_transition: t.globeToMercatorTransition(d.zoom),
                            u_is_globe: +("globe" === d.projection.name)
                        }
                    }
                    )(this, n, r, o, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * t.exported.devicePixelRatio, this.transform.height * t.exported.devicePixelRatio]);
                    i.setFogUniformValues(e, s)
                }
            }
            setTileLoadedFlag(t) {
                this.tileLoaded = t
            }
            saveCanvasCopy() {
                this.frameCopies.push(this.canvasCopy()),
                this.tileLoaded = !1
            }
            canvasCopy() {
                const t = this.context.gl
                  , e = t.createTexture();
                return t.bindTexture(t.TEXTURE_2D, e),
                t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0),
                e
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                }
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation)
                    return !1;
                const t = this.style && this.style.fog;
                return !!t && 0 !== t.getOpacity(this.transform.pitch)
            }
            getBackgroundTiles() {
                const e = this._backgroundTiles
                  , i = this._backgroundTiles = {}
                  , r = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const n of r)
                    i[n.key] = e[n.key] || new t.Tile(n,512,this.transform.tileZoom,this);
                return i
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {}
            }
        }
        class Lr {
            constructor(t=0, e=0, i=0, r=0) {
                if (isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(r) || r < 0)
                    throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = t,
                this.bottom = e,
                this.left = i,
                this.right = r
            }
            interpolate(e, i, r) {
                return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, r)),
                null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, r)),
                null != i.left && null != e.left && (this.left = t.number(e.left, i.left, r)),
                null != i.right && null != e.right && (this.right = t.number(e.right, i.right, r)),
                this
            }
            getCenter(e, i) {
                const r = t.clamp((this.left + e - this.right) / 2, 0, e)
                  , n = t.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new t.pointGeometry(r,n)
            }
            equals(t) {
                return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right
            }
            clone() {
                return new Lr(this.top,this.bottom,this.left,this.right)
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                }
            }
        }
        function Or(e, i) {
            const r = t.getColumn(e, 3);
            t.fromQuat(e, i),
            t.setColumn(e, 3, r)
        }
        function Rr(e, i) {
            const r = t.identity$1([]);
            return t.rotateZ$1(r, r, -i),
            t.rotateX$1(r, r, -e),
            r
        }
        function Br(e, i) {
            const r = [e[0], e[1], 0]
              , n = [i[0], i[1], 0];
            if (t.length(r) >= 1e-15) {
                const e = t.normalize([], r);
                t.scale$2(n, e, t.dot(n, e)),
                i[0] = n[0],
                i[1] = n[1]
            }
            const o = t.cross([], i, e);
            if (t.len(o) < 1e-15)
                return null;
            const s = Math.atan2(-o[1], o[0]);
            return Rr(Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]), s)
        }
        class Fr {
            constructor(t, e) {
                this.position = t,
                this.orientation = e
            }
            get position() {
                return this._position
            }
            set position(e) {
                if (e) {
                    const i = e instanceof t.MercatorCoordinate ? e : new t.MercatorCoordinate(e[0],e[1],e[2]);
                    this._renderWorldCopies && (i.x = t.wrap(i.x, 0, 1)),
                    this._position = i
                } else
                    this._position = null
            }
            lookAtPoint(e, i) {
                if (this.orientation = null,
                !this.position)
                    return;
                const r = this._elevation ? this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(e)) : 0
                  , n = this.position
                  , o = t.MercatorCoordinate.fromLngLat(e, r)
                  , s = [o.x - n.x, o.y - n.y, o.z - n.z];
                i || (i = [0, 0, 1]),
                i[2] = Math.abs(i[2]),
                this.orientation = Br(s, i)
            }
            setPitchBearing(e, i) {
                this.orientation = Rr(t.degToRad(e), t.degToRad(-i))
            }
        }
        class Ur {
            constructor(e, i) {
                this._transform = t.identity([]),
                this.orientation = i,
                this.position = e
            }
            get mercatorPosition() {
                const e = this.position;
                return new t.MercatorCoordinate(e[0],e[1],e[2])
            }
            get position() {
                const e = t.getColumn(this._transform, 3);
                return [e[0], e[1], e[2]]
            }
            set position(e) {
                var i;
                e && t.setColumn(this._transform, 3, [(i = e)[0], i[1], i[2], 1])
            }
            get orientation() {
                return this._orientation
            }
            set orientation(e) {
                this._orientation = e || t.identity$1([]),
                e && Or(this._transform, this._orientation)
            }
            getPitchBearing() {
                const t = this.forward()
                  , e = this.right();
                return {
                    bearing: Math.atan2(-e[1], e[0]),
                    pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2])
                }
            }
            setPitchBearing(t, e) {
                this._orientation = Rr(t, e),
                Or(this._transform, this._orientation)
            }
            forward() {
                const e = t.getColumn(this._transform, 2);
                return [-e[0], -e[1], -e[2]]
            }
            up() {
                const e = t.getColumn(this._transform, 1);
                return [-e[0], -e[1], -e[2]]
            }
            right() {
                const e = t.getColumn(this._transform, 0);
                return [e[0], e[1], e[2]]
            }
            getCameraToWorld(e, i) {
                const r = new Float64Array(16);
                return t.invert(r, this.getWorldToCamera(e, i)),
                r
            }
            getWorldToCameraPosition(e, i, r) {
                const n = this.position;
                t.scale$2(n, n, -e);
                const o = new Float64Array(16);
                return t.fromScaling(o, [r, r, r]),
                t.translate(o, o, n),
                o[10] *= i,
                o
            }
            getWorldToCamera(e, i) {
                const r = new Float64Array(16)
                  , n = new Float64Array(4)
                  , o = this.position;
                return t.conjugate(n, this._orientation),
                t.scale$2(o, o, -e),
                t.fromQuat(r, n),
                t.translate(r, r, o),
                r[1] *= -1,
                r[5] *= -1,
                r[9] *= -1,
                r[13] *= -1,
                r[8] *= i,
                r[9] *= i,
                r[10] *= i,
                r[11] *= i,
                r
            }
            getCameraToClipPerspective(e, i, r, n) {
                const o = new Float64Array(16);
                return t.perspective(o, e, i, r, n),
                o
            }
            getDistanceToElevation(e, i=!1) {
                const r = 0 === e ? 0 : t.mercatorZfromAltitude(e, i ? t.latFromMercatorY(this.position[1]) : this.position[1])
                  , n = this.forward();
                return (r - this.position[2]) / n[2]
            }
            clone() {
                return new Ur([...this.position],[...this.orientation])
            }
        }
        function Nr(e, i) {
            const r = jr(e.projection, e.zoom, e.width, e.height)
              , n = function(e, i, r, n, o) {
                const s = new t.LngLat(r.lng - 180 * Vr,r.lat)
                  , a = new t.LngLat(r.lng + 180 * Vr,r.lat)
                  , l = e.project(s.lng, s.lat)
                  , c = e.project(a.lng, a.lat)
                  , u = -Math.atan2(c.y - l.y, c.x - l.x)
                  , h = t.MercatorCoordinate.fromLngLat(r);
                h.y = t.clamp(h.y, -.999975, .999975);
                const d = h.toLngLat()
                  , p = e.project(d.lng, d.lat)
                  , m = t.MercatorCoordinate.fromLngLat(d);
                m.x += Vr;
                const f = m.toLngLat()
                  , _ = e.project(f.lng, f.lat)
                  , g = Jr(_.x - p.x, _.y - p.y, u)
                  , y = t.MercatorCoordinate.fromLngLat(d);
                y.y += Vr;
                const x = y.toLngLat()
                  , v = e.project(x.lng, x.lat)
                  , b = Jr(v.x - p.x, v.y - p.y, u)
                  , w = Math.abs(g.x) / Math.abs(b.y)
                  , z = t.identity([]);
                t.rotateZ(z, z, -u * (1 - (o ? 0 : n)));
                const T = t.identity([]);
                return t.scale(T, T, [1, 1 - (1 - w) * n, 1]),
                T[4] = -b.x / b.y * n,
                t.rotateZ(T, T, u),
                t.multiply(T, z, T),
                T
            }(e.projection, 0, e.center, r, i)
              , o = Gr(e);
            return t.scale(n, n, [o, o, 1]),
            n
        }
        function Gr(e) {
            const i = e.projection
              , r = jr(e.projection, e.zoom, e.width, e.height)
              , n = Zr(i, e.center)
              , o = Zr(i, t.LngLat.convert(i.center));
            return Math.pow(2, n * r + (1 - r) * o)
        }
        function jr(e, i, r, n, o=1 / 0) {
            const s = e.range;
            if (!s)
                return 0;
            const a = Math.min(o, Math.max(r, n))
              , l = Math.log(a / 1024) / Math.LN2;
            return t.smoothstep(s[0] + l, s[1] + l, i)
        }
        const Vr = 1 / 4e4;
        function Zr(e, i) {
            const r = t.clamp(i.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
              , n = new t.LngLat(i.lng - 180 * Vr,r)
              , o = new t.LngLat(i.lng + 180 * Vr,r)
              , s = e.project(n.lng, r)
              , a = e.project(o.lng, r)
              , l = t.MercatorCoordinate.fromLngLat(n)
              , c = t.MercatorCoordinate.fromLngLat(o)
              , u = a.x - s.x
              , h = a.y - s.y
              , d = c.x - l.x
              , p = c.y - l.y
              , m = Math.sqrt((d * d + p * p) / (u * u + h * h));
            return Math.log(m) / Math.LN2
        }
        function Jr(t, e, i) {
            const r = Math.cos(i)
              , n = Math.sin(i);
            return {
                x: t * r - e * n,
                y: t * n + e * r
            }
        }
        class Xr {
            constructor(e, i, r, n, o, s, a) {
                this.tileSize = 512,
                this._renderWorldCopies = void 0 === o || o,
                this._minZoom = e || 0,
                this._maxZoom = i || 22,
                this._minPitch = null == r ? 0 : r,
                this._maxPitch = null == n ? 60 : n,
                this.setProjection(s),
                this.setMaxBounds(a),
                this.width = 0,
                this.height = 0,
                this._center = new t.LngLat(0,0),
                this.zoom = 0,
                this.angle = 0,
                this._fov = .6435011087932844,
                this._pitch = 0,
                this._nearZ = 0,
                this._farZ = 0,
                this._unmodified = !0,
                this._edgeInsets = new Lr,
                this._projMatrixCache = {},
                this._alignedProjMatrixCache = {},
                this._fogTileMatrixCache = {},
                this._distanceTileDataCache = {},
                this._camera = new Ur,
                this._centerAltitude = 0,
                this._averageElevation = 0,
                this.cameraElevationReference = "ground",
                this._pixelsPerMercatorPixel = 1,
                this.globeRadius = 0,
                this.globeCenterInViewSpace = [0, 0, 0],
                this._horizonShift = .1
            }
            clone() {
                const t = new Xr(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());
                return t._elevation = this._elevation,
                t._centerAltitude = this._centerAltitude,
                t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration,
                t.tileSize = this.tileSize,
                t.mercatorFromTransition = this.mercatorFromTransition,
                t.width = this.width,
                t.height = this.height,
                t.cameraElevationReference = this.cameraElevationReference,
                t._center = this._center,
                t._setZoom(this.zoom),
                t._seaLevelZoom = this._seaLevelZoom,
                t.angle = this.angle,
                t._fov = this._fov,
                t._pitch = this._pitch,
                t._nearZ = this._nearZ,
                t._farZ = this._farZ,
                t._averageElevation = this._averageElevation,
                t._unmodified = this._unmodified,
                t._edgeInsets = this._edgeInsets.clone(),
                t._camera = this._camera.clone(),
                t._calcMatrices(),
                t.freezeTileCoverage = this.freezeTileCoverage,
                t.frustumCorners = this.frustumCorners,
                t
            }
            get elevation() {
                return this._elevation
            }
            set elevation(t) {
                this._elevation !== t && (this._elevation = t,
                this._updateCameraOnTerrain(),
                this._calcMatrices())
            }
            updateElevation(t, e=!1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(),
                (t || i) && this._constrainCamera(e),
                this._calcMatrices()
            }
            getProjection() {
                return t.pick(this.projection, ["name", "center", "parallels"])
            }
            setProjection(i) {
                this.projectionOptions = i || {
                    name: "mercator"
                };
                const r = this.projection ? this.getProjection() : void 0;
                this.projection = t.getProjection(this.projectionOptions);
                const n = !e(r, this.getProjection());
                return n && this._calcMatrices(),
                this.mercatorFromTransition = !1,
                n
            }
            setMercatorFromTransition() {
                const e = this.projection.name;
                this.mercatorFromTransition = !0,
                this.projectionOptions = {
                    name: "mercator"
                },
                this.projection = t.getProjection({
                    name: "mercator"
                });
                const i = e !== this.projection.name;
                return i && this._calcMatrices(),
                i
            }
            get minZoom() {
                return this._minZoom
            }
            set minZoom(t) {
                this._minZoom !== t && (this._minZoom = t,
                this.zoom = Math.max(this.zoom, t))
            }
            get maxZoom() {
                return this._maxZoom
            }
            set maxZoom(t) {
                this._maxZoom !== t && (this._maxZoom = t,
                this.zoom = Math.min(this.zoom, t))
            }
            get minPitch() {
                return this._minPitch
            }
            set minPitch(t) {
                this._minPitch !== t && (this._minPitch = t,
                this.pitch = Math.max(this.pitch, t))
            }
            get maxPitch() {
                return this._maxPitch
            }
            set maxPitch(t) {
                this._maxPitch !== t && (this._maxPitch = t,
                this.pitch = Math.min(this.pitch, t))
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies
            }
            set renderWorldCopies(t) {
                void 0 === t ? t = !0 : null === t && (t = !1),
                this._renderWorldCopies = t
            }
            get worldSize() {
                return this.tileSize * this.scale
            }
            get cameraWorldSizeForFog() {
                const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
            }
            get cameraWorldSize() {
                const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
            }
            get cameraPixelsPerMeter() {
                return t.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog)
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2))
            }
            get size() {
                return new t.pointGeometry(this.width,this.height)
            }
            get bearing() {
                return t.wrap(this.rotation, -180, 180)
            }
            set bearing(t) {
                this.rotation = t
            }
            get rotation() {
                return -this.angle / Math.PI * 180
            }
            set rotation(e) {
                const i = -e * Math.PI / 180;
                var r, n, o, s, a, l, c, u, h, d;
                this.angle !== i && (this._unmodified = !1,
                this.angle = i,
                this._calcMatrices(),
                this.rotationMatrix = (r = new t.ARRAY_TYPE(4),
                t.ARRAY_TYPE != Float32Array && (r[1] = 0,
                r[2] = 0),
                r[0] = 1,
                r[3] = 1,
                r),
                n = this.rotationMatrix,
                o = this.rotationMatrix,
                s = this.angle,
                a = o[0],
                l = o[1],
                c = o[2],
                u = o[3],
                h = Math.sin(s),
                d = Math.cos(s),
                n[0] = a * d + c * h,
                n[1] = l * d + u * h,
                n[2] = a * -h + c * d,
                n[3] = l * -h + u * d)
            }
            get pitch() {
                return this._pitch / Math.PI * 180
            }
            set pitch(e) {
                const i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1,
                this._pitch = i,
                this._calcMatrices())
            }
            get aspect() {
                return this.width / this.height
            }
            get fovX() {
                return this._fov
            }
            get fovY() {
                const t = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / t)
            }
            set fov(e) {
                e = Math.max(.01, Math.min(60, e)),
                this._fov !== e && (this._unmodified = !1,
                this._fov = t.degToRad(e),
                this._calcMatrices())
            }
            get averageElevation() {
                return this._averageElevation
            }
            set averageElevation(t) {
                this._averageElevation = t,
                this._calcFogMatrices(),
                this._distanceTileDataCache = {}
            }
            get zoom() {
                return this._zoom
            }
            set zoom(t) {
                const e = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                this._zoom !== e && (this._unmodified = !1,
                this._setZoom(e),
                this._updateSeaLevelZoom(),
                this._constrain(),
                this._calcMatrices())
            }
            _setZoom(t) {
                this._zoom = t,
                this.scale = this.zoomScale(t),
                this.tileZoom = Math.floor(t),
                this.zoomFraction = t - this.tileZoom
            }
            _updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
                    return this._centerAltitude = 0,
                    this._seaLevelZoom = null,
                    void (this._centerAltitudeValidForExaggeration = void 0);
                const t = this._elevation;
                this._centerAltitude = t.getAtPointOrZero(this.locationCoordinate(this.center)),
                this._centerAltitudeValidForExaggeration = t.exaggeration(),
                this._updateSeaLevelZoom()
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize))
            }
            sampleAverageElevation() {
                if (!this._elevation)
                    return 0;
                const e = this._elevation
                  , i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]]
                  , r = this.horizonLineFromTop();
                let n = 0
                  , o = 0;
                for (let s = 0; s < i.length; s++) {
                    const a = new t.pointGeometry(i[s][0] * this.width,r + i[s][1] * (this.height - r))
                      , l = e.pointCoordinate(a);
                    if (!l)
                        continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    n += l[3] * c,
                    o += c
                }
                return 0 === o ? NaN : n / o
            }
            get center() {
                return this._center
            }
            set center(t) {
                t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1,
                this._center = t,
                this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()),
                this._constrain(),
                this._calcMatrices())
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation)
                    return;
                const t = this._seaLevelZoom
                  , e = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center))
                  , i = this.pixelsPerMeter / this.worldSize * e
                  , r = this._mercatorZfromZoom(t)
                  , n = this._mercatorZfromZoom(this._maxZoom)
                  , o = Math.max(r - i, n);
                this._setZoom(this._zoomFromMercatorZ(o))
            }
            get padding() {
                return this._edgeInsets.toJSON()
            }
            set padding(t) {
                this._edgeInsets.equals(t) || (this._unmodified = !1,
                this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                this._calcMatrices())
            }
            computeZoomRelativeTo(e) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e.toAltitude()));
                let r;
                r = e.z < this._camera.position[2] ? [i.x, i.y, i.z] : [e.x, e.y, e.z];
                const n = t.length(t.sub([], this._camera.position, r));
                return t.clamp(this._zoomFromMercatorZ(n), this._minZoom, this._maxZoom)
            }
            setFreeCameraOptions(e) {
                if (!this.height)
                    return;
                if (!e.position && !e.orientation)
                    return;
                this._updateCameraState();
                let i = !1;
                if (e.orientation && !t.exactEquals(e.orientation, this._camera.orientation) && (i = this._setCameraOrientation(e.orientation)),
                e.position) {
                    const r = [e.position.x, e.position.y, e.position.z];
                    t.exactEquals$1(r, this._camera.position) || (this._setCameraPosition(r),
                    i = !0)
                }
                i && (this._updateStateFromCamera(),
                this.recenterOnTerrain())
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const e = this._camera.position
                  , i = new Fr;
                return i.position = new t.MercatorCoordinate(e[0],e[1],e[2]),
                i.orientation = this._camera.orientation,
                i._elevation = this.elevation,
                i._renderWorldCopies = this.renderWorldCopies,
                i
            }
            _setCameraOrientation(e) {
                if (!t.length$1(e))
                    return !1;
                t.normalize$1(e, e);
                const i = t.transformQuat([], [0, 0, -1], e)
                  , r = t.transformQuat([], [0, -1, 0], e);
                if (r[2] < 0)
                    return !1;
                const n = Br(i, r);
                return !!n && (this._camera.orientation = n,
                !0)
            }
            _setCameraPosition(e) {
                const i = this.zoomScale(this.minZoom) * this.tileSize
                  , r = this.zoomScale(this.maxZoom) * this.tileSize
                  , n = this.cameraToCenterDistance;
                e[2] = t.clamp(e[2], n / r, n / i),
                this._camera.position = e
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height)
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height)
            }
            isPaddingEqual(t) {
                return this._edgeInsets.equals(t)
            }
            interpolatePadding(t, e, i) {
                this._unmodified = !1,
                this._edgeInsets.interpolate(t, e, i),
                this._constrain(),
                this._calcMatrices()
            }
            coveringZoomLevel(t) {
                const e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
                return Math.max(0, e)
            }
            getVisibleUnwrappedCoordinates(e) {
                const i = [new t.UnwrappedTileID(0,e)];
                if (this.renderWorldCopies) {
                    const r = this.pointCoordinate(new t.pointGeometry(0,0))
                      , n = this.pointCoordinate(new t.pointGeometry(this.width,0))
                      , o = this.pointCoordinate(new t.pointGeometry(this.width,this.height))
                      , s = this.pointCoordinate(new t.pointGeometry(0,this.height))
                      , a = Math.floor(Math.min(r.x, n.x, o.x, s.x))
                      , l = Math.floor(Math.max(r.x, n.x, o.x, s.x))
                      , c = 1;
                    for (let r = a - c; r <= l + c; r++)
                        0 !== r && i.push(new t.UnwrappedTileID(r,e))
                }
                return i
            }
            coveringTiles(e) {
                let i = this.coveringZoomLevel(e);
                const r = i
                  , n = this.elevation && !e.isTerrainDEM
                  , o = "mercator" === this.projection.name;
                if (void 0 !== e.minzoom && i < e.minzoom)
                    return [];
                void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);
                const s = this.locationCoordinate(this.center)
                  , a = this.center.lat
                  , l = 1 << i
                  , c = [l * s.x, l * s.y, 0]
                  , u = "globe" === this.projection.name
                  , h = !u
                  , d = t.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, h)
                  , p = u ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                  , m = l * t.mercatorZfromAltitude(1, this.center.lat)
                  , f = this._camera.position[2] / t.mercatorZfromAltitude(1, this.center.lat)
                  , _ = [l * p.x, l * p.y, f * (h ? 1 : m)]
                  , g = this.cameraToCenterDistance / e.tileSize * (e.roundZoom ? 1 : .502)
                  , y = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0
                  , x = e.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude
                  , v = e.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0
                  , b = this.projection.isReprojectedInTileSpace ? Gr(this) : 1
                  , w = e=>{
                    const i = 1 / 4e4
                      , r = new t.MercatorCoordinate(e.x + i,e.y,e.z)
                      , n = new t.MercatorCoordinate(e.x,e.y + i,e.z)
                      , o = e.toLngLat()
                      , s = r.toLngLat()
                      , a = n.toLngLat()
                      , l = this.locationCoordinate(o)
                      , c = this.locationCoordinate(s)
                      , u = this.locationCoordinate(a)
                      , h = Math.hypot(c.x - l.x, c.y - l.y)
                      , d = Math.hypot(u.x - l.x, u.y - l.y);
                    return Math.sqrt(h * d) * b / i
                }
                  , z = e=>{
                    const i = x
                      , r = v;
                    return {
                        aabb: t.tileAABB(this, l, 0, 0, 0, e, r, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: r,
                        maxZ: i,
                        wrap: e,
                        fullyVisible: !1
                    }
                }
                  , T = [];
                let E = [];
                const S = i
                  , M = e.reparseOverscaled ? r : i
                  , A = t=>t * t
                  , I = A((f - this._centerAltitude) * m)
                  , C = t=>{
                    if (!this._elevation || !t.tileID || !o)
                        return;
                    const e = this._elevation.getMinMaxForTile(t.tileID)
                      , i = t.aabb;
                    e ? (i.min[2] = e.min,
                    i.max[2] = e.max,
                    i.center[2] = (i.min[2] + i.max[2]) / 2) : (t.shouldSplit = D(t),
                    t.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude))
                }
                  , D = e=>{
                    if (e.zoom < y)
                        return !0;
                    if (e.zoom === S)
                        return !1;
                    if (null != e.shouldSplit)
                        return e.shouldSplit;
                    const i = e.aabb.distanceX(_)
                      , o = e.aabb.distanceY(_);
                    let s = I
                      , l = 1;
                    if (u) {
                        s = A(e.aabb.distanceZ(_));
                        const i = Math.pow(2, e.zoom)
                          , r = t.latFromMercatorY((e.y + 1) / i)
                          , n = t.latFromMercatorY(e.y / i)
                          , o = Math.min(Math.max(a, r), n)
                          , c = t.circumferenceAtLatitude(o) / t.circumferenceAtLatitude(a);
                        if (l = o === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio),
                        this.zoom <= t.GLOBE_ZOOM_THRESHOLD_MIN && e.zoom === S - 1 && c >= .9)
                            return !0
                    } else if (n && (s = A(e.aabb.distanceZ(_) * m)),
                    this.projection.isReprojectedInTileSpace && r <= 5) {
                        const i = Math.pow(2, e.zoom)
                          , r = w(new t.MercatorCoordinate((e.x + .5) / i,(e.y + .5) / i));
                        l = r > .85 ? 1 : r
                    }
                    const c = i * i + o * o + s;
                    return c < A((1 << S - e.zoom) * g * l * ((t,e)=>{
                        if (e * A(.707) < t)
                            return 1;
                        const i = Math.sqrt(e / t);
                        return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                    }
                    )(Math.max(s, I), c))
                }
                ;
                if (this.renderWorldCopies)
                    for (let t = 1; t <= 3; t++)
                        T.push(z(-t)),
                        T.push(z(t));
                for (T.push(z(0)); T.length > 0; ) {
                    const r = T.pop()
                      , s = r.x
                      , a = r.y;
                    let h = r.fullyVisible;
                    if (!h) {
                        const t = r.aabb.intersects(d);
                        if (0 === t)
                            continue;
                        h = 2 === t
                    }
                    if (r.zoom !== S && D(r))
                        for (let e = 0; e < 4; e++) {
                            const i = (s << 1) + e % 2
                              , c = (a << 1) + (e >> 1)
                              , d = {
                                aabb: o ? r.aabb.quadrant(e) : t.tileAABB(this, l, r.zoom + 1, i, c, r.wrap, r.minZ, r.maxZ, this.projection),
                                zoom: r.zoom + 1,
                                x: i,
                                y: c,
                                wrap: r.wrap,
                                fullyVisible: h,
                                tileID: void 0,
                                shouldSplit: void 0,
                                minZ: r.minZ,
                                maxZ: r.maxZ
                            };
                            n && !u && (d.tileID = new t.OverscaledTileID(r.zoom + 1 === S ? M : r.zoom + 1,r.wrap,r.zoom + 1,i,c),
                            C(d)),
                            T.push(d)
                        }
                    else {
                        const n = r.zoom === S ? M : r.zoom;
                        if (e.minzoom && e.minzoom > n)
                            continue;
                        const o = c[0] - (.5 + s + (r.wrap << r.zoom)) * (1 << i - r.zoom)
                          , l = c[1] - .5 - a
                          , u = r.tileID ? r.tileID : new t.OverscaledTileID(n,r.wrap,r.zoom,s,a);
                        E.push({
                            tileID: u,
                            distanceSq: o * o + l * l
                        })
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq
                      , r = this.horizonLineFromTop();
                    E = E.filter((n=>{
                        const o = [0, 0, 0, 1]
                          , s = [t.EXTENT, t.EXTENT, 0, 1]
                          , a = this.calculateFogTileMatrix(n.tileID.toUnwrapped());
                        t.transformMat4$1(o, o, a),
                        t.transformMat4$1(s, s, a);
                        const l = t.getAABBPointSquareDist(o, s);
                        if (0 === l)
                            return !0;
                        let c = !1;
                        const u = this._elevation;
                        if (u && l > i && 0 !== r) {
                            const i = this.calculateProjMatrix(n.tileID.toUnwrapped());
                            let o;
                            e.isTerrainDEM || (o = u.getMinMaxForTile(n.tileID)),
                            o || (o = {
                                min: v,
                                max: x
                            });
                            const s = t.furthestTileCorner(this.rotation)
                              , a = [s[0] * t.EXTENT, s[1] * t.EXTENT, o.max];
                            t.transformMat4(a, a, i),
                            c = (1 - a[1]) * this.height * .5 < r
                        }
                        return l < i || c
                    }
                    ))
                }
                return E.sort(((t,e)=>t.distanceSq - e.distanceSq)).map((t=>t.tileID))
            }
            resize(t, e) {
                this.width = t,
                this.height = e,
                this.pixelsToGLUnits = [2 / t, -2 / e],
                this._constrain(),
                this._calcMatrices()
            }
            get unmodified() {
                return this._unmodified
            }
            zoomScale(t) {
                return Math.pow(2, t)
            }
            scaleZoom(t) {
                return Math.log(t) / Math.LN2
            }
            project(e) {
                const i = t.clamp(e.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
                  , r = this.projection.project(e.lng, i);
                return new t.pointGeometry(r.x * this.worldSize,r.y * this.worldSize)
            }
            unproject(t) {
                return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize)
            }
            get point() {
                return this.project(this.center)
            }
            setLocationAtPoint(e, i) {
                let r, n;
                const o = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const t = this.worldSize;
                    r = (i.x - o.x) / t,
                    n = (i.y - o.y) / t
                } else {
                    const t = this.pointCoordinate(i)
                      , e = this.pointCoordinate(o);
                    r = t.x - e.x,
                    n = t.y - e.y
                }
                const s = this.locationCoordinate(e);
                this.setLocation(new t.MercatorCoordinate(s.x - r,s.y - n))
            }
            setLocation(t) {
                this.center = this.coordinateLocation(t),
                this.projection.wrap && (this.center = this.center.wrap())
            }
            locationPoint(t) {
                return this.projection.locationPoint(this, t)
            }
            locationPoint3D(t) {
                return this.projection.locationPoint(this, t, !0)
            }
            pointLocation(t) {
                return this.coordinateLocation(this.pointCoordinate(t))
            }
            pointLocation3D(t) {
                return this.coordinateLocation(this.pointCoordinate3D(t))
            }
            locationCoordinate(e, i) {
                const r = i ? t.mercatorZfromAltitude(i, e.lat) : void 0
                  , n = this.projection.project(e.lng, e.lat);
                return new t.MercatorCoordinate(n.x,n.y,r)
            }
            coordinateLocation(t) {
                return this.projection.unproject(t.x, t.y)
            }
            pointRayIntersection(e, i) {
                const r = null != i ? i : this._centerAltitude
                  , n = [e.x, e.y, 0, 1]
                  , o = [e.x, e.y, 1, 1];
                t.transformMat4$1(n, n, this.pixelMatrixInverse),
                t.transformMat4$1(o, o, this.pixelMatrixInverse);
                const s = o[3];
                t.scale$1(n, n, 1 / n[3]),
                t.scale$1(o, o, 1 / s);
                const a = n[2]
                  , l = o[2];
                return {
                    p0: n,
                    p1: o,
                    t: a === l ? 0 : (r - a) / (l - a)
                }
            }
            screenPointToMercatorRay(e) {
                const i = [e.x, e.y, 0, 1]
                  , r = [e.x, e.y, 1, 1];
                return t.transformMat4$1(i, i, this.pixelMatrixInverse),
                t.transformMat4$1(r, r, this.pixelMatrixInverse),
                t.scale$1(i, i, 1 / i[3]),
                t.scale$1(r, r, 1 / r[3]),
                i[2] = t.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize,
                r[2] = t.mercatorZfromAltitude(r[2], this._center.lat) * this.worldSize,
                t.scale$1(i, i, 1 / this.worldSize),
                t.scale$1(r, r, 1 / this.worldSize),
                new t.Ray([i[0], i[1], i[2]],t.normalize([], t.sub([], r, i)))
            }
            rayIntersectionCoordinate(e) {
                const {p0: i, p1: r, t: n} = e
                  , o = t.mercatorZfromAltitude(i[2], this._center.lat)
                  , s = t.mercatorZfromAltitude(r[2], this._center.lat);
                return new t.MercatorCoordinate(t.number(i[0], r[0], n) / this.worldSize,t.number(i[1], r[1], n) / this.worldSize,t.number(o, s, n))
            }
            pointCoordinate(t, e=this._centerAltitude) {
                return this.projection.pointCoordinate(this, t.x, t.y, e)
            }
            pointCoordinate3D(e) {
                if (!this.elevation)
                    return this.pointCoordinate(e);
                let i = this.projection.pointCoordinate3D(this, e.x, e.y);
                if (i)
                    return new t.MercatorCoordinate(i[0],i[1],i[2]);
                let r = 0
                  , n = this.horizonLineFromTop();
                if (e.y > n)
                    return this.pointCoordinate(e);
                const o = .02 * n
                  , s = e.clone();
                for (let e = 0; e < 10 && n - r > o; e++) {
                    s.y = t.number(r, n, .66);
                    const e = this.projection.pointCoordinate3D(this, s.x, s.y);
                    e ? (n = s.y,
                    i = e) : r = s.y
                }
                return i ? new t.MercatorCoordinate(i[0],i[1],i[2]) : this.pointCoordinate(e)
            }
            isPointAboveHorizon(t) {
                return this.projection.isPointAboveHorizon(this, t)
            }
            _coordinatePoint(e, i) {
                const r = i && this.elevation ? this.elevation.getAtPointOrZero(e, this._centerAltitude) : this._centerAltitude
                  , n = [e.x * this.worldSize, e.y * this.worldSize, r + e.toAltitude(), 1];
                return t.transformMat4$1(n, n, this.pixelMatrix),
                n[3] > 0 ? new t.pointGeometry(n[0] / n[3],n[1] / n[3]) : new t.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE)
            }
            _getGlobeBounds() {
                const {top: e, left: i} = this._edgeInsets
                  , r = this.height - this._edgeInsets.bottom
                  , n = this.width - this._edgeInsets.right
                  , o = this.pointCoordinate3D(new t.pointGeometry(i,e))
                  , s = this.pointCoordinate3D(new t.pointGeometry(n,e))
                  , a = this.pointCoordinate3D(new t.pointGeometry(n,r))
                  , l = this.pointCoordinate3D(new t.pointGeometry(i,r));
                let c = Math.min(o.x, l.x)
                  , u = Math.max(s.x, a.x)
                  , h = Math.min(o.y, s.y)
                  , d = Math.max(l.y, a.y);
                const p = Math.pow(2, -this.zoom) / 16
                  , m = (e,i,r,n)=>{
                    const o = (e + r) / 2
                      , s = (i + n) / 2
                      , a = new t.pointGeometry(o,s)
                      , l = this.pointCoordinate3D(a)
                      , f = Math.max(0, c - l.x, h - l.y, l.x - u, l.y - d);
                    c = Math.min(c, l.x),
                    u = Math.max(u, l.x),
                    h = Math.min(h, l.y),
                    d = Math.max(d, l.y),
                    f > p && (m(e, i, o, s),
                    m(o, s, r, n))
                }
                ;
                m(i, e, n, e),
                m(n, e, n, r),
                m(n, r, i, r),
                m(i, r, i, e);
                const [f,_] = t.polesInViewport(this)
                  , g = f || _
                  , y = f ? 90 : t.latFromMercatorY(h)
                  , x = g ? 180 : t.lngFromMercatorX(u)
                  , v = _ ? -90 : t.latFromMercatorY(d)
                  , b = g ? -180 : t.lngFromMercatorX(c);
                return new t.LngLatBounds(new t.LngLat(b,v),new t.LngLat(x,y))
            }
            _getBounds(e, i) {
                if ("globe" === this.projection.name)
                    return this._getGlobeBounds();
                const r = new t.pointGeometry(this._edgeInsets.left,this._edgeInsets.top)
                  , n = new t.pointGeometry(this.width - this._edgeInsets.right,this._edgeInsets.top)
                  , o = new t.pointGeometry(this.width - this._edgeInsets.right,this.height - this._edgeInsets.bottom)
                  , s = new t.pointGeometry(this._edgeInsets.left,this.height - this._edgeInsets.bottom);
                let a = this.pointCoordinate(r, e)
                  , l = this.pointCoordinate(n, e);
                const c = this.pointCoordinate(o, i)
                  , u = this.pointCoordinate(s, i)
                  , h = (t,e)=>(e.y - t.y) / (e.x - t.x);
                return a.y > 1 && l.y >= 0 ? a = new t.MercatorCoordinate((1 - u.y) / h(u, a) + u.x,1) : a.y < 0 && l.y <= 1 && (a = new t.MercatorCoordinate(-u.y / h(u, a) + u.x,0)),
                l.y > 1 && a.y >= 0 ? l = new t.MercatorCoordinate((1 - c.y) / h(c, l) + c.x,1) : l.y < 0 && a.y <= 1 && (l = new t.MercatorCoordinate(-c.y / h(c, l) + c.x,0)),
                (new t.LngLatBounds).extend(this.coordinateLocation(a)).extend(this.coordinateLocation(l)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(c))
            }
            _getBounds3D() {
                const t = this.elevation;
                if (!t.visibleDemTiles.length || t.isUsingMockSource())
                    return this._getBounds(0, 0);
                const e = t.visibleDemTiles.reduce(((t,e)=>{
                    if (e.dem) {
                        const i = e.dem.tree;
                        t.min = Math.min(t.min, i.minimums[0]),
                        t.max = Math.max(t.max, i.maximums[0])
                    }
                    return t
                }
                ), {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBounds(e.min * t.exaggeration(), e.max * t.exaggeration())
            }
            getBounds() {
                return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0)
            }
            horizonLineFromTop(t=!0) {
                const e = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y
                  , i = this.height / 2 - e * (1 - this._horizonShift);
                return t ? Math.max(0, i) : i
            }
            getMaxBounds() {
                return this.maxBounds
            }
            setMaxBounds(e) {
                this.maxBounds = e,
                this.minLat = -t.MAX_MERCATOR_LATITUDE,
                this.maxLat = t.MAX_MERCATOR_LATITUDE,
                this.minLng = -180,
                this.maxLng = 180,
                e && (this.minLat = e.getSouth(),
                this.maxLat = e.getNorth(),
                this.minLng = e.getWest(),
                this.maxLng = e.getEast(),
                this.maxLng < this.minLng && (this.maxLng += 360)),
                this.worldMinX = t.mercatorXfromLng(this.minLng) * this.tileSize,
                this.worldMaxX = t.mercatorXfromLng(this.maxLng) * this.tileSize,
                this.worldMinY = t.mercatorYfromLat(this.maxLat) * this.tileSize,
                this.worldMaxY = t.mercatorYfromLat(this.minLat) * this.tileSize,
                this._constrain()
            }
            calculatePosMatrix(t, e) {
                return this.projection.createTileMatrix(this, e, t)
            }
            calculateDistanceTileData(e) {
                const i = e.key
                  , r = this._distanceTileDataCache;
                if (r[i])
                    return r[i];
                const n = e.canonical
                  , o = 1 / this.height
                  , s = this.cameraWorldSize
                  , a = s / this.zoomScale(n.z)
                  , l = (n.x + Math.pow(2, n.z) * e.wrap) * a
                  , c = n.y * a
                  , u = this.point;
                u.x *= s / this.worldSize,
                u.y *= s / this.worldSize;
                const h = this.angle
                  , d = Math.sin(-h)
                  , p = -Math.cos(-h);
                return r[i] = {
                    bearing: [d, p],
                    center: [(u.x - l) * o, (u.y - c) * o],
                    scale: a / t.EXTENT * o
                },
                r[i]
            }
            calculateFogTileMatrix(e) {
                const i = e.key
                  , r = this._fogTileMatrixCache;
                if (r[i])
                    return r[i];
                const n = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, e);
                return t.multiply(n, this.worldToFogMatrix, n),
                r[i] = new Float32Array(n),
                r[i]
            }
            calculateProjMatrix(e, i=!1) {
                const r = e.key
                  , n = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (n[r])
                    return n[r];
                const o = this.calculatePosMatrix(e, this.worldSize);
                return t.multiply(o, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, o),
                n[r] = new Float32Array(o),
                n[r]
            }
            calculatePixelsToTileUnitsMatrix(e) {
                const i = e.tileID.key
                  , r = this._pixelsToTileUnitsCache;
                if (r[i])
                    return r[i];
                const n = function(e, i) {
                    const {scale: r} = e.tileTransform
                      , n = r * t.EXTENT / (e.tileSize * Math.pow(2, i.zoom - e.tileID.overscaledZ + e.tileID.canonical.z));
                    var o, s, a, l, c, u, h, d;
                    return o = new Float32Array(4),
                    l = (s = i.inverseAdjustmentMatrix)[1],
                    c = s[2],
                    u = s[3],
                    d = (a = [n, n])[1],
                    o[0] = s[0] * (h = a[0]),
                    o[1] = l * h,
                    o[2] = c * d,
                    o[3] = u * d,
                    o
                }(e, this);
                return r[i] = n,
                r[i]
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice()
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name)
                    return;
                const e = this._elevation;
                this._updateCameraState();
                const i = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                  , r = this._computeCameraPosition(i)
                  , n = this._camera.forward()
                  , o = t.mercatorZfromAltitude(1, this._center.lat);
                r[2] /= o,
                n[2] /= o,
                t.normalize(n, n);
                const s = e.raycast(r, n, e.exaggeration());
                if (s) {
                    const e = t.scaleAndAdd([], r, n, s)
                      , i = new t.MercatorCoordinate(e[0],e[1],t.mercatorZfromAltitude(e[2], t.latFromMercatorY(e[1])))
                      , a = (i.z + t.length([i.x - r[0], i.y - r[1], i.z - r[2] * o])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a),
                    this._centerAltitude = i.toAltitude(),
                    this._center = this.coordinateLocation(i),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices()
                }
            }
            _constrainCamera(e=!1) {
                if (!this._elevation)
                    return;
                const i = this._elevation
                  , r = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                  , n = this._computeCameraPosition(r)
                  , o = i.getAtPointOrZero(new t.MercatorCoordinate(...n))
                  , s = this.pixelsPerMeter / this.worldSize * o
                  , a = this._minimumHeightOverTerrain()
                  , l = n[2] - s;
                if (l <= a)
                    if (l < 0 || e) {
                        const e = this.locationCoordinate(this._center, this._centerAltitude)
                          , i = [n[0], n[1], e.z - n[2]]
                          , r = t.length(i);
                        i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                        const o = t.length(i);
                        if (0 === o)
                            return;
                        t.scale$2(i, i, r / o * this._pixelsPerMercatorPixel),
                        this._camera.position = [n[0], n[1], e.z * this._pixelsPerMercatorPixel - i[2]],
                        this._updateStateFromCamera()
                    } else
                        this._isCameraConstrained = !0
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining)
                    return;
                this._constraining = !0;
                const e = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || e) {
                    const i = this.center;
                    return i.lat = t.clamp(i.lat, this.minLat, this.maxLat),
                    (this.maxBounds || !this.renderWorldCopies && !e) && (i.lng = t.clamp(i.lng, this.minLng, this.maxLng)),
                    this.center = i,
                    void (this._constraining = !1)
                }
                const i = this._unmodified
                  , {x: r, y: n} = this.point;
                let o = 0
                  , s = r
                  , a = n;
                const l = this.width / 2
                  , c = this.height / 2
                  , u = this.worldMinY * this.scale
                  , h = this.worldMaxY * this.scale;
                if (n - c < u && (a = u + c),
                n + c > h && (a = h - c),
                h - u < this.height && (o = Math.max(o, this.height / (h - u)),
                a = (h + u) / 2),
                this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const t = this.worldMinX * this.scale
                      , e = this.worldMaxX * this.scale
                      , i = this.worldSize / 2 - (t + e) / 2;
                    s = (r + i + this.worldSize) % this.worldSize - i,
                    s - l < t && (s = t + l),
                    s + l > e && (s = e - l),
                    e - t < this.width && (o = Math.max(o, this.width / (e - t)),
                    s = (e + t) / 2)
                }
                s === r && a === n || (this.center = this.unproject(new t.pointGeometry(s,a))),
                o && (this.zoom += this.scaleZoom(o)),
                this._constrainCamera(),
                this._unmodified = i,
                this._constraining = !1
            }
            _minZoomForBounds() {
                let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))),
                t
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds())
            }
            _calcMatrices() {
                if (!this.height)
                    return;
                const e = this.centerOffset
                  , i = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = t.mercatorZfromAltitude(1, this.center.lat) / t.mercatorZfromAltitude(1, t.GLOBE_SCALE_MATCH_LATITUDE));
                const r = jr(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r),
                this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel,
                this._updateCameraState(),
                this._farZ = this.projection.farthestPixelDistance(this),
                this._nearZ = this.height / 50;
                const n = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? i : 1)
                  , o = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                o[8] = 2 * -e.x / this.width,
                o[9] = 2 * e.y / this.height;
                let s = t.mul([], o, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const e = this.locationCoordinate(this.center)
                      , i = t.identity([]);
                    t.translate(i, i, [e.x * this.worldSize, e.y * this.worldSize, 0]),
                    t.multiply(i, i, Nr(this)),
                    t.translate(i, i, [-e.x * this.worldSize, -e.y * this.worldSize, 0]),
                    t.multiply(s, s, i),
                    this.inverseAdjustmentMatrix = function(t) {
                        const e = Nr(t, !0);
                        return y([], [e[0], e[1], e[4], e[5]])
                    }(this)
                } else
                    this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                this.mercatorMatrix = t.scale([], s, [this.worldSize, this.worldSize, this.worldSize / i, 1]),
                this.projMatrix = s,
                this.invProjMatrix = t.invert(new Float64Array(16), this.projMatrix);
                const a = t.invert([], o);
                this.frustumCorners = t.FrustumCorners.fromInvProjectionMatrix(a, this.horizonLineFromTop(), this.height);
                const l = new Float32Array(16);
                t.identity(l),
                t.scale(l, l, [1, -1, 1]),
                t.rotateX(l, l, this._pitch),
                t.rotateZ(l, l, this.angle);
                const c = t.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ)
                  , u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                c[8] = 2 * -e.x / this.width,
                c[9] = 2 * (e.y + u) / this.height,
                this.skyboxMatrix = t.multiply(l, c, l);
                const h = this.point
                  , d = h.x
                  , p = h.y
                  , m = this.width % 2 / 2
                  , f = this.height % 2 / 2
                  , _ = Math.cos(this.angle)
                  , g = Math.sin(this.angle)
                  , x = d - Math.round(d) + _ * m + g * f
                  , v = p - Math.round(p) + _ * f + g * m
                  , b = new Float64Array(s);
                if (t.translate(b, b, [x > .5 ? x - 1 : x, v > .5 ? v - 1 : v, 0]),
                this.alignedProjMatrix = b,
                s = t.create(),
                t.scale(s, s, [this.width / 2, -this.height / 2, 1]),
                t.translate(s, s, [1, -1, 0]),
                this.labelPlaneMatrix = s,
                s = t.create(),
                t.scale(s, s, [1, -1, 1]),
                t.translate(s, s, [-1, -1, 0]),
                t.scale(s, s, [2 / this.width, 2 / this.height, 1]),
                this.glCoordMatrix = s,
                this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix),
                this._calcFogMatrices(),
                this._distanceTileDataCache = {},
                s = t.invert(new Float64Array(16), this.pixelMatrix),
                !s)
                    throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = s,
                "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = t.calculateGlobeMatrix(this);
                    const e = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                    this.globeCenterInViewSpace = t.transformMat4(e, e, n),
                    this.globeRadius = this.worldSize / 2 / Math.PI - 1
                } else
                    this.globeMatrix = s;
                this._projMatrixCache = {},
                this._alignedProjMatrixCache = {},
                this._pixelsToTileUnitsCache = {}
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const e = this.cameraWorldSizeForFog
                  , i = this.cameraPixelsPerMeter
                  , r = this._camera.position
                  , n = 1 / this.height / this._pixelsPerMercatorPixel
                  , o = [e, e, i];
                t.scale$2(o, o, n),
                t.scale$2(r, r, -1),
                t.multiply$2(r, r, o);
                const s = t.create();
                t.translate(s, s, r),
                t.scale(s, s, o),
                this.mercatorFogMatrix = s,
                this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e, i, n)
            }
            _computeCameraPosition(t) {
                const e = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter
                  , i = this._camera.forward()
                  , r = this.point
                  , n = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * e - t / this.worldSize * this._centerAltitude;
                return [r.x / this.worldSize - i[0] * n, r.y / this.worldSize - i[1] * n, t / this.worldSize * this._centerAltitude - i[2] * n]
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle),
                this._camera.position = this._computeCameraPosition())
            }
            _translateCameraConstrained(e) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch)
                  , r = this._camera.position[2]
                  , n = e[2];
                let o = 1;
                this.projection.wrap && (this.center = this.center.wrap()),
                n > 0 && (o = Math.min((i - r) / n, 1)),
                this._camera.position = t.scaleAndAdd([], this._camera.position, e, o),
                this._updateStateFromCamera()
            }
            _updateStateFromCamera() {
                const e = this._camera.position
                  , i = this._camera.forward()
                  , {pitch: r, bearing: n} = this._camera.getPitchBearing()
                  , o = t.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel
                  , s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(t.degToRad(this._maxPitch))
                  , a = Math.max((e[2] - o) / Math.cos(r), s)
                  , l = this._zoomFromMercatorZ(a);
                t.scaleAndAdd(e, e, i, a),
                this._pitch = t.clamp(r, t.degToRad(this.minPitch), t.degToRad(this.maxPitch)),
                this.angle = t.wrap(n, -Math.PI, Math.PI),
                this._setZoom(t.clamp(l, this._minZoom, this._maxZoom)),
                this._updateSeaLevelZoom(),
                this._center = this.coordinateLocation(new t.MercatorCoordinate(e[0],e[1],e[2])),
                this._unmodified = !1,
                this._constrain(),
                this._calcMatrices()
            }
            _worldSizeFromZoom(t) {
                return Math.pow(2, t) * this.tileSize
            }
            _mercatorZfromZoom(t) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(t)
            }
            _minimumHeightOverTerrain() {
                const t = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                return this._mercatorZfromZoom(t)
            }
            _zoomFromMercatorZ(t) {
                return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize))
            }
            zoomFromMercatorZAdjusted(t) {
                const e = e=>{
                    const i = this.getCameraToCenterDistance(this.projection, e);
                    return this.scaleZoom(i / (t * this.tileSize))
                }
                ;
                let i, r = e(this.zoom), n = Math.abs(r - e(r));
                for (; i !== n; )
                    r = e(r),
                    i = n,
                    n = Math.abs(r - e(r));
                return r
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (t.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),
                1))
            }
            anyCornerOffEdge(e, i) {
                const r = Math.min(e.x, i.x)
                  , n = Math.max(e.x, i.x)
                  , o = Math.min(e.y, i.y)
                  , s = Math.max(e.y, i.y);
                if (o < this.horizonLineFromTop(!1))
                    return !0;
                if ("mercator" !== this.projection.name)
                    return !1;
                const a = [new t.pointGeometry(r,o), new t.pointGeometry(n,s), new t.pointGeometry(r,s), new t.pointGeometry(n,o)]
                  , l = this.renderWorldCopies ? -3 : 0
                  , c = this.renderWorldCopies ? 4 : 1;
                for (const t of a) {
                    const e = this.pointRayIntersection(t);
                    if (e.t < 0)
                        return !0;
                    const i = this.rayIntersectionCoordinate(e);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1)
                        return !0
                }
                return !1
            }
            isHorizonVisible() {
                return this.pitch + t.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new t.pointGeometry(0,0), new t.pointGeometry(this.width,this.height))
            }
            zoomDeltaToMovement(e, i) {
                const r = t.length(t.sub([], this._camera.position, e))
                  , n = this._zoomFromMercatorZ(r) + i;
                return r - this._mercatorZfromZoom(n)
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const e = function([e,i,r], n) {
                        const o = [e, i, r, 1];
                        t.transformMat4$1(o, o, n);
                        const s = o[3] = Math.max(o[3], 1e-6);
                        return o[0] /= s,
                        o[1] /= s,
                        o[2] /= s,
                        o
                    }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                    return new t.pointGeometry(e[0],e[1])
                }
                {
                    const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new t.pointGeometry(0,e))
                }
            }
            getCameraToCenterDistance(t, e=this.zoom) {
                const i = jr(t, e, this.width, this.height, 1024)
                  , r = t.pixelSpaceConversion(this.center.lat, this.worldSize, i);
                return .5 / Math.tan(.5 * this._fov) * this.height * r
            }
            getWorldToCameraMatrix() {
                const e = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && t.multiply(e, e, this.globeMatrix),
                e
            }
        }
        function qr(t, e) {
            let i = !1
              , r = null;
            const n = ()=>{
                r = null,
                i && (t(),
                r = setTimeout(n, e),
                i = !1)
            }
            ;
            return ()=>(i = !0,
            r || n(),
            r)
        }
        class $r {
            constructor(e) {
                this._hashName = e && encodeURIComponent(e),
                t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                this._updateHash = qr(this._updateHashUnthrottled.bind(this), 300)
            }
            addTo(e) {
                return this._map = e,
                t.window.addEventListener("hashchange", this._onHashChange, !1),
                e.on("moveend", this._updateHash),
                this
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash),
                t.window.removeEventListener("hashchange", this._onHashChange, !1),
                clearTimeout(this._updateHash()),
                this._map = void 0,
                this) : this
            }
            getHashString() {
                const e = this._map;
                if (!e)
                    return "";
                const i = Yr(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let r = !1;
                    const n = t.window.location.hash.slice(1).split("&").map((t=>{
                        const n = t.split("=")[0];
                        return n === e ? (r = !0,
                        `${n}=${i}`) : t
                    }
                    )).filter((t=>t));
                    return r || n.push(`${e}=${i}`),
                    `#${n.join("&")}`
                }
                return `#${i}`
            }
            _getCurrentHash() {
                const e = t.window.location.hash.replace("#", "");
                if (this._hashName) {
                    let t;
                    return e.split("&").map((t=>t.split("="))).forEach((e=>{
                        e[0] === this._hashName && (t = e)
                    }
                    )),
                    (t && t[1] || "").split("/")
                }
                return e.split("/")
            }
            _onHashChange() {
                const t = this._map;
                if (!t)
                    return !1;
                const e = this._getCurrentHash();
                if (e.length >= 3 && !e.some((t=>isNaN(t)))) {
                    const i = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(e[3] || 0) : t.getBearing();
                    return t.jumpTo({
                        center: [+e[2], +e[1]],
                        zoom: +e[0],
                        bearing: i,
                        pitch: +(e[4] || 0)
                    }),
                    !0
                }
                return !1
            }
            _updateHashUnthrottled() {
                const e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
                t.window.history.replaceState(t.window.history.state, null, e)
            }
        }
        function Yr(t, e) {
            const i = t.getCenter()
              , r = Math.round(100 * t.getZoom()) / 100
              , n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
              , o = Math.pow(10, n)
              , s = Math.round(i.lng * o) / o
              , a = Math.round(i.lat * o) / o
              , l = t.getBearing()
              , c = t.getPitch();
            let u = e ? `/${s}/${a}/${r}` : `${r}/${a}/${s}`;
            return (l || c) && (u += "/" + Math.round(10 * l) / 10),
            c && (u += `/${Math.round(c)}`),
            u
        }
        const Wr = {
            linearity: .3,
            easing: t.bezier(0, 0, .3, 1)
        }
          , Hr = t.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, Wr)
          , Kr = t.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, Wr)
          , Qr = t.extend({
            deceleration: 1e3,
            maxSpeed: 360
        }, Wr)
          , tn = t.extend({
            deceleration: 1e3,
            maxSpeed: 90
        }, Wr);
        class en {
            constructor(t) {
                this._map = t,
                this.clear()
            }
            clear() {
                this._inertiaBuffer = []
            }
            record(e) {
                this._drainInertiaBuffer(),
                this._inertiaBuffer.push({
                    time: t.exported.now(),
                    settings: e
                })
            }
            _drainInertiaBuffer() {
                const e = this._inertiaBuffer
                  , i = t.exported.now();
                for (; e.length > 0 && i - e[0].time > 160; )
                    e.shift()
            }
            _onMoveEnd(e) {
                if (this._drainInertiaBuffer(),
                this._inertiaBuffer.length < 2)
                    return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new t.pointGeometry(0,0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const {settings: t} of this._inertiaBuffer)
                    i.zoom += t.zoomDelta || 0,
                    i.bearing += t.bearingDelta || 0,
                    i.pitch += t.pitchDelta || 0,
                    t.panDelta && i.pan._add(t.panDelta),
                    t.around && (i.around = t.around),
                    t.pinchAround && (i.pinchAround = t.pinchAround);
                const r = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                  , n = {};
                if (i.pan.mag()) {
                    const o = nn(i.pan.mag(), r, t.extend({}, Hr, e || {}));
                    n.offset = i.pan.mult(o.amount / i.pan.mag()),
                    n.center = this._map.transform.center,
                    rn(n, o)
                }
                if (i.zoom) {
                    const t = nn(i.zoom, r, Kr);
                    n.zoom = this._map.transform.zoom + t.amount,
                    rn(n, t)
                }
                if (i.bearing) {
                    const e = nn(i.bearing, r, Qr);
                    n.bearing = this._map.transform.bearing + t.clamp(e.amount, -179, 179),
                    rn(n, e)
                }
                if (i.pitch) {
                    const t = nn(i.pitch, r, tn);
                    n.pitch = this._map.transform.pitch + t.amount,
                    rn(n, t)
                }
                if (n.zoom || n.bearing) {
                    const t = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    n.around = t ? this._map.unproject(t) : this._map.getCenter()
                }
                return this.clear(),
                n.noMoveStart = !0,
                n
            }
        }
        function rn(t, e) {
            (!t.duration || t.duration < e.duration) && (t.duration = e.duration,
            t.easing = e.easing)
        }
        function nn(e, i, r) {
            const {maxSpeed: n, linearity: o, deceleration: s} = r
              , a = t.clamp(e * o / (i / 1e3), -n, n)
              , l = Math.abs(a) / (s * o);
            return {
                easing: r.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            }
        }
        class on extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(e, i, r, n={}) {
                const o = m(i.getCanvasContainer(), r)
                  , s = i.unproject(o);
                super(e, t.extend({
                    point: o,
                    lngLat: s,
                    originalEvent: r
                }, n)),
                this._defaultPrevented = !1,
                this.target = i
            }
        }
        class sn extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(e, i, r) {
                const n = "touchend" === e ? r.changedTouches : r.touches
                  , o = f(i.getCanvasContainer(), n)
                  , s = o.map((t=>i.unproject(t)))
                  , a = o.reduce(((t,e,i,r)=>t.add(e.div(r.length))), new t.pointGeometry(0,0));
                super(e, {
                    points: o,
                    point: a,
                    lngLats: s,
                    lngLat: i.unproject(a),
                    originalEvent: r
                }),
                this._defaultPrevented = !1
            }
        }
        class an extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(t, e, i) {
                super(t, {
                    originalEvent: i
                }),
                this._defaultPrevented = !1
            }
        }
        class ln {
            constructor(t, e) {
                this._map = t,
                this._clickTolerance = e.clickTolerance
            }
            reset() {
                this._mousedownPos = void 0
            }
            wheel(t) {
                return this._firePreventable(new an(t.type,this._map,t))
            }
            mousedown(t, e) {
                return this._mousedownPos = e,
                this._firePreventable(new on(t.type,this._map,t))
            }
            mouseup(t) {
                this._map.fire(new on(t.type,this._map,t))
            }
            preclick(e) {
                const i = t.extend({}, e);
                i.type = "preclick",
                this._map.fire(new on(i.type,this._map,i))
            }
            click(t, e) {
                this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || (this.preclick(t),
                this._map.fire(new on(t.type,this._map,t)))
            }
            dblclick(t) {
                return this._firePreventable(new on(t.type,this._map,t))
            }
            mouseover(t) {
                this._map.fire(new on(t.type,this._map,t))
            }
            mouseout(t) {
                this._map.fire(new on(t.type,this._map,t))
            }
            touchstart(t) {
                return this._firePreventable(new sn(t.type,this._map,t))
            }
            touchmove(t) {
                this._map.fire(new sn(t.type,this._map,t))
            }
            touchend(t) {
                this._map.fire(new sn(t.type,this._map,t))
            }
            touchcancel(t) {
                this._map.fire(new sn(t.type,this._map,t))
            }
            _firePreventable(t) {
                if (this._map.fire(t),
                t.defaultPrevented)
                    return {}
            }
            isEnabled() {
                return !0
            }
            isActive() {
                return !1
            }
            enable() {}
            disable() {}
        }
        class cn {
            constructor(t) {
                this._map = t
            }
            reset() {
                this._delayContextMenu = !1,
                this._contextMenuEvent = void 0
            }
            mousemove(t) {
                this._map.fire(new on(t.type,this._map,t))
            }
            mousedown() {
                this._delayContextMenu = !0
            }
            mouseup() {
                this._delayContextMenu = !1,
                this._contextMenuEvent && (this._map.fire(new on("contextmenu",this._map,this._contextMenuEvent)),
                delete this._contextMenuEvent)
            }
            contextmenu(t) {
                this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new on(t.type,this._map,t)),
                this._map.listens("contextmenu") && t.preventDefault()
            }
            isEnabled() {
                return !0
            }
            isActive() {
                return !1
            }
            enable() {}
            disable() {}
        }
        class un {
            constructor(t, e) {
                this._map = t,
                this._el = t.getCanvasContainer(),
                this._container = t.getContainer(),
                this._clickTolerance = e.clickTolerance || 1
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return !!this._active
            }
            enable() {
                this.isEnabled() || (this._enabled = !0)
            }
            disable() {
                this.isEnabled() && (this._enabled = !1)
            }
            mousedown(t, e) {
                this.isEnabled() && t.shiftKey && 0 === t.button && (u(),
                this._startPos = this._lastPos = e,
                this._active = !0)
            }
            mousemoveWindow(t, e) {
                if (!this._active)
                    return;
                const i = e
                  , r = this._startPos
                  , n = this._lastPos;
                if (!r || !n || n.equals(i) || !this._box && i.dist(r) < this._clickTolerance)
                    return;
                this._lastPos = i,
                this._box || (this._box = o("div", "mapboxgl-boxzoom", this._container),
                this._container.classList.add("mapboxgl-crosshair"),
                this._fireEvent("boxzoomstart", t));
                const s = Math.min(r.x, i.x)
                  , a = Math.max(r.x, i.x)
                  , l = Math.min(r.y, i.y)
                  , c = Math.max(r.y, i.y);
                this._map._requestDomTask((()=>{
                    this._box && (this._box.style.transform = `translate(${s}px,${l}px)`,
                    this._box.style.width = a - s + "px",
                    this._box.style.height = c - l + "px")
                }
                ))
            }
            mouseupWindow(e, i) {
                if (!this._active)
                    return;
                const r = this._startPos
                  , n = i;
                if (r && 0 === e.button) {
                    if (this.reset(),
                    p(),
                    r.x !== n.x || r.y !== n.y)
                        return this._map.fire(new t.Event("boxzoomend",{
                            originalEvent: e
                        })),
                        {
                            cameraAnimation: t=>t.fitScreenCoordinates(r, n, this._map.getBearing(), {
                                linear: !1
                            })
                        };
                    this._fireEvent("boxzoomcancel", e)
                }
            }
            keydown(t) {
                this._active && 27 === t.keyCode && (this.reset(),
                this._fireEvent("boxzoomcancel", t))
            }
            blur() {
                this.reset()
            }
            reset() {
                this._active = !1,
                this._container.classList.remove("mapboxgl-crosshair"),
                this._box && (this._box.remove(),
                this._box = null),
                h(),
                delete this._startPos,
                delete this._lastPos
            }
            _fireEvent(e, i) {
                return this._map.fire(new t.Event(e,{
                    originalEvent: i
                }))
            }
        }
        function hn(t, e) {
            const i = {};
            for (let r = 0; r < t.length; r++)
                i[t[r].identifier] = e[r];
            return i
        }
        class dn {
            constructor(t) {
                this.reset(),
                this.numTouches = t.numTouches
            }
            reset() {
                this.centroid = void 0,
                this.startTime = 0,
                this.touches = {},
                this.aborted = !1
            }
            touchstart(e, i, r) {
                (this.centroid || r.length > this.numTouches) && (this.aborted = !0),
                this.aborted || (0 === this.startTime && (this.startTime = e.timeStamp),
                r.length === this.numTouches && (this.centroid = function(e) {
                    const i = new t.pointGeometry(0,0);
                    for (const t of e)
                        i._add(t);
                    return i.div(e.length)
                }(i),
                this.touches = hn(r, i)))
            }
            touchmove(t, e, i) {
                if (this.aborted || !this.centroid)
                    return;
                const r = hn(i, e);
                for (const t in this.touches) {
                    const e = this.touches[t]
                      , i = r[t];
                    (!i || i.dist(e) > 30) && (this.aborted = !0)
                }
            }
            touchend(t, e, i) {
                if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0),
                0 === i.length) {
                    const t = !this.aborted && this.centroid;
                    if (this.reset(),
                    t)
                        return t
                }
            }
        }
        class pn {
            constructor(t) {
                this.singleTap = new dn(t),
                this.numTaps = t.numTaps,
                this.reset()
            }
            reset() {
                this.lastTime = 1 / 0,
                this.lastTap = void 0,
                this.count = 0,
                this.singleTap.reset()
            }
            touchstart(t, e, i) {
                this.singleTap.touchstart(t, e, i)
            }
            touchmove(t, e, i) {
                this.singleTap.touchmove(t, e, i)
            }
            touchend(t, e, i) {
                const r = this.singleTap.touchend(t, e, i);
                if (r) {
                    const e = t.timeStamp - this.lastTime < 500
                      , i = !this.lastTap || this.lastTap.dist(r) < 30;
                    if (e && i || this.reset(),
                    this.count++,
                    this.lastTime = t.timeStamp,
                    this.lastTap = r,
                    this.count === this.numTaps)
                        return this.reset(),
                        r
                }
            }
        }
        class mn {
            constructor() {
                this._zoomIn = new pn({
                    numTouches: 1,
                    numTaps: 2
                }),
                this._zoomOut = new pn({
                    numTouches: 2,
                    numTaps: 1
                }),
                this.reset()
            }
            reset() {
                this._active = !1,
                this._zoomIn.reset(),
                this._zoomOut.reset()
            }
            touchstart(t, e, i) {
                this._zoomIn.touchstart(t, e, i),
                this._zoomOut.touchstart(t, e, i)
            }
            touchmove(t, e, i) {
                this._zoomIn.touchmove(t, e, i),
                this._zoomOut.touchmove(t, e, i)
            }
            touchend(t, e, i) {
                const r = this._zoomIn.touchend(t, e, i)
                  , n = this._zoomOut.touchend(t, e, i);
                return r ? (this._active = !0,
                t.preventDefault(),
                setTimeout((()=>this.reset()), 0),
                {
                    cameraAnimation: e=>e.easeTo({
                        duration: 300,
                        zoom: e.getZoom() + 1,
                        around: e.unproject(r)
                    }, {
                        originalEvent: t
                    })
                }) : n ? (this._active = !0,
                t.preventDefault(),
                setTimeout((()=>this.reset()), 0),
                {
                    cameraAnimation: e=>e.easeTo({
                        duration: 300,
                        zoom: e.getZoom() - 1,
                        around: e.unproject(n)
                    }, {
                        originalEvent: t
                    })
                }) : void 0
            }
            touchcancel() {
                this.reset()
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        const fn = {
            0: 1,
            2: 2
        };
        class _n {
            constructor(t) {
                this.reset(),
                this._clickTolerance = t.clickTolerance || 1
            }
            blur() {
                this.reset()
            }
            reset() {
                this._active = !1,
                this._moved = !1,
                this._lastPoint = void 0,
                this._eventButton = void 0
            }
            _correctButton(t, e) {
                return !1
            }
            _move(t, e) {
                return {}
            }
            mousedown(t, e) {
                if (this._lastPoint)
                    return;
                const i = _(t);
                this._correctButton(t, i) && (this._lastPoint = e,
                this._eventButton = i)
            }
            mousemoveWindow(t, e) {
                const i = this._lastPoint;
                if (i)
                    if (t.preventDefault(),
                    null != this._eventButton && function(t, e) {
                        const i = fn[e];
                        return void 0 === t.buttons || (t.buttons & i) !== i
                    }(t, this._eventButton))
                        this.reset();
                    else if (this._moved || !(e.dist(i) < this._clickTolerance))
                        return this._moved = !0,
                        this._lastPoint = e,
                        this._move(i, e)
            }
            mouseupWindow(t) {
                this._lastPoint && _(t) === this._eventButton && (this._moved && p(),
                this.reset())
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class gn extends _n {
            mousedown(t, e) {
                super.mousedown(t, e),
                this._lastPoint && (this._active = !0)
            }
            _correctButton(t, e) {
                return 0 === e && !t.ctrlKey
            }
            _move(t, e) {
                return {
                    around: e,
                    panDelta: e.sub(t)
                }
            }
        }
        class yn extends _n {
            _correctButton(t, e) {
                return 0 === e && t.ctrlKey || 2 === e
            }
            _move(t, e) {
                const i = .8 * (e.x - t.x);
                if (i)
                    return this._active = !0,
                    {
                        bearingDelta: i
                    }
            }
            contextmenu(t) {
                t.preventDefault()
            }
        }
        class xn extends _n {
            _correctButton(t, e) {
                return 0 === e && t.ctrlKey || 2 === e
            }
            _move(t, e) {
                const i = -.5 * (e.y - t.y);
                if (i)
                    return this._active = !0,
                    {
                        pitchDelta: i
                    }
            }
            contextmenu(t) {
                t.preventDefault()
            }
        }
        class vn {
            constructor(e, i) {
                this._map = e,
                this._el = e.getCanvasContainer(),
                this._minTouches = 1,
                this._clickTolerance = i.clickTolerance || 1,
                this.reset(),
                t.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
            }
            reset() {
                this._active = !1,
                this._touches = {},
                this._sum = new t.pointGeometry(0,0)
            }
            touchstart(t, e, i) {
                return this._calculateTransform(t, e, i)
            }
            touchmove(e, i, r) {
                if (this._active && !(r.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === r.length && !t.isFullscreen())
                            return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                        clearTimeout(this._alertTimer))
                    }
                    return e.cancelable && e.preventDefault(),
                    this._calculateTransform(e, i, r)
                }
            }
            touchend(t, e, i) {
                this._calculateTransform(t, e, i),
                this._active && i.length < this._minTouches && this.reset()
            }
            touchcancel() {
                this.reset()
            }
            _calculateTransform(e, i, r) {
                r.length > 0 && (this._active = !0);
                const n = hn(r, i)
                  , o = new t.pointGeometry(0,0)
                  , s = new t.pointGeometry(0,0);
                let a = 0;
                for (const t in n) {
                    const e = n[t]
                      , i = this._touches[t];
                    i && (o._add(e),
                    s._add(e.sub(i)),
                    a++,
                    n[t] = e)
                }
                if (this._touches = n,
                a < this._minTouches || !s.mag())
                    return;
                const l = s.div(a);
                return this._sum._add(l),
                this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: o.div(a),
                    panDelta: l
                }
            }
            enable() {
                this._enabled = !0,
                this._map._cooperativeGestures && (this._addTouchPanBlocker(),
                this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
            }
            disable() {
                this._enabled = !1,
                this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                this._alertContainer.remove(),
                this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")),
                this.reset()
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return !!this._active
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = o("div", "mapboxgl-touch-pan-blocker", this._map._container),
                this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"),
                this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible",
                this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),
                this._alertContainer.setAttribute("role", "alert"),
                clearTimeout(this._alertTimer),
                this._alertTimer = setTimeout((()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),
                    this._alertContainer.setAttribute("role", "null")
                }
                ), 500)
            }
        }
        class bn {
            constructor() {
                this.reset()
            }
            reset() {
                this._active = !1,
                this._firstTwoTouches = void 0
            }
            _start(t) {}
            _move(t, e, i) {
                return {}
            }
            touchstart(t, e, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier],
                this._start([e[0], e[1]]))
            }
            touchmove(t, e, i) {
                const r = this._firstTwoTouches;
                if (!r)
                    return;
                t.preventDefault();
                const [n,o] = r
                  , s = wn(i, e, n)
                  , a = wn(i, e, o);
                if (!s || !a)
                    return;
                const l = this._aroundCenter ? null : s.add(a).div(2);
                return this._move([s, a], l, t)
            }
            touchend(t, e, i) {
                if (!this._firstTwoTouches)
                    return;
                const [r,n] = this._firstTwoTouches
                  , o = wn(i, e, r)
                  , s = wn(i, e, n);
                o && s || (this._active && p(),
                this.reset())
            }
            touchcancel() {
                this.reset()
            }
            enable(t) {
                this._enabled = !0,
                this._aroundCenter = !!t && "center" === t.around
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        function wn(t, e, i) {
            for (let r = 0; r < t.length; r++)
                if (t[r].identifier === i)
                    return e[r]
        }
        function zn(t, e) {
            return Math.log(t / e) / Math.LN2
        }
        class Tn extends bn {
            reset() {
                super.reset(),
                this._distance = 0,
                this._startDistance = 0
            }
            _start(t) {
                this._startDistance = this._distance = t[0].dist(t[1])
            }
            _move(t, e) {
                const i = this._distance;
                if (this._distance = t[0].dist(t[1]),
                this._active || !(Math.abs(zn(this._distance, this._startDistance)) < .1))
                    return this._active = !0,
                    {
                        zoomDelta: zn(this._distance, i),
                        pinchAround: e
                    }
            }
        }
        function En(t, e) {
            return 180 * t.angleWith(e) / Math.PI
        }
        class Sn extends bn {
            reset() {
                super.reset(),
                this._minDiameter = 0,
                this._startVector = void 0,
                this._vector = void 0
            }
            _start(t) {
                this._startVector = this._vector = t[0].sub(t[1]),
                this._minDiameter = t[0].dist(t[1])
            }
            _move(t, e) {
                const i = this._vector;
                if (this._vector = t[0].sub(t[1]),
                i && (this._active || !this._isBelowThreshold(this._vector)))
                    return this._active = !0,
                    {
                        bearingDelta: En(this._vector, i),
                        pinchAround: e
                    }
            }
            _isBelowThreshold(t) {
                this._minDiameter = Math.min(this._minDiameter, t.mag());
                const e = 25 / (Math.PI * this._minDiameter) * 360
                  , i = this._startVector;
                if (!i)
                    return !1;
                const r = En(t, i);
                return Math.abs(r) < e
            }
        }
        function Mn(t) {
            return Math.abs(t.y) > Math.abs(t.x)
        }
        class An extends bn {
            constructor(t) {
                super(),
                this._map = t
            }
            reset() {
                super.reset(),
                this._valid = void 0,
                this._firstMove = void 0,
                this._lastPoints = void 0
            }
            _start(t) {
                this._lastPoints = t,
                Mn(t[0].sub(t[1])) && (this._valid = !1)
            }
            _move(e, i, r) {
                const n = this._lastPoints;
                if (!n)
                    return;
                const o = e[0].sub(n[0])
                  , s = e[1].sub(n[1]);
                return this._map._cooperativeGestures && !t.isFullscreen() && r.touches.length < 3 || (this._valid = this.gestureBeginsVertically(o, s, r.timeStamp),
                !this._valid) ? void 0 : (this._lastPoints = e,
                this._active = !0,
                {
                    pitchDelta: (o.y + s.y) / 2 * -.5
                })
            }
            gestureBeginsVertically(t, e, i) {
                if (void 0 !== this._valid)
                    return this._valid;
                const r = t.mag() >= 2
                  , n = e.mag() >= 2;
                if (!r && !n)
                    return;
                if (!r || !n)
                    return null == this._firstMove && (this._firstMove = i),
                    i - this._firstMove < 100 && void 0;
                const o = t.y > 0 == e.y > 0;
                return Mn(t) && Mn(e) && o
            }
        }
        const In = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class Cn {
            constructor() {
                const t = In;
                this._panStep = t.panStep,
                this._bearingStep = t.bearingStep,
                this._pitchStep = t.pitchStep,
                this._rotationDisabled = !1
            }
            blur() {
                this.reset()
            }
            reset() {
                this._active = !1
            }
            keydown(t) {
                if (t.altKey || t.ctrlKey || t.metaKey)
                    return;
                let e = 0
                  , i = 0
                  , r = 0
                  , n = 0
                  , o = 0;
                switch (t.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                    e = 1;
                    break;
                case 189:
                case 109:
                case 173:
                    e = -1;
                    break;
                case 37:
                    t.shiftKey ? i = -1 : (t.preventDefault(),
                    n = -1);
                    break;
                case 39:
                    t.shiftKey ? i = 1 : (t.preventDefault(),
                    n = 1);
                    break;
                case 38:
                    t.shiftKey ? r = 1 : (t.preventDefault(),
                    o = -1);
                    break;
                case 40:
                    t.shiftKey ? r = -1 : (t.preventDefault(),
                    o = 1);
                    break;
                default:
                    return
                }
                return this._rotationDisabled && (i = 0,
                r = 0),
                {
                    cameraAnimation: s=>{
                        const a = s.getZoom();
                        s.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: Dn,
                            zoom: e ? Math.round(a) + e * (t.shiftKey ? 2 : 1) : a,
                            bearing: s.getBearing() + i * this._bearingStep,
                            pitch: s.getPitch() + r * this._pitchStep,
                            offset: [-n * this._panStep, -o * this._panStep],
                            center: s.getCenter()
                        }, {
                            originalEvent: t
                        })
                    }
                }
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
            disableRotation() {
                this._rotationDisabled = !0
            }
            enableRotation() {
                this._rotationDisabled = !1
            }
        }
        function Dn(t) {
            return t * (2 - t)
        }
        const kn = 4.000244140625;
        class Pn {
            constructor(e, i) {
                this._map = e,
                this._el = e.getCanvasContainer(),
                this._handler = i,
                this._delta = 0,
                this._defaultZoomRate = .01,
                this._wheelZoomRate = .0022222222222222222,
                t.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this)
            }
            setZoomRate(t) {
                this._defaultZoomRate = t
            }
            setWheelZoomRate(t) {
                this._wheelZoomRate = t
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout
            }
            isZooming() {
                return !!this._zooming
            }
            enable(t) {
                this.isEnabled() || (this._enabled = !0,
                this._aroundCenter = !!t && "center" === t.around,
                this._map._cooperativeGestures && this._addScrollZoomBlocker())
            }
            disable() {
                this.isEnabled() && (this._enabled = !1,
                this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                this._alertContainer.remove()))
            }
            wheel(e) {
                if (!this.isEnabled())
                    return;
                if (this._map._cooperativeGestures) {
                    if (!(e.ctrlKey || e.metaKey || this.isZooming() || t.isFullscreen()))
                        return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                    clearTimeout(this._alertTimer))
                }
                let i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                const r = t.exported.now()
                  , n = r - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = r,
                0 !== i && i % kn == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : n > 400 ? (this._type = null,
                this._lastValue = i,
                this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(n * i) < 200 ? "trackpad" : "wheel",
                this._timeout && (clearTimeout(this._timeout),
                this._timeout = null,
                i += this._lastValue)),
                e.shiftKey && i && (i /= 4),
                this._type && (this._lastWheelEvent = e,
                this._delta -= i,
                this._active || this._start(e)),
                e.preventDefault()
            }
            _onTimeout(t) {
                this._type = "wheel",
                this._delta -= this._lastValue,
                this._active || this._start(t)
            }
            _start(t) {
                if (!this._delta)
                    return;
                this._frameId && (this._frameId = null),
                this._active = !0,
                this.isZooming() || (this._zooming = !0),
                this._finishTimeout && (clearTimeout(this._finishTimeout),
                delete this._finishTimeout);
                const e = m(this._el, t);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : e,
                this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint),
                this._targetZoom = void 0,
                this._frameId || (this._frameId = !0,
                this._handler._triggerRenderFrame())
            }
            renderFrame() {
                if (!this._frameId)
                    return;
                if (this._frameId = null,
                !this.isActive())
                    return;
                const e = this._map.transform;
                "wheel" === this._type && e.projection.wrap && (e._center.lng >= 180 || e._center.lng <= -180) && (this._prevEase = null,
                this._easing = null,
                this._lastWheelEvent = null,
                this._lastWheelEventTime = 0);
                const i = ()=>e._terrainEnabled() && this._aroundCoord ? e.computeZoomRelativeTo(this._aroundCoord) : e.zoom;
                if (0 !== this._delta) {
                    const t = "wheel" === this._type && Math.abs(this._delta) > kn ? this._wheelZoomRate : this._defaultZoomRate;
                    let r = 2 / (1 + Math.exp(-Math.abs(this._delta * t)));
                    this._delta < 0 && 0 !== r && (r = 1 / r);
                    const n = i()
                      , o = Math.pow(2, n)
                      , s = "number" == typeof this._targetZoom ? e.zoomScale(this._targetZoom) : o;
                    this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(s * r))),
                    "wheel" === this._type && (this._startZoom = n,
                    this._easing = this._smoothOutEasing(200)),
                    this._delta = 0
                }
                const r = "number" == typeof this._targetZoom ? this._targetZoom : i()
                  , n = this._startZoom
                  , o = this._easing;
                let s, a = !1;
                if ("wheel" === this._type && n && o) {
                    const e = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1)
                      , i = o(e);
                    s = t.number(n, r, i),
                    e < 1 ? this._frameId || (this._frameId = !0) : a = !0
                } else
                    s = r,
                    a = !0;
                return this._active = !0,
                a && (this._active = !1,
                this._finishTimeout = setTimeout((()=>{
                    this._zooming = !1,
                    this._handler._triggerRenderFrame(),
                    delete this._targetZoom,
                    delete this._finishTimeout
                }
                ), 200)),
                {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: s - i(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                }
            }
            _smoothOutEasing(e) {
                let i = t.ease;
                if (this._prevEase) {
                    const e = this._prevEase
                      , r = (t.exported.now() - e.start) / e.duration
                      , n = e.easing(r + .01) - e.easing(r)
                      , o = .27 / Math.sqrt(n * n + 1e-4) * .01
                      , s = Math.sqrt(.0729 - o * o);
                    i = t.bezier(o, s, .25, 1)
                }
                return this._prevEase = {
                    start: t.exported.now(),
                    duration: e,
                    easing: i
                },
                i
            }
            blur() {
                this.reset()
            }
            reset() {
                this._active = !1
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = o("div", "mapboxgl-scroll-zoom-blocker", this._map._container),
                this._alertContainer.textContent = /(Mac|iPad)/i.test(t.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),
                this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible",
                this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),
                this._alertContainer.setAttribute("role", "alert"),
                clearTimeout(this._alertTimer),
                this._alertTimer = setTimeout((()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),
                    this._alertContainer.setAttribute("role", "null")
                }
                ), 200)
            }
        }
        class Ln {
            constructor(t, e) {
                this._clickZoom = t,
                this._tapZoom = e
            }
            enable() {
                this._clickZoom.enable(),
                this._tapZoom.enable()
            }
            disable() {
                this._clickZoom.disable(),
                this._tapZoom.disable()
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive()
            }
        }
        class On {
            constructor() {
                this.reset()
            }
            reset() {
                this._active = !1
            }
            blur() {
                this.reset()
            }
            dblclick(t, e) {
                return t.preventDefault(),
                {
                    cameraAnimation: i=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (t.shiftKey ? -1 : 1),
                            around: i.unproject(e)
                        }, {
                            originalEvent: t
                        })
                    }
                }
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class Rn {
            constructor() {
                this._tap = new pn({
                    numTouches: 1,
                    numTaps: 1
                }),
                this.reset()
            }
            reset() {
                this._active = !1,
                this._swipePoint = void 0,
                this._swipeTouch = 0,
                this._tapTime = 0,
                this._tap.reset()
            }
            touchstart(t, e, i) {
                this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(),
                this._tapTime ? i.length > 0 && (this._swipePoint = e[0],
                this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i))
            }
            touchmove(t, e, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch)
                            return;
                        const r = e[0]
                          , n = r.y - this._swipePoint.y;
                        return this._swipePoint = r,
                        t.preventDefault(),
                        this._active = !0,
                        {
                            zoomDelta: n / 128
                        }
                    }
                } else
                    this._tap.touchmove(t, e, i)
            }
            touchend(t, e, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp)
            }
            touchcancel() {
                this.reset()
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this.reset()
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class Bn {
            constructor(t, e, i) {
                this._el = t,
                this._mousePan = e,
                this._touchPan = i
            }
            enable(t) {
                this._inertiaOptions = t || {},
                this._mousePan.enable(),
                this._touchPan.enable(),
                this._el.classList.add("mapboxgl-touch-drag-pan")
            }
            disable() {
                this._mousePan.disable(),
                this._touchPan.disable(),
                this._el.classList.remove("mapboxgl-touch-drag-pan")
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled()
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive()
            }
        }
        class Fn {
            constructor(t, e, i) {
                this._pitchWithRotate = t.pitchWithRotate,
                this._mouseRotate = e,
                this._mousePitch = i
            }
            enable() {
                this._mouseRotate.enable(),
                this._pitchWithRotate && this._mousePitch.enable()
            }
            disable() {
                this._mouseRotate.disable(),
                this._mousePitch.disable()
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive()
            }
        }
        class Un {
            constructor(t, e, i, r) {
                this._el = t,
                this._touchZoom = e,
                this._touchRotate = i,
                this._tapDragZoom = r,
                this._rotationDisabled = !1,
                this._enabled = !0
            }
            enable(t) {
                this._touchZoom.enable(t),
                this._rotationDisabled || this._touchRotate.enable(t),
                this._tapDragZoom.enable(),
                this._el.classList.add("mapboxgl-touch-zoom-rotate")
            }
            disable() {
                this._touchZoom.disable(),
                this._touchRotate.disable(),
                this._tapDragZoom.disable(),
                this._el.classList.remove("mapboxgl-touch-zoom-rotate")
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
            }
            disableRotation() {
                this._rotationDisabled = !0,
                this._touchRotate.disable()
            }
            enableRotation() {
                this._rotationDisabled = !1,
                this._touchZoom.isEnabled() && this._touchRotate.enable()
            }
        }
        const Nn = t=>t.zoom || t.drag || t.pitch || t.rotate;
        class Gn extends t.Event {
        }
        class jn {
            constructor() {
                this.constants = [1, 1, .01],
                this.radius = 0
            }
            setup(e, i) {
                const r = t.sub([], i, e);
                this.radius = t.length(r[2] < 0 ? t.div([], r, this.constants) : [r[0], r[1], 0])
            }
            projectRay(e) {
                t.div(e, e, this.constants),
                t.normalize(e, e),
                t.mul$1(e, e, this.constants);
                const i = t.scale$2([], e, this.radius);
                if (i[2] > 0) {
                    const e = t.scale$2([], [0, 0, 1], t.dot(i, [0, 0, 1]))
                      , r = t.scale$2([], t.normalize([], [i[0], i[1], 0]), this.radius)
                      , n = t.add([], i, t.scale$2([], t.sub([], t.add([], r, e), i), 2));
                    i[0] = n[0],
                    i[1] = n[1]
                }
                return i
            }
        }
        function Vn(t) {
            return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta
        }
        class Zn {
            constructor(e, i) {
                this._map = e,
                this._el = this._map.getCanvasContainer(),
                this._handlers = [],
                this._handlersById = {},
                this._changes = [],
                this._inertia = new en(e),
                this._bearingSnap = i.bearingSnap,
                this._previousActiveHandlers = {},
                this._trackingEllipsoid = new jn,
                this._dragOrigin = null,
                this._eventsInProgress = {},
                this._addDefaultHandlers(i),
                t.bindAll(["handleEvent", "handleWindowEvent"], this);
                const r = this._el;
                this._listeners = [[r, "touchstart", {
                    passive: !0
                }], [r, "touchmove", {
                    passive: !1
                }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [t.window.document, "mousemove", {
                    capture: !0
                }], [t.window.document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", {
                    capture: !1
                }], [r, "keyup", void 0], [r, "wheel", {
                    passive: !1
                }], [r, "contextmenu", void 0], [t.window, "blur", void 0]];
                for (const [e,i,r] of this._listeners)
                    e.addEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, r)
            }
            destroy() {
                for (const [e,i,r] of this._listeners)
                    e.removeEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, r)
            }
            _addDefaultHandlers(t) {
                const e = this._map
                  , i = e.getCanvasContainer();
                this._add("mapEvent", new ln(e,t));
                const r = e.boxZoom = new un(e,t);
                this._add("boxZoom", r);
                const n = new mn
                  , o = new On;
                e.doubleClickZoom = new Ln(o,n),
                this._add("tapZoom", n),
                this._add("clickZoom", o);
                const s = new Rn;
                this._add("tapDragZoom", s);
                const a = e.touchPitch = new An(e);
                this._add("touchPitch", a);
                const l = new yn(t)
                  , c = new xn(t);
                e.dragRotate = new Fn(t,l,c),
                this._add("mouseRotate", l, ["mousePitch"]),
                this._add("mousePitch", c, ["mouseRotate"]);
                const u = new gn(t)
                  , h = new vn(e,t);
                e.dragPan = new Bn(i,u,h),
                this._add("mousePan", u),
                this._add("touchPan", h, ["touchZoom", "touchRotate"]);
                const d = new Sn
                  , p = new Tn;
                e.touchZoomRotate = new Un(i,p,d,s),
                this._add("touchRotate", d, ["touchPan", "touchZoom"]),
                this._add("touchZoom", p, ["touchPan", "touchRotate"]),
                this._add("blockableMapEvent", new cn(e));
                const m = e.scrollZoom = new Pn(e,this);
                this._add("scrollZoom", m, ["mousePan"]);
                const f = e.keyboard = new Cn;
                this._add("keyboard", f);
                for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                    t.interactive && t[i] && e[i].enable(t[i])
            }
            _add(t, e, i) {
                this._handlers.push({
                    handlerName: t,
                    handler: e,
                    allowed: i
                }),
                this._handlersById[t] = e
            }
            stop(t) {
                if (!this._updatingCamera) {
                    for (const {handler: t} of this._handlers)
                        t.reset();
                    this._inertia.clear(),
                    this._fireEvents({}, {}, t),
                    this._changes = []
                }
            }
            isActive() {
                for (const {handler: t} of this._handlers)
                    if (t.isActive())
                        return !0;
                return !1
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
            }
            isRotating() {
                return !!this._eventsInProgress.rotate
            }
            isMoving() {
                return !!Nn(this._eventsInProgress) || this.isZooming()
            }
            _isDragging() {
                return !!this._eventsInProgress.drag
            }
            _blockedByActive(t, e, i) {
                for (const r in t)
                    if (r !== i && (!e || e.indexOf(r) < 0))
                        return !0;
                return !1
            }
            handleWindowEvent(t) {
                this.handleEvent(t, `${t.type}Window`)
            }
            _getMapTouches(t) {
                const e = [];
                for (const i of t)
                    this._el.contains(i.target) && e.push(i);
                return e
            }
            handleEvent(t, e) {
                this._updatingCamera = !0;
                const i = "renderFrame" === t.type
                  , r = i ? void 0 : t
                  , n = {
                    needsRenderFrame: !1
                }
                  , o = {}
                  , s = {}
                  , a = t.touches ? this._getMapTouches(t.touches) : void 0
                  , l = a ? f(this._el, a) : i ? void 0 : m(this._el, t);
                for (const {handlerName: i, handler: c, allowed: u} of this._handlers) {
                    if (!c.isEnabled())
                        continue;
                    let h;
                    this._blockedByActive(s, u, i) ? c.reset() : c[e || t.type] && (h = c[e || t.type](t, l, a),
                    this.mergeHandlerResult(n, o, h, i, r),
                    h && h.needsRenderFrame && this._triggerRenderFrame()),
                    (h || c.isActive()) && (s[i] = c)
                }
                const c = {};
                for (const t in this._previousActiveHandlers)
                    s[t] || (c[t] = r);
                this._previousActiveHandlers = s,
                (Object.keys(c).length || Vn(n)) && (this._changes.push([n, o, c]),
                this._triggerRenderFrame()),
                (Object.keys(s).length || Vn(n)) && this._map._stop(!0),
                this._updatingCamera = !1;
                const {cameraAnimation: u} = n;
                u && (this._inertia.clear(),
                this._fireEvents({}, {}, !0),
                this._changes = [],
                u(this._map))
            }
            mergeHandlerResult(e, i, r, n, o) {
                if (!r)
                    return;
                t.extend(e, r);
                const s = {
                    handlerName: n,
                    originalEvent: r.originalEvent || o
                };
                void 0 !== r.zoomDelta && (i.zoom = s),
                void 0 !== r.panDelta && (i.drag = s),
                void 0 !== r.pitchDelta && (i.pitch = s),
                void 0 !== r.bearingDelta && (i.rotate = s)
            }
            _applyChanges() {
                const e = {}
                  , i = {}
                  , r = {};
                for (const [n,o,s] of this._changes)
                    n.panDelta && (e.panDelta = (e.panDelta || new t.pointGeometry(0,0))._add(n.panDelta)),
                    n.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + n.zoomDelta),
                    n.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + n.bearingDelta),
                    n.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + n.pitchDelta),
                    void 0 !== n.around && (e.around = n.around),
                    void 0 !== n.aroundCoord && (e.aroundCoord = n.aroundCoord),
                    void 0 !== n.pinchAround && (e.pinchAround = n.pinchAround),
                    n.noInertia && (e.noInertia = n.noInertia),
                    t.extend(i, o),
                    t.extend(r, s);
                this._updateMapTransform(e, i, r),
                this._changes = []
            }
            _updateMapTransform(e, i, r) {
                const n = this._map
                  , o = n.transform
                  , s = t=>[t.x, t.y, t.z];
                if ((t=>{
                    const e = this._eventsInProgress.drag;
                    return e && !this._handlersById[e.handlerName].isActive()
                }
                )() && !Vn(e)) {
                    const t = o.zoom;
                    o.cameraElevationReference = "sea",
                    o.recenterOnTerrain(),
                    o.cameraElevationReference = "ground",
                    t !== o.zoom && this._map._update(!0)
                }
                if (o._isCameraConstrained && n._stop(!0),
                !Vn(e))
                    return void this._fireEvents(i, r, !0);
                let {panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: u, around: h, aroundCoord: d, pinchAround: p} = e;
                o._isCameraConstrained && (l > 0 && (l = 0),
                o._isCameraConstrained = !1),
                void 0 !== p && (h = p),
                (t=>i.drag && !this._eventsInProgress.drag)() && h && (this._dragOrigin = s(o.pointCoordinate3D(h)),
                this._trackingEllipsoid.setup(o._camera.position, this._dragOrigin)),
                o.cameraElevationReference = "sea",
                n._stop(!0),
                h = h || n.transform.centerPoint,
                c && (o.bearing += c),
                u && (o.pitch += u),
                o._updateCameraState();
                const m = [0, 0, 0];
                if (a)
                    if ("mercator" === o.projection.name) {
                        const t = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h).dir)
                          , e = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h.sub(a)).dir);
                        m[0] = e[0] - t[0],
                        m[1] = e[1] - t[1]
                    } else {
                        const e = o.pointCoordinate(h);
                        if ("globe" === o.projection.name) {
                            a = a.rotate(-o.angle);
                            const i = o._pixelsPerMercatorPixel / o.worldSize;
                            m[0] = -a.x * t.mercatorScale(t.latFromMercatorY(e.y)) * i,
                            m[1] = -a.y * t.mercatorScale(o.center.lat) * i
                        } else {
                            const t = o.pointCoordinate(h.sub(a));
                            e && t && (m[0] = t.x - e.x,
                            m[1] = t.y - e.y)
                        }
                    }
                const f = o.zoom
                  , _ = [0, 0, 0];
                if (l) {
                    const e = s(d || o.pointCoordinate3D(h))
                      , i = {
                        dir: t.normalize([], t.sub([], e, o._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const r = o.zoomDeltaToMovement(e, l);
                        t.scale$2(_, i.dir, r)
                    }
                }
                const g = t.add(m, m, _);
                o._translateCameraConstrained(g),
                l && Math.abs(o.zoom - f) > 1e-4 && o.recenterOnTerrain(),
                o.cameraElevationReference = "ground",
                this._map._update(),
                e.noInertia || this._inertia.record(e),
                this._fireEvents(i, r, !0)
            }
            _fireEvents(e, i, r) {
                const n = Nn(this._eventsInProgress)
                  , o = Nn(e)
                  , s = {};
                for (const t in e) {
                    const {originalEvent: i} = e[t];
                    this._eventsInProgress[t] || (s[`${t}start`] = i),
                    this._eventsInProgress[t] = e[t]
                }
                !n && o && this._fireEvent("movestart", o.originalEvent);
                for (const t in s)
                    this._fireEvent(t, s[t]);
                o && this._fireEvent("move", o.originalEvent);
                for (const t in e) {
                    const {originalEvent: i} = e[t];
                    this._fireEvent(t, i)
                }
                const a = {};
                let l;
                for (const t in this._eventsInProgress) {
                    const {handlerName: e, originalEvent: r} = this._eventsInProgress[t];
                    this._handlersById[e].isActive() || (delete this._eventsInProgress[t],
                    l = i[e] || r,
                    a[`${t}end`] = l)
                }
                for (const t in a)
                    this._fireEvent(t, a[t]);
                const c = Nn(this._eventsInProgress);
                if (r && (n || o) && !c) {
                    this._updatingCamera = !0;
                    const e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                      , i = t=>0 !== t && -this._bearingSnap < t && t < this._bearingSnap;
                    e ? (i(e.bearing || this._map.getBearing()) && (e.bearing = 0),
                    this._map.easeTo(e, {
                        originalEvent: l
                    })) : (this._map.fire(new t.Event("moveend",{
                        originalEvent: l
                    })),
                    i(this._map.getBearing()) && this._map.resetNorth()),
                    this._updatingCamera = !1
                }
            }
            _fireEvent(e, i) {
                this._map.fire(new t.Event(e,i ? {
                    originalEvent: i
                } : {}))
            }
            _requestFrame() {
                return this._map.triggerRepaint(),
                this._map._renderTaskQueue.add((t=>{
                    this._frameId = void 0,
                    this.handleEvent(new Gn("renderFrame",{
                        timeStamp: t
                    })),
                    this._applyChanges()
                }
                ))
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame())
            }
        }
        const Jn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Xn extends t.Evented {
            constructor(e, i) {
                super(),
                this._moving = !1,
                this._zooming = !1,
                this.transform = e,
                this._bearingSnap = i.bearingSnap,
                t.bindAll(["_renderFrameCallback"], this)
            }
            getCenter() {
                return new t.LngLat(this.transform.center.lng,this.transform.center.lat)
            }
            setCenter(t, e) {
                return this.jumpTo({
                    center: t
                }, e)
            }
            panBy(e, i, r) {
                return e = t.pointGeometry.convert(e).mult(-1),
                this.panTo(this.transform.center, t.extend({
                    offset: e
                }, i), r)
            }
            panTo(e, i, r) {
                return this.easeTo(t.extend({
                    center: e
                }, i), r)
            }
            getZoom() {
                return this.transform.zoom
            }
            setZoom(t, e) {
                return this.jumpTo({
                    zoom: t
                }, e),
                this
            }
            zoomTo(e, i, r) {
                return this.easeTo(t.extend({
                    zoom: e
                }, i), r)
            }
            zoomIn(t, e) {
                return this.zoomTo(this.getZoom() + 1, t, e),
                this
            }
            zoomOut(t, e) {
                return this.zoomTo(this.getZoom() - 1, t, e),
                this
            }
            getBearing() {
                return this.transform.bearing
            }
            setBearing(t, e) {
                return this.jumpTo({
                    bearing: t
                }, e),
                this
            }
            getPadding() {
                return this.transform.padding
            }
            setPadding(t, e) {
                return this.jumpTo({
                    padding: t
                }, e),
                this
            }
            rotateTo(e, i, r) {
                return this.easeTo(t.extend({
                    bearing: e
                }, i), r)
            }
            resetNorth(e, i) {
                return this.rotateTo(0, t.extend({
                    duration: 1e3
                }, e), i),
                this
            }
            resetNorthPitch(e, i) {
                return this.easeTo(t.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, e), i),
                this
            }
            snapToNorth(t, e) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this
            }
            getPitch() {
                return this.transform.pitch
            }
            setPitch(t, e) {
                return this.jumpTo({
                    pitch: t
                }, e),
                this
            }
            cameraForBounds(e, i) {
                e = t.LngLatBounds.convert(e);
                const r = i && i.bearing || 0
                  , n = i && i.pitch || 0
                  , o = e.getNorthWest()
                  , s = e.getSouthEast();
                return this._cameraForBounds(this.transform, o, s, r, n, i)
            }
            _extendCameraOptions(e) {
                const i = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (e = t.extend({
                    padding: i,
                    offset: [0, 0],
                    maxZoom: this.transform.maxZoom
                }, e)).padding) {
                    const t = e.padding;
                    e.padding = {
                        top: t,
                        bottom: t,
                        right: t,
                        left: t
                    }
                }
                return e.padding = t.extend(i, e.padding),
                e
            }
            _minimumAABBFrustumDistance(t, e) {
                const i = e.max[0] - e.min[0]
                  , r = e.max[1] - e.min[1];
                return i / r > t.aspect ? i / (2 * Math.tan(.5 * t.fovX) * t.aspect) : r / (2 * Math.tan(.5 * t.fovY) * t.aspect)
            }
            _cameraForBoundsOnGlobe(e, i, r, n, o, s) {
                const a = e.clone()
                  , l = this._extendCameraOptions(s);
                a.bearing = n,
                a.pitch = o;
                const c = t.LngLat.convert(i)
                  , u = t.LngLat.convert(r)
                  , h = .5 * (c.lat + u.lat)
                  , d = .5 * (c.lng + u.lng)
                  , p = t.latLngToECEF(h, d)
                  , m = t.normalize([], p)
                  , f = t.normalize([], t.cross([], m, [0, 1, 0]))
                  , _ = t.cross([], f, m)
                  , g = [f[0], f[1], f[2], 0, _[0], _[1], _[2], 0, m[0], m[1], m[2], 0, 0, 0, 0, 1]
                  , y = [p, t.latLngToECEF(c.lat, c.lng), t.latLngToECEF(u.lat, c.lng), t.latLngToECEF(u.lat, u.lng), t.latLngToECEF(c.lat, u.lng), t.latLngToECEF(h, c.lng), t.latLngToECEF(h, u.lng), t.latLngToECEF(c.lat, d), t.latLngToECEF(u.lat, d)];
                let x = t.Aabb.fromPoints(y.map((e=>[t.dot(f, e), t.dot(_, e), t.dot(m, e)])));
                const v = t.transformMat4([], x.center, g);
                0 === t.squaredLength(v) && t.set(v, 0, 0, 1),
                t.normalize(v, v),
                t.scale$2(v, v, t.GLOBE_RADIUS),
                a.center = t.ecefToLatLng(v);
                const b = a.getWorldToCameraMatrix()
                  , w = t.invert(new Float64Array(16), b);
                x = t.Aabb.applyTransform(x, t.multiply([], b, g)),
                t.transformMat4(v, v, b);
                const z = .5 * (x.max[2] - x.min[2])
                  , T = this._minimumAABBFrustumDistance(a, x)
                  , E = t.scale$2([], [0, 0, 1], z)
                  , S = t.add(E, v, E)
                  , M = T + (0 === a.pitch ? 0 : t.distance(v, S))
                  , A = a.globeCenterInViewSpace
                  , I = t.sub([], v, [A[0], A[1], A[2]]);
                t.normalize(I, I),
                t.scale$2(I, I, M);
                const C = t.add([], v, I);
                t.transformMat4(C, C, w);
                const D = t.earthRadius / t.GLOBE_RADIUS
                  , k = t.length(C)
                  , P = t.mercatorZfromAltitude(k * D - t.earthRadius, 0)
                  , L = Math.min(a.zoomFromMercatorZAdjusted(P), l.maxZoom);
                return L > .5 * (t.GLOBE_ZOOM_THRESHOLD_MIN + t.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "mercator"
                }),
                a.zoom = L,
                this._cameraForBounds(a, i, r, n, o, s)) : {
                    center: a.center,
                    zoom: L,
                    bearing: n,
                    pitch: o
                }
            }
            queryTerrainElevation(e, i) {
                const r = this.transform.elevation;
                return r ? (i = t.extend({}, {
                    exaggerated: !0
                }, i),
                r.getAtPoint(t.MercatorCoordinate.fromLngLat(e), null, i.exaggerated)) : null
            }
            _cameraForBounds(e, i, r, n, o, s) {
                if ("globe" === e.projection.name)
                    return this._cameraForBoundsOnGlobe(e, i, r, n, o, s);
                const a = e.clone()
                  , l = this._extendCameraOptions(s)
                  , c = a.padding;
                a.bearing = n,
                a.pitch = o;
                const u = t.LngLat.convert(i)
                  , h = t.LngLat.convert(r)
                  , d = new t.LngLat(u.lng,h.lat)
                  , p = new t.LngLat(h.lng,u.lat)
                  , m = a.project(u)
                  , f = a.project(h)
                  , _ = this.queryTerrainElevation(u)
                  , g = this.queryTerrainElevation(h)
                  , y = this.queryTerrainElevation(d)
                  , x = this.queryTerrainElevation(p)
                  , v = [[m.x, m.y, Math.min(_ || 0, g || 0, y || 0, x || 0)], [f.x, f.y, Math.max(_ || 0, g || 0, y || 0, x || 0)]];
                let b = t.Aabb.fromPoints(v);
                const w = a.getWorldToCameraMatrix()
                  , z = t.invert(new Float64Array(16), w);
                b = t.Aabb.applyTransform(b, w);
                const T = t.sub([], b.max, b.min)
                  , E = c.left || 0
                  , S = c.right || 0
                  , M = c.bottom || 0
                  , A = c.top || 0
                  , {left: I, right: C, top: D, bottom: k} = l.padding
                  , P = .5 * (E + S)
                  , L = .5 * (A + M)
                  , O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (E + S + I + C)) / T[0], (a.height - (M + A + k + D)) / T[1])), l.maxZoom)
                  , R = a.scale / a.zoomScale(O);
                b = new t.Aabb([b.min[0] - (I + P) * R, b.min[1] - (k + L) * R, b.min[2]],[b.max[0] + (C + P) * R, b.max[1] + (D + L) * R, b.max[2]]);
                const B = .5 * T[2]
                  , F = this._minimumAABBFrustumDistance(a, b)
                  , U = [0, 0, 1, 0];
                t.transformMat4$1(U, U, w),
                t.normalize$2(U, U);
                const N = t.scale$2([], U, F + B)
                  , G = t.add([], b.center, N)
                  , j = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new t.pointGeometry(l.offset.x,l.offset.y) : t.pointGeometry.convert(l.offset)).rotate(-t.degToRad(n));
                b.center[0] -= j.x * R,
                b.center[1] += j.y * R,
                t.transformMat4(b.center, b.center, z),
                t.transformMat4(G, G, z);
                const V = [b.center[0], b.center[1], G[2] * a.pixelsPerMeter];
                t.scale$2(V, V, 1 / a.worldSize);
                const Z = t.lngFromMercatorX(V[0])
                  , J = t.latFromMercatorY(V[1])
                  , X = Math.min(a._zoomFromMercatorZ(V[2]), l.maxZoom)
                  , q = new t.LngLat(Z,J);
                return a.mercatorFromTransition && X < .5 * (t.GLOBE_ZOOM_THRESHOLD_MIN + t.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "globe"
                }),
                a.zoom = X,
                this._cameraForBounds(a, i, r, n, o, s)) : {
                    center: q,
                    zoom: X,
                    bearing: n,
                    pitch: o
                }
            }
            fitBounds(t, e, i) {
                const r = this.cameraForBounds(t, e);
                return this._fitInternal(r, e, i)
            }
            fitScreenCoordinates(e, i, r, n, o) {
                const s = t.pointGeometry.convert(e)
                  , a = t.pointGeometry.convert(i)
                  , l = new t.pointGeometry(Math.min(s.x, a.x),Math.min(s.y, a.y))
                  , c = new t.pointGeometry(Math.max(s.x, a.x),Math.max(s.y, a.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a))
                    return this;
                const u = this.transform.pointLocation3D(l)
                  , h = this.transform.pointLocation3D(c)
                  , d = this.transform.pointLocation3D(new t.pointGeometry(l.x,c.y))
                  , p = this.transform.pointLocation3D(new t.pointGeometry(c.x,l.y))
                  , m = [Math.min(u.lng, h.lng, d.lng, p.lng), Math.min(u.lat, h.lat, d.lat, p.lat)]
                  , f = [Math.max(u.lng, h.lng, d.lng, p.lng), Math.max(u.lat, h.lat, d.lat, p.lat)]
                  , _ = n && n.pitch ? n.pitch : this.getPitch()
                  , g = this._cameraForBounds(this.transform, m, f, r, _, n);
                return this._fitInternal(g, n, o)
            }
            _fitInternal(e, i, r) {
                return e ? (delete (i = t.extend(e, i)).padding,
                i.linear ? this.easeTo(i, r) : this.flyTo(i, r)) : this
            }
            jumpTo(e, i) {
                this.stop();
                const r = e.preloadOnly ? this.transform.clone() : this.transform;
                let n = !1
                  , o = !1
                  , s = !1;
                return "zoom"in e && r.zoom !== +e.zoom && (n = !0,
                r.zoom = +e.zoom),
                void 0 !== e.center && (r.center = t.LngLat.convert(e.center)),
                "bearing"in e && r.bearing !== +e.bearing && (o = !0,
                r.bearing = +e.bearing),
                "pitch"in e && r.pitch !== +e.pitch && (s = !0,
                r.pitch = +e.pitch),
                null == e.padding || r.isPaddingEqual(e.padding) || (r.padding = e.padding),
                e.preloadOnly ? (this._preloadTiles(r),
                this) : (this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                n && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                o && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                s && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                this.fire(new t.Event("moveend",i)))
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || t.warnOnce(Jn),
                this.transform.getFreeCameraOptions()
            }
            setFreeCameraOptions(e, i) {
                const r = this.transform;
                if (!r.projection.supportsFreeCamera)
                    return t.warnOnce(Jn),
                    this;
                this.stop();
                const n = r.zoom
                  , o = r.pitch
                  , s = r.bearing;
                r.setFreeCameraOptions(e);
                const a = n !== r.zoom
                  , l = o !== r.pitch
                  , c = s !== r.bearing;
                return this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                a && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                c && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                l && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                this.fire(new t.Event("moveend",i)),
                this
            }
            easeTo(e, i) {
                this._stop(!1, e.easeId),
                (!1 === (e = t.extend({
                    offset: [0, 0],
                    duration: 500,
                    easing: t.ease
                }, e)).animate || !e.essential && t.exported.prefersReducedMotion) && (e.duration = 0);
                const r = this.transform
                  , n = this.getZoom()
                  , o = this.getBearing()
                  , s = this.getPitch()
                  , a = this.getPadding()
                  , l = "zoom"in e ? +e.zoom : n
                  , c = "bearing"in e ? this._normalizeBearing(e.bearing, o) : o
                  , u = "pitch"in e ? +e.pitch : s
                  , h = "padding"in e ? e.padding : r.padding
                  , d = t.pointGeometry.convert(e.offset);
                let p, m, f;
                if ("globe" === r.projection.name) {
                    const i = t.MercatorCoordinate.fromLngLat(r.center)
                      , n = d.rotate(-r.angle);
                    i.x += n.x / r.worldSize,
                    i.y += n.y / r.worldSize;
                    const o = i.toLngLat()
                      , s = t.LngLat.convert(e.center || o);
                    this._normalizeCenter(s),
                    p = r.centerPoint.add(n),
                    m = new t.pointGeometry(i.x,i.y).mult(r.worldSize),
                    f = new t.pointGeometry(t.mercatorXfromLng(s.lng),t.mercatorYfromLat(s.lat)).mult(r.worldSize).sub(m)
                } else {
                    p = r.centerPoint.add(d);
                    const i = r.pointLocation(p)
                      , n = t.LngLat.convert(e.center || i);
                    this._normalizeCenter(n),
                    m = r.project(i),
                    f = r.project(n).sub(m)
                }
                const _ = r.zoomScale(l - n);
                let g, y;
                e.around && (g = t.LngLat.convert(e.around),
                y = r.locationPoint(g));
                const x = this._zooming || l !== n
                  , v = this._rotating || o !== c
                  , b = this._pitching || u !== s
                  , w = !r.isPaddingEqual(h)
                  , z = r=>z=>{
                    if (x && (r.zoom = t.number(n, l, z)),
                    v && (r.bearing = t.number(o, c, z)),
                    b && (r.pitch = t.number(s, u, z)),
                    w && (r.interpolatePadding(a, h, z),
                    p = r.centerPoint.add(d)),
                    g)
                        r.setLocationAtPoint(g, y);
                    else {
                        const t = r.zoomScale(r.zoom - n)
                          , e = l > n ? Math.min(2, _) : Math.max(.5, _)
                          , i = Math.pow(e, 1 - z)
                          , o = r.unproject(m.add(f.mult(z * i)).mult(t));
                        r.setLocationAtPoint(r.renderWorldCopies ? o.wrap() : o, p)
                    }
                    return e.preloadOnly || this._fireMoveEvents(i),
                    r
                }
                ;
                if (e.preloadOnly) {
                    const t = this._emulate(z, e.duration, r);
                    return this._preloadTiles(t),
                    this
                }
                const T = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = x,
                this._rotating = v,
                this._pitching = b,
                this._padding = w,
                this._easeId = e.easeId,
                this._prepareEase(i, e.noMoveStart, T),
                this._ease(z(r), (t=>{
                    r.recenterOnTerrain(),
                    this._afterEase(i, t)
                }
                ), e),
                this
            }
            _prepareEase(e, i, r={}) {
                this._moving = !0,
                this.transform.cameraElevationReference = "sea",
                i || r.moving || this.fire(new t.Event("movestart",e)),
                this._zooming && !r.zooming && this.fire(new t.Event("zoomstart",e)),
                this._rotating && !r.rotating && this.fire(new t.Event("rotatestart",e)),
                this._pitching && !r.pitching && this.fire(new t.Event("pitchstart",e))
            }
            _fireMoveEvents(e) {
                this.fire(new t.Event("move",e)),
                this._zooming && this.fire(new t.Event("zoom",e)),
                this._rotating && this.fire(new t.Event("rotate",e)),
                this._pitching && this.fire(new t.Event("pitch",e))
            }
            _afterEase(e, i) {
                if (this._easeId && i && this._easeId === i)
                    return;
                this._easeId = void 0,
                this.transform.cameraElevationReference = "ground";
                const r = this._zooming
                  , n = this._rotating
                  , o = this._pitching;
                this._moving = !1,
                this._zooming = !1,
                this._rotating = !1,
                this._pitching = !1,
                this._padding = !1,
                r && this.fire(new t.Event("zoomend",e)),
                n && this.fire(new t.Event("rotateend",e)),
                o && this.fire(new t.Event("pitchend",e)),
                this.fire(new t.Event("moveend",e))
            }
            flyTo(e, i) {
                if (!e.essential && t.exported.prefersReducedMotion) {
                    const r = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);
                    return this.jumpTo(r, i)
                }
                this.stop(),
                e = t.extend({
                    offset: [0, 0],
                    speed: 1.2,
                    curve: 1.42,
                    easing: t.ease
                }, e);
                const r = this.transform
                  , n = this.getZoom()
                  , o = this.getBearing()
                  , s = this.getPitch()
                  , a = this.getPadding()
                  , l = "zoom"in e ? t.clamp(+e.zoom, r.minZoom, r.maxZoom) : n
                  , c = "bearing"in e ? this._normalizeBearing(e.bearing, o) : o
                  , u = "pitch"in e ? +e.pitch : s
                  , h = "padding"in e ? e.padding : r.padding
                  , d = r.zoomScale(l - n)
                  , p = t.pointGeometry.convert(e.offset);
                let m = r.centerPoint.add(p);
                const f = r.pointLocation(m)
                  , _ = t.LngLat.convert(e.center || f);
                this._normalizeCenter(_);
                const g = r.project(f)
                  , y = r.project(_).sub(g);
                let x = e.curve;
                const v = Math.max(r.width, r.height)
                  , b = v / d
                  , w = y.mag();
                if ("minZoom"in e) {
                    const i = t.clamp(Math.min(e.minZoom, n, l), r.minZoom, r.maxZoom)
                      , o = v / r.zoomScale(i - n);
                    x = Math.sqrt(o / w * 2)
                }
                const z = x * x;
                function T(t) {
                    const e = (b * b - v * v + (t ? -1 : 1) * z * z * w * w) / (2 * (t ? b : v) * z * w);
                    return Math.log(Math.sqrt(e * e + 1) - e)
                }
                function E(t) {
                    return (Math.exp(t) - Math.exp(-t)) / 2
                }
                function S(t) {
                    return (Math.exp(t) + Math.exp(-t)) / 2
                }
                const M = T(0);
                let A = function(t) {
                    return S(M) / S(M + x * t)
                }
                  , I = function(t) {
                    var e;
                    return v * ((S(M) * (E(e = M + x * t) / S(e)) - E(M)) / z) / w
                }
                  , C = (T(1) - M) / x;
                if (Math.abs(w) < 1e-6 || !isFinite(C)) {
                    if (Math.abs(v - b) < 1e-6)
                        return this.easeTo(e, i);
                    const t = b < v ? -1 : 1;
                    C = Math.abs(Math.log(b / v)) / x,
                    I = function() {
                        return 0
                    }
                    ,
                    A = function(e) {
                        return Math.exp(t * x * e)
                    }
                }
                e.duration = "duration"in e ? +e.duration : 1e3 * C / ("screenSpeed"in e ? +e.screenSpeed / x : +e.speed),
                e.maxDuration && e.duration > e.maxDuration && (e.duration = 0);
                const D = o !== c
                  , k = u !== s
                  , P = !r.isPaddingEqual(h)
                  , L = r=>d=>{
                    const f = d * C
                      , x = 1 / A(f);
                    r.zoom = 1 === d ? l : n + r.scaleZoom(x),
                    D && (r.bearing = t.number(o, c, d)),
                    k && (r.pitch = t.number(s, u, d)),
                    P && (r.interpolatePadding(a, h, d),
                    m = r.centerPoint.add(p));
                    const v = 1 === d ? _ : r.unproject(g.add(y.mult(I(f))).mult(x));
                    return r.setLocationAtPoint(r.renderWorldCopies ? v.wrap() : v, m),
                    r._updateCameraOnTerrain(),
                    e.preloadOnly || this._fireMoveEvents(i),
                    r
                }
                ;
                if (e.preloadOnly) {
                    const t = this._emulate(L, e.duration, r);
                    return this._preloadTiles(t),
                    this
                }
                return this._zooming = !0,
                this._rotating = D,
                this._pitching = k,
                this._padding = P,
                this._prepareEase(i, !1),
                this._ease(L(r), (()=>this._afterEase(i)), e),
                this
            }
            isEasing() {
                return !!this._easeFrameId
            }
            stop() {
                return this._stop()
            }
            _stop(t, e) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                this._easeFrameId = void 0,
                this._onEaseFrame = void 0),
                this._onEaseEnd) {
                    const t = this._onEaseEnd;
                    this._onEaseEnd = void 0,
                    t.call(this, e)
                }
                if (!t) {
                    const t = this.handlers;
                    t && t.stop(!1)
                }
                return this
            }
            _ease(e, i, r) {
                !1 === r.animate || 0 === r.duration ? (e(1),
                i()) : (this._easeStart = t.exported.now(),
                this._easeOptions = r,
                this._onEaseFrame = e,
                this._onEaseEnd = i,
                this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
            }
            _renderFrameCallback() {
                const e = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1)
                  , i = this._onEaseFrame;
                i && i(this._easeOptions.easing(e)),
                e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }
            _normalizeBearing(e, i) {
                e = t.wrap(e, -180, 180);
                const r = Math.abs(e - i);
                return Math.abs(e - 360 - i) < r && (e -= 360),
                Math.abs(e + 360 - i) < r && (e += 360),
                e
            }
            _normalizeCenter(t) {
                const e = this.transform;
                if (!e.renderWorldCopies || e.maxBounds)
                    return;
                const i = t.lng - e.center.lng;
                t.lng += i > 180 ? -360 : i < -180 ? 360 : 0
            }
            _emulate(t, e, i) {
                const r = Math.ceil(15 * e / 1e3)
                  , n = []
                  , o = t(i.clone());
                for (let t = 0; t <= r; t++) {
                    const e = o(t / r);
                    n.push(e.clone())
                }
                return n
            }
        }
        class qn {
            constructor(e={}) {
                this.options = e,
                t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
            }
            getDefaultPosition() {
                return "bottom-right"
            }
            onAdd(t) {
                const e = this.options && this.options.compact;
                return this._map = t,
                this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"),
                this._compactButton = o("button", "mapboxgl-ctrl-attrib-button", this._container),
                o("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"),
                this._compactButton.type = "button",
                this._compactButton.addEventListener("click", this._toggleAttribution),
                this._setElementTitle(this._compactButton, "ToggleAttribution"),
                this._innerContainer = o("div", "mapboxgl-ctrl-attrib-inner", this._container),
                this._innerContainer.setAttribute("role", "list"),
                e && this._container.classList.add("mapboxgl-compact"),
                this._updateAttributions(),
                this._updateEditLink(),
                this._map.on("styledata", this._updateData),
                this._map.on("sourcedata", this._updateData),
                this._map.on("moveend", this._updateEditLink),
                void 0 === e && (this._map.on("resize", this._updateCompact),
                this._updateCompact()),
                this._container
            }
            onRemove() {
                this._container.remove(),
                this._map.off("styledata", this._updateData),
                this._map.off("sourcedata", this._updateData),
                this._map.off("moveend", this._updateEditLink),
                this._map.off("resize", this._updateCompact),
                this._map = void 0,
                this._attribHTML = void 0
            }
            _setElementTitle(t, e) {
                const i = this._map._getUIString(`AttributionControl.${e}`);
                t.setAttribute("aria-label", i),
                t.removeAttribute("title"),
                t.firstElementChild && t.firstElementChild.setAttribute("title", i)
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"),
                this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"),
                this._compactButton.setAttribute("aria-expanded", "true"))
            }
            _updateEditLink() {
                let e = this._editLink;
                e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [{
                    key: "owner",
                    value: this.styleOwner
                }, {
                    key: "id",
                    value: this.styleId
                }, {
                    key: "access_token",
                    value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN
                }];
                if (e) {
                    const r = i.reduce(((t,e,r)=>(e.value && (t += `${e.key}=${e.value}${r < i.length - 1 ? "&" : ""}`),
                    t)), "?");
                    e.href = `${t.config.FEEDBACK_URL}/${r}#${Yr(this._map, !0)}`,
                    e.rel = "noopener nofollow",
                    this._setElementTitle(e, "MapFeedback")
                }
            }
            _updateData(t) {
                !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(),
                this._updateEditLink())
            }
            _updateAttributions() {
                if (!this._map.style)
                    return;
                let t = [];
                if (this._map.style.stylesheet) {
                    const t = this._map.style.stylesheet;
                    this.styleOwner = t.owner,
                    this.styleId = t.id
                }
                const e = this._map.style._sourceCaches;
                for (const i in e) {
                    const r = e[i];
                    if (r.used) {
                        const e = r.getSource();
                        e.attribution && t.indexOf(e.attribution) < 0 && t.push(e.attribution)
                    }
                }
                t.sort(((t,e)=>t.length - e.length)),
                t = t.filter(((e,i)=>{
                    for (let r = i + 1; r < t.length; r++)
                        if (t[r].indexOf(e) >= 0)
                            return !1;
                    return !0
                }
                )),
                this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
                const i = t.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i,
                t.length ? (this._innerContainer.innerHTML = i,
                this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"),
                this._editLink = null)
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
            }
        }
        class $n {
            constructor() {
                t.bindAll(["_updateLogo", "_updateCompact"], this)
            }
            onAdd(t) {
                this._map = t,
                this._container = o("div", "mapboxgl-ctrl");
                const e = o("a", "mapboxgl-ctrl-logo");
                return e.target = "_blank",
                e.rel = "noopener nofollow",
                e.href = "https://www.mapbox.com/",
                e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                e.setAttribute("rel", "noopener nofollow"),
                this._container.appendChild(e),
                this._container.style.display = "none",
                this._map.on("sourcedata", this._updateLogo),
                this._updateLogo(),
                this._map.on("resize", this._updateCompact),
                this._updateCompact(),
                this._container
            }
            onRemove() {
                this._container.remove(),
                this._map.off("sourcedata", this._updateLogo),
                this._map.off("resize", this._updateCompact)
            }
            getDefaultPosition() {
                return "bottom-left"
            }
            _updateLogo(t) {
                t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none")
            }
            _logoRequired() {
                if (!this._map.style)
                    return !0;
                const t = this._map.style._sourceCaches;
                if (0 === Object.entries(t).length)
                    return !0;
                for (const e in t) {
                    const i = t[e].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo)
                        return !1
                }
                return !0
            }
            _updateCompact() {
                const t = this._container.children;
                if (t.length) {
                    const e = t[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("mapboxgl-compact") : e.classList.remove("mapboxgl-compact")
                }
            }
        }
        class Yn {
            constructor() {
                this._queue = [],
                this._id = 0,
                this._cleared = !1,
                this._currentlyRunning = !1
            }
            add(t) {
                const e = ++this._id;
                return this._queue.push({
                    callback: t,
                    id: e,
                    cancelled: !1
                }),
                e
            }
            remove(t) {
                const e = this._currentlyRunning
                  , i = e ? this._queue.concat(e) : this._queue;
                for (const e of i)
                    if (e.id === t)
                        return void (e.cancelled = !0)
            }
            run(t=0) {
                const e = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of e)
                    if (!i.cancelled && (i.callback(t),
                    this._cleared))
                        break;
                this._cleared = !1,
                this._currentlyRunning = !1
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0),
                this._queue = []
            }
        }
        function Wn(e, i, r) {
            if (e = new t.LngLat(e.lng,e.lat),
            i) {
                const n = new t.LngLat(e.lng - 360,e.lat)
                  , o = new t.LngLat(e.lng + 360,e.lat)
                  , s = 360 * Math.ceil(Math.abs(e.lng - r.center.lng) / 360)
                  , a = r.locationPoint(e).distSqr(i)
                  , l = i.x < 0 || i.y < 0 || i.x > r.width || i.y > r.height;
                r.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - r.center.lng) < s) ? e = n : r.locationPoint(o).distSqr(i) < a && (l || Math.abs(o.lng - r.center.lng) < s) && (e = o)
            }
            for (; Math.abs(e.lng - r.center.lng) > 180; ) {
                const t = r.locationPoint(e);
                if (t.x >= 0 && t.y >= 0 && t.x <= r.width && t.y <= r.height)
                    break;
                e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360
            }
            return e
        }
        const Hn = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class Kn extends t.Evented {
            constructor(e, i) {
                if (super(),
                (e instanceof t.window.HTMLElement || i) && (e = t.extend({
                    element: e
                }, i)),
                t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this),
                this._anchor = e && e.anchor || "center",
                this._color = e && e.color || "#3FB1CE",
                this._scale = e && e.scale || 1,
                this._draggable = e && e.draggable || !1,
                this._clickTolerance = e && e.clickTolerance || 0,
                this._isDragging = !1,
                this._state = "inactive",
                this._rotation = e && e.rotation || 0,
                this._rotationAlignment = e && e.rotationAlignment || "auto",
                this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment || "auto",
                this._updateMoving = ()=>this._update(!0),
                this._occludedOpacity = e && e.occludedOpacity || .2,
                e && e.element)
                    this._element = e.element,
                    this._offset = t.pointGeometry.convert(e && e.offset || [0, 0]);
                else {
                    this._defaultMarker = !0,
                    this._element = o("div");
                    const i = 41
                      , r = 27
                      , n = s("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: r * this._scale + "px",
                        viewBox: `0 0 ${r} ${i}`
                    }, this._element)
                      , a = s("radialGradient", {
                        id: "shadowGradient"
                    }, s("defs", {}, n));
                    s("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, a),
                    s("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, a),
                    s("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, n),
                    s("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, n),
                    s("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, n),
                    s("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, n),
                    this._offset = t.pointGeometry.convert(e && e.offset || [0, -14])
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"),
                this._element.classList.add("mapboxgl-marker"),
                this._element.addEventListener("dragstart", (t=>{
                    t.preventDefault()
                }
                )),
                this._element.addEventListener("mousedown", (t=>{
                    t.preventDefault()
                }
                ));
                const r = this._element.classList;
                for (const t in Hn)
                    r.remove(`mapboxgl-marker-anchor-${t}`);
                r.add(`mapboxgl-marker-anchor-${this._anchor}`),
                this._popup = null
            }
            addTo(t) {
                return t === this._map || (this.remove(),
                this._map = t,
                t.getCanvasContainer().appendChild(this._element),
                t.on("move", this._updateMoving),
                t.on("moveend", this._update),
                t.on("remove", this._clearFadeTimer),
                t._addMarker(this),
                this.setDraggable(this._draggable),
                this._update(),
                t.on("click", this._onMapClick)),
                this
            }
            remove() {
                const t = this._map;
                return t && (t.off("click", this._onMapClick),
                t.off("move", this._updateMoving),
                t.off("moveend", this._update),
                t.off("mousedown", this._addDragHandler),
                t.off("touchstart", this._addDragHandler),
                t.off("mouseup", this._onUp),
                t.off("touchend", this._onUp),
                t.off("mousemove", this._onMove),
                t.off("touchmove", this._onMove),
                t.off("remove", this._clearFadeTimer),
                t._removeMarker(this),
                this._map = void 0),
                this._clearFadeTimer(),
                this._element.remove(),
                this._popup && this._popup.remove(),
                this
            }
            getLngLat() {
                return this._lngLat
            }
            setLngLat(e) {
                return this._lngLat = t.LngLat.convert(e),
                this._pos = null,
                this._popup && this._popup.setLngLat(this._lngLat),
                this._update(!0),
                this
            }
            getElement() {
                return this._element
            }
            setPopup(t) {
                if (this._popup && (this._popup.remove(),
                this._popup = null,
                this._element.removeAttribute("role"),
                this._element.removeEventListener("keypress", this._onKeyPress),
                this._originalTabIndex || this._element.removeAttribute("tabindex")),
                t) {
                    if (!("offset"in t.options)) {
                        const e = 38.1
                          , i = 13.5
                          , r = Math.sqrt(Math.pow(i, 2) / 2);
                        t.options.offset = this._defaultMarker ? {
                            top: [0, 0],
                            "top-left": [0, 0],
                            "top-right": [0, 0],
                            bottom: [0, -e],
                            "bottom-left": [r, -1 * (e - i + r)],
                            "bottom-right": [-r, -1 * (e - i + r)],
                            left: [i, -1 * (e - i)],
                            right: [-i, -1 * (e - i)]
                        } : this._offset
                    }
                    this._popup = t,
                    t._marker = this,
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    this._element.setAttribute("role", "button"),
                    this._originalTabIndex = this._element.getAttribute("tabindex"),
                    this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener("keypress", this._onKeyPress),
                    this._element.setAttribute("aria-expanded", "false")
                }
                return this
            }
            _onKeyPress(t) {
                const e = t.code
                  , i = t.charCode || t.keyCode;
                "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup()
            }
            _onMapClick(t) {
                const e = t.originalEvent.target
                  , i = this._element;
                this._popup && (e === i || i.contains(e)) && this.togglePopup()
            }
            getPopup() {
                return this._popup
            }
            togglePopup() {
                const t = this._popup;
                return t ? (t.isOpen() ? (t.remove(),
                this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map),
                this._element.setAttribute("aria-expanded", "true")),
                this) : this
            }
            _behindTerrain() {
                const t = this._map
                  , e = this._pos;
                if (!t || !e)
                    return !1;
                const i = t.unproject(e)
                  , r = t.getFreeCameraOptions();
                if (!r.position)
                    return !1;
                const n = r.position.toLngLat();
                return n.distanceTo(i) < .9 * n.distanceTo(this._lngLat)
            }
            _evaluateOpacity() {
                const e = this._map;
                if (!e)
                    return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > e.transform.width || i.y < 0 || i.y > e.transform.height)
                    return void this._clearFadeTimer();
                const r = e.unproject(i);
                let n;
                e._showingGlobe() && t.isLngLatBehindGlobe(e.transform, this._lngLat) ? n = 0 : (n = 1 - e._queryFogOpacity(r),
                e.transform._terrainEnabled() && e.getTerrain() && this._behindTerrain() && (n *= this._occludedOpacity)),
                this._element.style.opacity = `${n}`,
                this._element.style.pointerEvents = n > 0 ? "auto" : "none",
                this._popup && this._popup._setOpacity(n),
                this._fadeTimer = null
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer),
                this._fadeTimer = null)
            }
            _updateDOM() {
                const t = this._pos;
                if (!t || !this._map)
                    return;
                const e = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${t.x}px,${t.y}px)\n            ${Hn[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${e.x}px,${e.y}px)\n        `
            }
            _calculateXYTransform() {
                const e = this._pos
                  , i = this._map
                  , r = this.getPitchAlignment();
                if (!i || !e || "map" !== r)
                    return "";
                if (!i._showingGlobe()) {
                    const t = i.getPitch();
                    return t ? `rotateX(${t}deg)` : ""
                }
                const n = t.radToDeg(t.globeTiltAtLngLat(i.transform, this._lngLat))
                  , o = e.sub(t.globeCenterToScreenPoint(i.transform))
                  , s = Math.abs(o.x) + Math.abs(o.y);
                if (0 === s)
                    return "";
                const a = n / s;
                return `rotateX(${-o.y * a}deg) rotateY(${o.x * a}deg)`
            }
            _calculateZTransform() {
                const e = this._pos
                  , i = this._map;
                if (!i || !e)
                    return "";
                let r = 0;
                const n = this.getRotationAlignment();
                if ("map" === n)
                    if (i._showingGlobe()) {
                        const e = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat + .001))
                          , n = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat - .001)).sub(e);
                        r = t.radToDeg(Math.atan2(n.y, n.x)) - 90
                    } else
                        r = -i.getBearing();
                else if ("horizon" === n) {
                    const n = t.smoothstep(4, 6, i.getZoom())
                      , o = t.globeCenterToScreenPoint(i.transform);
                    o.y += n * i.transform.height;
                    const s = e.sub(o)
                      , a = t.radToDeg(Math.atan2(s.y, s.x));
                    r = (a > 90 ? a - 270 : a + 90) * (1 - n)
                }
                return r += this._rotation,
                r ? `rotateZ(${r}deg)` : ""
            }
            _update(e) {
                t.window.cancelAnimationFrame(this._updateFrameId);
                const i = this._map;
                i && (i.transform.renderWorldCopies && (this._lngLat = Wn(this._lngLat, this._pos, i.transform)),
                this._pos = i.project(this._lngLat),
                !0 === e ? this._updateFrameId = t.window.requestAnimationFrame((()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(),
                    this._updateDOM())
                }
                )) : this._pos = this._pos.round(),
                i._requestDomTask((()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(),
                    (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)))
                }
                )))
            }
            getOffset() {
                return this._offset
            }
            setOffset(e) {
                return this._offset = t.pointGeometry.convert(e),
                this._update(),
                this
            }
            _onMove(e) {
                const i = this._map;
                if (!i)
                    return;
                const r = this._pointerdownPos
                  , n = this._positionDelta;
                if (r && n) {
                    if (!this._isDragging) {
                        const t = this._clickTolerance || i._clickTolerance;
                        if (e.point.dist(r) < t)
                            return;
                        this._isDragging = !0
                    }
                    this._pos = e.point.sub(n),
                    this._lngLat = i.unproject(this._pos),
                    this.setLngLat(this._lngLat),
                    this._element.style.pointerEvents = "none",
                    "pending" === this._state && (this._state = "active",
                    this.fire(new t.Event("dragstart"))),
                    this.fire(new t.Event("drag"))
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto",
                this._positionDelta = null,
                this._pointerdownPos = null,
                this._isDragging = !1;
                const e = this._map;
                e && (e.off("mousemove", this._onMove),
                e.off("touchmove", this._onMove)),
                "active" === this._state && this.fire(new t.Event("dragend")),
                this._state = "inactive"
            }
            _addDragHandler(t) {
                const e = this._map
                  , i = this._pos;
                e && i && this._element.contains(t.originalEvent.target) && (t.preventDefault(),
                this._positionDelta = t.point.sub(i),
                this._pointerdownPos = t.point,
                this._state = "pending",
                e.on("mousemove", this._onMove),
                e.on("touchmove", this._onMove),
                e.once("mouseup", this._onUp),
                e.once("touchend", this._onUp))
            }
            setDraggable(t) {
                this._draggable = !!t;
                const e = this._map;
                return e && (t ? (e.on("mousedown", this._addDragHandler),
                e.on("touchstart", this._addDragHandler)) : (e.off("mousedown", this._addDragHandler),
                e.off("touchstart", this._addDragHandler))),
                this
            }
            isDraggable() {
                return this._draggable
            }
            setRotation(t) {
                return this._rotation = t || 0,
                this._update(),
                this
            }
            getRotation() {
                return this._rotation
            }
            setRotationAlignment(t) {
                return this._rotationAlignment = t || "auto",
                this._update(),
                this
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
            }
            setPitchAlignment(t) {
                return this._pitchAlignment = t || "auto",
                this._update(),
                this
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment
            }
            setOccludedOpacity(t) {
                return this._occludedOpacity = t || .2,
                this._update(),
                this
            }
            getOccludedOpacity() {
                return this._occludedOpacity
            }
        }
        const Qn = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }
          , to = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function eo(e=new t.pointGeometry(0,0), i="bottom") {
            if ("number" == typeof e) {
                const r = Math.round(Math.sqrt(.5 * Math.pow(e, 2)));
                switch (i) {
                case "top":
                    return new t.pointGeometry(0,e);
                case "top-left":
                    return new t.pointGeometry(r,r);
                case "top-right":
                    return new t.pointGeometry(-r,r);
                case "bottom":
                    return new t.pointGeometry(0,-e);
                case "bottom-left":
                    return new t.pointGeometry(r,-r);
                case "bottom-right":
                    return new t.pointGeometry(-r,-r);
                case "left":
                    return new t.pointGeometry(e,0);
                case "right":
                    return new t.pointGeometry(-e,0)
                }
                return new t.pointGeometry(0,0)
            }
            return e instanceof t.pointGeometry || Array.isArray(e) ? t.pointGeometry.convert(e) : t.pointGeometry.convert(e[i] || [0, 0])
        }
        class io {
            constructor(t) {
                this.jumpTo(t)
            }
            getValue(e) {
                if (e <= this._startTime)
                    return this._start;
                if (e >= this._endTime)
                    return this._end;
                const i = t.easeCubicInOut((e - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i
            }
            isEasing(t) {
                return t >= this._startTime && t <= this._endTime
            }
            jumpTo(t) {
                this._startTime = -1 / 0,
                this._endTime = -1 / 0,
                this._start = t,
                this._end = t
            }
            easeTo(t, e, i) {
                this._start = this.getValue(e),
                this._end = t,
                this._startTime = e,
                this._endTime = e + i
            }
        }
        const ro = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }
          , no = {
            center: [0, 0],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            optimizeForTerrain: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            crossSourceCollisions: !0
        }
          , oo = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class so {
            constructor(e, i, r=!1) {
                this._clickTolerance = 10,
                this.element = i,
                this.mouseRotate = new yn({
                    clickTolerance: e.dragRotate._mouseRotate._clickTolerance
                }),
                this.map = e,
                r && (this.mousePitch = new xn({
                    clickTolerance: e.dragRotate._mousePitch._clickTolerance
                })),
                t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this),
                i.addEventListener("mousedown", this.mousedown),
                i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }),
                i.addEventListener("touchmove", this.touchmove),
                i.addEventListener("touchend", this.touchend),
                i.addEventListener("touchcancel", this.reset)
            }
            down(t, e) {
                this.mouseRotate.mousedown(t, e),
                this.mousePitch && this.mousePitch.mousedown(t, e),
                u()
            }
            move(t, e) {
                const i = this.map
                  , r = this.mouseRotate.mousemoveWindow(t, e)
                  , n = r && r.bearingDelta;
                if (n && i.setBearing(i.getBearing() + n),
                this.mousePitch) {
                    const r = this.mousePitch.mousemoveWindow(t, e)
                      , n = r && r.pitchDelta;
                    n && i.setPitch(i.getPitch() + n)
                }
            }
            off() {
                const t = this.element;
                t.removeEventListener("mousedown", this.mousedown),
                t.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }),
                t.removeEventListener("touchmove", this.touchmove),
                t.removeEventListener("touchend", this.touchend),
                t.removeEventListener("touchcancel", this.reset),
                this.offTemp()
            }
            offTemp() {
                h(),
                t.window.removeEventListener("mousemove", this.mousemove),
                t.window.removeEventListener("mouseup", this.mouseup)
            }
            mousedown(e) {
                this.down(t.extend({}, e, {
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }), m(this.element, e)),
                t.window.addEventListener("mousemove", this.mousemove),
                t.window.addEventListener("mouseup", this.mouseup)
            }
            mousemove(t) {
                this.move(t, m(this.element, t))
            }
            mouseup(t) {
                this.mouseRotate.mouseupWindow(t),
                this.mousePitch && this.mousePitch.mouseupWindow(t),
                this.offTemp()
            }
            touchstart(t) {
                1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = f(this.element, t.targetTouches)[0],
                this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>t.preventDefault()
                }, this._startPos))
            }
            touchmove(t) {
                1 !== t.targetTouches.length ? this.reset() : (this._lastPos = f(this.element, t.targetTouches)[0],
                this.move({
                    preventDefault: ()=>t.preventDefault()
                }, this._lastPos))
            }
            touchend(t) {
                0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                this.reset()
            }
            reset() {
                this.mouseRotate.reset(),
                this.mousePitch && this.mousePitch.reset(),
                delete this._startPos,
                delete this._lastPos,
                this.offTemp()
            }
        }
        const ao = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }
          , lo = {
            maxWidth: 100,
            unit: "metric"
        };
        function co(t, e, i) {
            const r = uo(e)
              , n = r / e
              , o = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm"
            }[i];
            this._map._requestDomTask((()=>{
                this._container.style.width = t * n + "px",
                this._container.innerHTML = `${r}&nbsp;${o}`
            }
            ))
        }
        function uo(t) {
            const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
            let i = t / e;
            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(t) {
                const e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));
                return Math.round(t * e) / e
            }(i),
            e * i
        }
        const ho = {
            version: t.version,
            supported: i,
            setRTLTextPlugin: t.setRTLTextPlugin,
            getRTLTextPluginStatus: t.getRTLTextPluginStatus,
            Map: class extends Xn {
                constructor(e) {
                    if (t.LivePerformanceUtils.mark(t.PerformanceMarkers.create),
                    null != (e = t.extend({}, no, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom)
                        throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch)
                        throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != e.minPitch && e.minPitch < 0)
                        throw new Error("minPitch must be greater than or equal to 0");
                    if (null != e.maxPitch && e.maxPitch > 85)
                        throw new Error("maxPitch must be less than or equal to 85");
                    if (e.antialias && t.isSafariWithAntialiasingBug(t.window) && (e.antialias = !1,
                    t.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),
                    super(new Xr(e.minZoom,e.maxZoom,e.minPitch,e.maxPitch,e.renderWorldCopies), e),
                    this._interactive = e.interactive,
                    this._minTileCacheSize = e.minTileCacheSize,
                    this._maxTileCacheSize = e.maxTileCacheSize,
                    this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat,
                    this._preserveDrawingBuffer = e.preserveDrawingBuffer,
                    this._antialias = e.antialias,
                    this._trackResize = e.trackResize,
                    this._bearingSnap = e.bearingSnap,
                    this._refreshExpiredTiles = e.refreshExpiredTiles,
                    this._fadeDuration = e.fadeDuration,
                    this._isInitialLoad = !0,
                    this._crossSourceCollisions = e.crossSourceCollisions,
                    this._collectResourceTiming = e.collectResourceTiming,
                    this._optimizeForTerrain = e.optimizeForTerrain,
                    this._language = this._parseLanguage(e.language),
                    this._worldview = e.worldview,
                    this._renderTaskQueue = new Yn,
                    this._domRenderTaskQueue = new Yn,
                    this._controls = [],
                    this._markers = [],
                    this._popups = [],
                    this._mapId = t.uniqueId(),
                    this._locale = t.extend({}, ro, e.locale),
                    this._clickTolerance = e.clickTolerance,
                    this._cooperativeGestures = e.cooperativeGestures,
                    this._performanceMetricsCollection = e.performanceMetricsCollection,
                    this._containerWidth = 0,
                    this._containerHeight = 0,
                    this._averageElevationLastSampledAt = -1 / 0,
                    this._averageElevationExaggeration = 0,
                    this._averageElevation = new io(0),
                    this._interactionRange = [1 / 0, -1 / 0],
                    this._visibilityHidden = 0,
                    this._useExplicitProjection = !1,
                    this._requestManager = new t.RequestManager(e.transformRequest,e.accessToken,e.testMode),
                    this._silenceAuthErrors = !!e.testMode,
                    "string" == typeof e.container) {
                        if (this._container = t.window.document.getElementById(e.container),
                        !this._container)
                            throw new Error(`Container '${e.container}' not found.`)
                    } else {
                        if (!(e.container instanceof t.window.HTMLElement))
                            throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = e.container
                    }
                    if (this._container.childNodes.length > 0 && t.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),
                    e.maxBounds && this.setMaxBounds(e.maxBounds),
                    t.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this),
                    this._setupContainer(),
                    this._setupPainter(),
                    void 0 === this.painter)
                        throw new Error("Failed to initialize WebGL.");
                    this.on("move", (()=>this._update(!1))),
                    this.on("moveend", (()=>this._update(!1))),
                    this.on("zoom", (()=>this._update(!0))),
                    void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1),
                    t.window.addEventListener("resize", this._onWindowResize, !1),
                    t.window.addEventListener("orientationchange", this._onWindowResize, !1),
                    t.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                    t.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)),
                    this.handlers = new Zn(this,e),
                    this._localFontFamily = e.localFontFamily,
                    this._localIdeographFontFamily = e.localIdeographFontFamily,
                    e.style && this.setStyle(e.style, {
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }),
                    e.projection && this.setProjection(e.projection),
                    this._hash = e.hash && new $r("string" == typeof e.hash && e.hash || void 0).addTo(this),
                    this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: e.center,
                        zoom: e.zoom,
                        bearing: e.bearing,
                        pitch: e.pitch
                    }),
                    e.bounds && (this.resize(),
                    this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {
                        duration: 0
                    })))),
                    this.resize(),
                    e.attributionControl && this.addControl(new qn({
                        customAttribution: e.customAttribution
                    })),
                    this._logoControl = new $n,
                    this.addControl(this._logoControl, e.logoPosition),
                    this.on("style.load", (()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet)
                    }
                    )),
                    this.on("data", (e=>{
                        this._update("style" === e.dataType),
                        this.fire(new t.Event(`${e.dataType}data`,e))
                    }
                    )),
                    this.on("dataloading", (e=>{
                        this.fire(new t.Event(`${e.dataType}dataloading`,e))
                    }
                    ))
                }
                _getMapId() {
                    return this._mapId
                }
                addControl(e, i) {
                    if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"),
                    !e || !e.onAdd)
                        return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const r = e.onAdd(this);
                    this._controls.push(e);
                    const n = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? n.insertBefore(r, n.firstChild) : n.appendChild(r),
                    this
                }
                removeControl(e) {
                    if (!e || !e.onRemove)
                        return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(e);
                    return i > -1 && this._controls.splice(i, 1),
                    e.onRemove(this),
                    this
                }
                hasControl(t) {
                    return this._controls.indexOf(t) > -1
                }
                getContainer() {
                    return this._container
                }
                getCanvasContainer() {
                    return this._canvasContainer
                }
                getCanvas() {
                    return this._canvas
                }
                resize(e) {
                    if (this._updateContainerDimensions(),
                    this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                        return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight),
                    this.transform.resize(this._containerWidth, this._containerHeight),
                    this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)),
                    this.fire(new t.Event("resize",e)),
                    i && this.fire(new t.Event("moveend",e)),
                    this
                }
                getBounds() {
                    return this.transform.getBounds()
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null
                }
                setMaxBounds(e) {
                    return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),
                    this._update()
                }
                setMinZoom(e) {
                    if ((e = null == e ? -2 : e) >= -2 && e <= this.transform.maxZoom)
                        return this.transform.minZoom = e,
                        this._update(),
                        this.getZoom() < e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                        this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                }
                getMinZoom() {
                    return this.transform.minZoom
                }
                setMaxZoom(e) {
                    if ((e = null == e ? 22 : e) >= this.transform.minZoom)
                        return this.transform.maxZoom = e,
                        this._update(),
                        this.getZoom() > e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                        this;
                    throw new Error("maxZoom must be greater than the current minZoom")
                }
                getMaxZoom() {
                    return this.transform.maxZoom
                }
                setMinPitch(e) {
                    if ((e = null == e ? 0 : e) < 0)
                        throw new Error("minPitch must be greater than or equal to 0");
                    if (e >= 0 && e <= this.transform.maxPitch)
                        return this.transform.minPitch = e,
                        this._update(),
                        this.getPitch() < e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                        this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                }
                getMinPitch() {
                    return this.transform.minPitch
                }
                setMaxPitch(e) {
                    if ((e = null == e ? 85 : e) > 85)
                        throw new Error("maxPitch must be less than or equal to 85");
                    if (e >= this.transform.minPitch)
                        return this.transform.maxPitch = e,
                        this._update(),
                        this.getPitch() > e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                        this;
                    throw new Error("maxPitch must be greater than or equal to minPitch")
                }
                getMaxPitch() {
                    return this.transform.maxPitch
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies
                }
                setRenderWorldCopies(t) {
                    return this.transform.renderWorldCopies = t,
                    this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0),
                    this._update()
                }
                getLanguage() {
                    return this._language
                }
                _parseLanguage(e) {
                    return "auto" === e ? t.window.navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e=>"auto" === e ? t.window.navigator.language : e)) : e
                }
                setLanguage(t) {
                    const e = this._parseLanguage(t);
                    if (!this.style || e === this._language)
                        return this;
                    this._language = e,
                    this.style._reloadSources();
                    for (const t of this._controls)
                        t._setLanguage && t._setLanguage(this._language);
                    return this
                }
                getWorldview() {
                    return this._worldview
                }
                setWorldview(t) {
                    return this.style && t !== this._worldview ? (this._worldview = t,
                    this.style._reloadSources(),
                    this) : this
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [0, 0]
                    } : this.transform.getProjection()
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name
                }
                setProjection(t) {
                    return this._lazyInitEmptyStyle(),
                    t ? "string" == typeof t && (t = {
                        name: t
                    }) : t = null,
                    this._useExplicitProjection = !!t,
                    this._prioritizeAndUpdateProjection(t, this.style.stylesheet ? this.style.stylesheet.projection : null)
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name)
                        return;
                    const e = this.transform
                      , i = e.projection.name;
                    let r;
                    "globe" === i && e.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? (e.setMercatorFromTransition(),
                    r = !0) : "mercator" === i && e.zoom < t.GLOBE_ZOOM_THRESHOLD_MAX && (e.setProjection({
                        name: "globe"
                    }),
                    r = !0),
                    r && (this.style.applyProjectionUpdate(),
                    this.style._forceSymbolLayerUpdate())
                }
                _prioritizeAndUpdateProjection(t, e) {
                    return this._updateProjection(t || e || {
                        name: "mercator"
                    })
                }
                _updateProjection(e) {
                    let i;
                    if (i = "globe" === e.name && this.transform.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e),
                    this.style.applyProjectionUpdate(),
                    i) {
                        this.painter.clearBackgroundTiles();
                        for (const t in this.style._sourceCaches)
                            this.style._sourceCaches[t].clearTiles();
                        this._update(!0),
                        this._forceMarkerAndPopupUpdate(!0)
                    }
                    return this
                }
                project(e) {
                    return this.transform.locationPoint3D(t.LngLat.convert(e))
                }
                unproject(e) {
                    return this.transform.pointLocation3D(t.pointGeometry.convert(e))
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1
                }
                _createDelegatedListener(t, e, i) {
                    if ("mouseenter" === t || "mouseover" === t) {
                        let r = !1;
                        const n = n=>{
                            const o = e.filter((t=>this.getLayer(t)))
                              , s = o.length ? this.queryRenderedFeatures(n.point, {
                                layers: o
                            }) : [];
                            s.length ? r || (r = !0,
                            i.call(this, new on(t,this,n.originalEvent,{
                                features: s
                            }))) : r = !1
                        }
                          , o = ()=>{
                            r = !1
                        }
                        ;
                        return {
                            layers: new Set(e),
                            listener: i,
                            delegates: {
                                mousemove: n,
                                mouseout: o
                            }
                        }
                    }
                    if ("mouseleave" === t || "mouseout" === t) {
                        let r = !1;
                        const n = n=>{
                            const o = e.filter((t=>this.getLayer(t)));
                            (o.length ? this.queryRenderedFeatures(n.point, {
                                layers: o
                            }) : []).length ? r = !0 : r && (r = !1,
                            i.call(this, new on(t,this,n.originalEvent)))
                        }
                          , o = e=>{
                            r && (r = !1,
                            i.call(this, new on(t,this,e.originalEvent)))
                        }
                        ;
                        return {
                            layers: new Set(e),
                            listener: i,
                            delegates: {
                                mousemove: n,
                                mouseout: o
                            }
                        }
                    }
                    {
                        const r = t=>{
                            const r = e.filter((t=>this.getLayer(t)))
                              , n = r.length ? this.queryRenderedFeatures(t.point, {
                                layers: r
                            }) : [];
                            n.length && (t.features = n,
                            i.call(this, t),
                            delete t.features)
                        }
                        ;
                        return {
                            layers: new Set(e),
                            listener: i,
                            delegates: {
                                [t]: r
                            }
                        }
                    }
                }
                on(t, e, i) {
                    if (void 0 === i)
                        return super.on(t, e);
                    Array.isArray(e) || (e = [e]);
                    const r = this._createDelegatedListener(t, e, i);
                    this._delegatedListeners = this._delegatedListeners || {},
                    this._delegatedListeners[t] = this._delegatedListeners[t] || [],
                    this._delegatedListeners[t].push(r);
                    for (const t in r.delegates)
                        this.on(t, r.delegates[t]);
                    return this
                }
                once(t, e, i) {
                    if (void 0 === i)
                        return super.once(t, e);
                    Array.isArray(e) || (e = [e]);
                    const r = this._createDelegatedListener(t, e, i);
                    for (const t in r.delegates)
                        this.once(t, r.delegates[t]);
                    return this
                }
                off(t, e, i) {
                    if (void 0 === i)
                        return super.off(t, e);
                    e = new Set(Array.isArray(e) ? e : [e]);
                    const r = (t,e)=>{
                        if (t.size !== e.size)
                            return !1;
                        for (const i of t)
                            if (!e.has(i))
                                return !1;
                        return !0
                    }
                      , n = this._delegatedListeners ? this._delegatedListeners[t] : void 0;
                    return n && (t=>{
                        for (let n = 0; n < t.length; n++) {
                            const o = t[n];
                            if (o.listener === i && r(o.layers, e)) {
                                for (const t in o.delegates)
                                    this.off(t, o.delegates[t]);
                                return t.splice(n, 1),
                                this
                            }
                        }
                    }
                    )(n),
                    this
                }
                queryRenderedFeatures(e, i) {
                    return this.style ? (void 0 !== i || void 0 === e || e instanceof t.pointGeometry || Array.isArray(e) || (i = e,
                    e = void 0),
                    this.style.queryRenderedFeatures(e = e || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : []
                }
                querySourceFeatures(t, e) {
                    return this.style.querySourceFeatures(t, e)
                }
                setStyle(e, i) {
                    return !1 !== (i = t.extend({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && e ? (this._diffStyle(e, i),
                    this) : (this._localIdeographFontFamily = i.localIdeographFontFamily,
                    this._localFontFamily = i.localFontFamily,
                    this._updateStyle(e, i))
                }
                _getUIString(t) {
                    const e = this._locale[t];
                    if (null == e)
                        throw new Error(`Missing UI string '${t}'`);
                    return e
                }
                _updateStyle(t, e) {
                    return this.style && (this.style.setEventedParent(null),
                    this.style._remove(),
                    this.style = void 0),
                    t && (this.style = new Ke(this,e || {}),
                    this.style.setEventedParent(this, {
                        style: this.style
                    }),
                    "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t)),
                    this._updateTerrain(),
                    this
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Ke(this,{}),
                    this.style.setEventedParent(this, {
                        style: this.style
                    }),
                    this.style.loadEmpty())
                }
                _diffStyle(e, i) {
                    if ("string" == typeof e) {
                        const r = this._requestManager.normalizeStyleURL(e)
                          , n = this._requestManager.transformRequest(r, t.ResourceType.Style);
                        t.getJSON(n, ((e,r)=>{
                            e ? this.fire(new t.ErrorEvent(e)) : r && this._updateDiff(r, i)
                        }
                        ))
                    } else
                        "object" == typeof e && this._updateDiff(e, i)
                }
                _updateDiff(e, i) {
                    try {
                        this.style.setState(e) && this._update(!0)
                    } catch (r) {
                        t.warnOnce(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`),
                        this._updateStyle(e, i)
                    }
                }
                getStyle() {
                    if (this.style)
                        return this.style.serialize()
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (t.warnOnce("There is no style added to the map."),
                    !1)
                }
                addSource(t, e) {
                    return this._lazyInitEmptyStyle(),
                    this.style.addSource(t, e),
                    this._update(!0)
                }
                isSourceLoaded(t) {
                    return !!this.style && this.style._isSourceCacheLoaded(t)
                }
                areTilesLoaded() {
                    const t = this.style && this.style._sourceCaches;
                    for (const e in t) {
                        const i = t[e]._tiles;
                        for (const t in i) {
                            const e = i[t];
                            if ("loaded" !== e.state && "errored" !== e.state)
                                return !1
                        }
                    }
                    return !0
                }
                addSourceType(t, e, i) {
                    this._lazyInitEmptyStyle(),
                    this.style.addSourceType(t, e, i)
                }
                removeSource(t) {
                    return this.style.removeSource(t),
                    this._updateTerrain(),
                    this._update(!0)
                }
                getSource(t) {
                    return this.style.getSource(t)
                }
                addImage(e, i, {pixelRatio: r=1, sdf: n=!1, stretchX: o, stretchY: s, content: a}={}) {
                    if (this._lazyInitEmptyStyle(),
                    i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap) {
                        const {width: l, height: c, data: u} = t.exported.getImageData(i);
                        this.style.addImage(e, {
                            data: new t.RGBAImage({
                                width: l,
                                height: c
                            },u),
                            pixelRatio: r,
                            stretchX: o,
                            stretchY: s,
                            content: a,
                            sdf: n,
                            version: 0
                        })
                    } else if (void 0 === i.width || void 0 === i.height)
                        this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const {width: l, height: c} = i
                          , u = i;
                        this.style.addImage(e, {
                            data: new t.RGBAImage({
                                width: l,
                                height: c
                            },new Uint8Array(u.data)),
                            pixelRatio: r,
                            stretchX: o,
                            stretchY: s,
                            content: a,
                            sdf: n,
                            version: 0,
                            userImage: u
                        }),
                        u.onAdd && u.onAdd(this, e)
                    }
                }
                updateImage(e, i) {
                    const r = this.style.getImage(e);
                    if (!r)
                        return void this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const n = i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap ? t.exported.getImageData(i) : i
                      , {width: o, height: s} = n;
                    void 0 !== o && void 0 !== s ? o === r.data.width && s === r.data.height ? (r.data.replace(n.data, !(i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap)),
                    this.style.updateImage(e, r)) : this.fire(new t.ErrorEvent(new Error(`The width and height of the updated image (${o}, ${s})\n                must be that same as the previous version of the image\n                (${r.data.width}, ${r.data.height})`))) : this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")))
                }
                hasImage(e) {
                    return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))),
                    !1)
                }
                removeImage(t) {
                    this.style.removeImage(t)
                }
                loadImage(e, i) {
                    t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), ((e,r)=>{
                        i(e, r instanceof t.window.HTMLImageElement ? t.exported.getImageData(r) : r)
                    }
                    ))
                }
                listImages() {
                    return this.style.listImages()
                }
                addLayer(t, e) {
                    return this._lazyInitEmptyStyle(),
                    this.style.addLayer(t, e),
                    this._update(!0)
                }
                moveLayer(t, e) {
                    return this.style.moveLayer(t, e),
                    this._update(!0)
                }
                removeLayer(t) {
                    return this.style.removeLayer(t),
                    this._update(!0)
                }
                getLayer(t) {
                    return this.style.getLayer(t)
                }
                setLayerZoomRange(t, e, i) {
                    return this.style.setLayerZoomRange(t, e, i),
                    this._update(!0)
                }
                setFilter(t, e, i={}) {
                    return this.style.setFilter(t, e, i),
                    this._update(!0)
                }
                getFilter(t) {
                    return this.style.getFilter(t)
                }
                setPaintProperty(t, e, i, r={}) {
                    return this.style.setPaintProperty(t, e, i, r),
                    this._update(!0)
                }
                getPaintProperty(t, e) {
                    return this.style.getPaintProperty(t, e)
                }
                setLayoutProperty(t, e, i, r={}) {
                    return this.style.setLayoutProperty(t, e, i, r),
                    this._update(!0)
                }
                getLayoutProperty(t, e) {
                    return this.style.getLayoutProperty(t, e)
                }
                setLight(t, e={}) {
                    return this._lazyInitEmptyStyle(),
                    this.style.setLight(t, e),
                    this._update(!0)
                }
                getLight() {
                    return this.style.getLight()
                }
                setTerrain(t) {
                    return this._lazyInitEmptyStyle(),
                    !t && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(t),
                    this._averageElevationLastSampledAt = -1 / 0,
                    this._update(!0)
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null
                }
                setFog(t) {
                    return this._lazyInitEmptyStyle(),
                    this.style.setFog(t),
                    this._update(!0)
                }
                getFog() {
                    return this.style ? this.style.getFog() : null
                }
                _queryFogOpacity(e) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(t.LngLat.convert(e), this.transform) : 0
                }
                setFeatureState(t, e) {
                    return this.style.setFeatureState(t, e),
                    this._update()
                }
                removeFeatureState(t, e) {
                    return this.style.removeFeatureState(t, e),
                    this._update()
                }
                getFeatureState(t) {
                    return this.style.getFeatureState(t)
                }
                _updateContainerDimensions() {
                    if (!this._container)
                        return;
                    const e = this._container.getBoundingClientRect().width || 400
                      , i = this._container.getBoundingClientRect().height || 300;
                    let r, n, o, s = this._container;
                    for (; s && (!n || !o); ) {
                        const e = t.window.getComputedStyle(s).transform;
                        e && "none" !== e && (r = e.match(/matrix.*\((.+)\)/)[1].split(", "),
                        r[0] && "0" !== r[0] && "1" !== r[0] && (n = r[0]),
                        r[3] && "0" !== r[3] && "1" !== r[3] && (o = r[3])),
                        s = s.parentElement
                    }
                    this._containerWidth = n ? Math.abs(e / n) : e,
                    this._containerHeight = o ? Math.abs(i / o) : i
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                }
                _setupContainer() {
                    const t = this._container;
                    t.classList.add("mapboxgl-map"),
                    (this._missingCSSCanary = o("div", "mapboxgl-canary", t)).style.visibility = "hidden",
                    this._detectMissingCSS();
                    const e = this._canvasContainer = o("div", "mapboxgl-canvas-container", t);
                    this._interactive && e.classList.add("mapboxgl-interactive"),
                    this._canvas = o("canvas", "mapboxgl-canvas", e),
                    this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                    this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                    this._canvas.setAttribute("tabindex", "0"),
                    this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                    this._canvas.setAttribute("role", "region"),
                    this._updateContainerDimensions(),
                    this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = o("div", "mapboxgl-control-container", t)
                      , r = this._controlPositions = {};
                    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t=>{
                        r[t] = o("div", `mapboxgl-ctrl-${t}`, i)
                    }
                    )),
                    this._container.addEventListener("scroll", this._onMapScroll, !1)
                }
                _resizeCanvas(e, i) {
                    const r = t.exported.devicePixelRatio || 1;
                    this._canvas.width = r * Math.ceil(e),
                    this._canvas.height = r * Math.ceil(i),
                    this._canvas.style.width = `${e}px`,
                    this._canvas.style.height = `${i}px`
                }
                _addMarker(t) {
                    this._markers.push(t)
                }
                _removeMarker(t) {
                    const e = this._markers.indexOf(t);
                    -1 !== e && this._markers.splice(e, 1)
                }
                _addPopup(t) {
                    this._popups.push(t)
                }
                _removePopup(t) {
                    const e = this._popups.indexOf(t);
                    -1 !== e && this._popups.splice(e, 1)
                }
                _setupPainter() {
                    const e = t.extend({}, i.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    })
                      , r = this._canvas.getContext("webgl", e) || this._canvas.getContext("experimental-webgl", e);
                    r ? (t.storeAuthState(r, !0),
                    this.painter = new Pr(r,this.transform),
                    this.on("data", (t=>{
                        "source" === t.dataType && this.painter.setTileLoadedFlag(!0)
                    }
                    )),
                    t.exported$1.testSupport(r)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")))
                }
                _contextLost(e) {
                    e.preventDefault(),
                    this._frame && (this._frame.cancel(),
                    this._frame = null),
                    this.fire(new t.Event("webglcontextlost",{
                        originalEvent: e
                    }))
                }
                _contextRestored(e) {
                    this._setupPainter(),
                    this.resize(),
                    this._update(),
                    this.fire(new t.Event("webglcontextrestored",{
                        originalEvent: e
                    }))
                }
                _onMapScroll(t) {
                    if (t.target === this._container)
                        return this._container.scrollTop = 0,
                        this._container.scrollLeft = 0,
                        !1
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                }
                _update(t) {
                    return this.style ? (this._styleDirty = this._styleDirty || t,
                    this._sourcesDirty = !0,
                    this.triggerRepaint(),
                    this) : this
                }
                _requestRenderFrame(t) {
                    return this._update(),
                    this._renderTaskQueue.add(t)
                }
                _cancelRenderFrame(t) {
                    this._renderTaskQueue.remove(t)
                }
                _requestDomTask(t) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? t() : this._domRenderTaskQueue.add(t)
                }
                _render(e) {
                    let i;
                    const r = this.painter.context.extTimerQuery
                      , n = t.exported.now();
                    if (this.listens("gpu-timing-frame") && (i = r.createQueryEXT(),
                    r.beginQueryEXT(r.TIME_ELAPSED_EXT, i)),
                    this.painter.context.setDirty(),
                    this.painter.setBaseState(),
                    (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], t.window.performance.now()),
                    this._interactionRange[1] = Math.max(this._interactionRange[1], t.window.performance.now())),
                    this._renderTaskQueue.run(e),
                    this._domRenderTaskQueue.run(e),
                    this._removed)
                        return;
                    this._updateProjectionTransition();
                    const o = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const e = this.transform.zoom
                          , i = this.transform.pitch
                          , r = t.exported.now()
                          , n = new t.EvaluationParameters(e,{
                            now: r,
                            fadeDuration: o,
                            pitch: i,
                            transition: this.style.getTransition()
                        });
                        this.style.update(n)
                    }
                    this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0,
                    this._sourcesDirty = !0);
                    let s = !1;
                    if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1,
                    this.painter._updateFog(this.style),
                    this._updateTerrain(),
                    s = this._updateAverageElevation(n),
                    this.style._updateSources(this.transform),
                    this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(n),
                    this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, o, this._crossSourceCollisions),
                    this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showTerrainWireframe: this.showTerrainWireframe,
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: o,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }),
                    this.fire(new t.Event("render")),
                    this.loaded() && !this._loaded && (this._loaded = !0,
                    this.fire(new t.Event("load"))),
                    this.style && this.style.hasTransitions() && (this._styleDirty = !0),
                    this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(),
                    i) {
                        const e = t.exported.now() - n;
                        r.endQueryEXT(r.TIME_ELAPSED_EXT, i),
                        setTimeout((()=>{
                            const o = r.getQueryObjectEXT(i, r.QUERY_RESULT_EXT) / 1e6;
                            r.deleteQueryEXT(i),
                            this.fire(new t.Event("gpu-timing-frame",{
                                cpuTime: e,
                                gpuTime: o
                            })),
                            t.window.performance.mark("frame-gpu", {
                                startTime: n,
                                detail: {
                                    gpuTime: o
                                }
                            })
                        }
                        ), 50)
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const e = this.painter.collectGpuTimers();
                        setTimeout((()=>{
                            const i = this.painter.queryGpuTimers(e);
                            this.fire(new t.Event("gpu-timing-layer",{
                                layerTimes: i
                            }))
                        }
                        ), 50)
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const e = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout((()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(e);
                            this.fire(new t.Event("gpu-timing-deferred-render",{
                                gpuTime: i
                            }))
                        }
                        ), 50)
                    }
                    const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
                    if (a || this._repaint)
                        this.triggerRepaint();
                    else {
                        const e = !this.isMoving() && this.loaded();
                        if (e && (s = this._updateAverageElevation(n, !0)),
                        s)
                            this.triggerRepaint();
                        else if (this._triggerFrame(!1),
                        e && (this.fire(new t.Event("idle")),
                        this._isInitialLoad = !1,
                        this.speedIndexTiming)) {
                            const e = this._calculateSpeedIndex();
                            this.fire(new t.Event("speedindexcompleted",{
                                speedIndex: e
                            })),
                            this.speedIndexTiming = !1
                        }
                    }
                    !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0,
                    t.LivePerformanceUtils.mark(t.PerformanceMarkers.fullLoad),
                    this._performanceMetricsCollection && t.postPerformanceEvent(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }),
                    this._authenticate())
                }
                _forceMarkerAndPopupUpdate(t) {
                    for (const e of this._markers)
                        t && !this.getRenderWorldCopies() && (e._lngLat = e._lngLat.wrap()),
                        e._update();
                    for (const e of this._popups)
                        !t || this.getRenderWorldCopies() || e._trackPointer || (e._lngLat = e._lngLat.wrap()),
                        e._update()
                }
                _updateAverageElevation(t, e=!1) {
                    const i = t=>(this.transform.averageElevation = t,
                    this._update(!1),
                    !0);
                    if (!this.painter.averageElevationNeedsEasing())
                        return 0 !== this.transform.averageElevation && i(0);
                    if ((e || t - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(t)) {
                        const e = this.transform.averageElevation;
                        let r = this.transform.sampleAverageElevation()
                          , n = !1;
                        this.transform.elevation && (n = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration,
                        this._averageElevationExaggeration = this.transform.elevation.exaggeration()),
                        isNaN(r) ? r = 0 : this._averageElevationLastSampledAt = t;
                        const o = Math.abs(e - r);
                        if (o > 1) {
                            if (this._isInitialLoad || n)
                                return this._averageElevation.jumpTo(r),
                                i(r);
                            this._averageElevation.easeTo(r, t, 300)
                        } else if (o > 1e-4)
                            return this._averageElevation.jumpTo(r),
                            i(r)
                    }
                    return !!this._averageElevation.isEasing(t) && i(this._averageElevation.getValue(t))
                }
                _authenticate() {
                    t.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e=>{
                        if (e && (e.message === t.AUTH_ERR_MSG || 401 === e.status)) {
                            const e = this.painter.context.gl;
                            t.storeAuthState(e, !1),
                            this._logoControl instanceof $n && this._logoControl._updateLogo(),
                            e && e.clear(e.DEPTH_BUFFER_BIT | e.COLOR_BUFFER_BIT | e.STENCIL_BUFFER_BIT),
                            this._silenceAuthErrors || this.fire(new t.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                        }
                    }
                    )),
                    t.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (()=>{}
                    ))
                }
                _updateTerrain() {
                    const t = this._isDragging();
                    this.painter.updateTerrain(this.style, t)
                }
                _calculateSpeedIndex() {
                    const t = this.painter.canvasCopy()
                      , e = this.painter.getCanvasCopiesAndTimestamps();
                    e.timeStamps.push(performance.now());
                    const i = this.painter.context.gl
                      , r = i.createFramebuffer();
                    function n(t) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t, 0);
                        const e = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, e),
                        e
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, r),
                    this._canvasPixelComparison(n(t), e.canvasCopies.map(n), e.timeStamps)
                }
                _canvasPixelComparison(t, e, i) {
                    let r = i[1] - i[0];
                    const n = t.length / 4;
                    for (let o = 0; o < e.length; o++) {
                        const s = e[o];
                        let a = 0;
                        for (let e = 0; e < s.length; e += 4)
                            s[e] === t[e] && s[e + 1] === t[e + 1] && s[e + 2] === t[e + 2] && s[e + 3] === t[e + 3] && (a += 1);
                        r += (i[o + 2] - i[o + 1]) * (1 - a / n)
                    }
                    return r
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const t of this._controls)
                        t.onRemove(this);
                    this._controls = [],
                    this._frame && (this._frame.cancel(),
                    this._frame = null),
                    this._renderTaskQueue.clear(),
                    this._domRenderTaskQueue.clear(),
                    this.style && this.style.destroy(),
                    this.painter.destroy(),
                    this.handlers && this.handlers.destroy(),
                    this.handlers = void 0,
                    this.setStyle(null),
                    void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1),
                    t.window.removeEventListener("orientationchange", this._onWindowResize, !1),
                    t.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                    t.window.removeEventListener("online", this._onWindowOnline, !1),
                    t.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                    const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    e && e.loseContext(),
                    this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                    this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                    this._canvasContainer.remove(),
                    this._controlContainer.remove(),
                    this._missingCSSCanary.remove(),
                    this._canvas = void 0,
                    this._canvasContainer = void 0,
                    this._controlContainer = void 0,
                    this._missingCSSCanary = void 0,
                    this._container.classList.remove("mapboxgl-map"),
                    this._container.removeEventListener("scroll", this._onMapScroll, !1),
                    t.removeAuthState(this.painter.context.gl),
                    this._removed = !0,
                    this.fire(new t.Event("remove"))
                }
                triggerRepaint() {
                    this._triggerFrame(!0)
                }
                _triggerFrame(e) {
                    this._renderNextFrame = this._renderNextFrame || e,
                    this.style && !this._frame && (this._frame = t.exported.frame((t=>{
                        const e = !!this._renderNextFrame;
                        this._frame = null,
                        this._renderNextFrame = null,
                        e && this._render(t)
                    }
                    )))
                }
                _preloadTiles(e) {
                    const i = this.style ? Object.values(this.style._sourceCaches) : [];
                    return t.asyncAll(i, ((t,i)=>t._preloadTiles(e, i)), (()=>{
                        this.triggerRepaint()
                    }
                    )),
                    this
                }
                _onWindowOnline() {
                    this._update()
                }
                _onWindowResize(t) {
                    this._trackResize && this.resize({
                        originalEvent: t
                    })._update()
                }
                _onVisibilityChange() {
                    "hidden" === t.window.document.visibilityState && this._visibilityHidden++
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries
                }
                set showTileBoundaries(t) {
                    this._showTileBoundaries !== t && (this._showTileBoundaries = t,
                    this._update())
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe
                }
                set showTerrainWireframe(t) {
                    this._showTerrainWireframe !== t && (this._showTerrainWireframe = t,
                    this._update())
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming
                }
                set speedIndexTiming(t) {
                    this._speedIndexTiming !== t && (this._speedIndexTiming = t,
                    this._update())
                }
                get showPadding() {
                    return !!this._showPadding
                }
                set showPadding(t) {
                    this._showPadding !== t && (this._showPadding = t,
                    this._update())
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes
                }
                set showCollisionBoxes(t) {
                    this._showCollisionBoxes !== t && (this._showCollisionBoxes = t,
                    t ? this.style._generateCollisionBoxes() : this._update())
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector
                }
                set showOverdrawInspector(t) {
                    this._showOverdrawInspector !== t && (this._showOverdrawInspector = t,
                    this._update())
                }
                get repaint() {
                    return !!this._repaint
                }
                set repaint(t) {
                    this._repaint !== t && (this._repaint = t,
                    this.triggerRepaint())
                }
                get vertices() {
                    return !!this._vertices
                }
                set vertices(t) {
                    this._vertices = t,
                    this._update()
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs
                }
                set showTileAABBs(t) {
                    this._showTileAABBs !== t && (this._showTileAABBs = t,
                    t && this._update())
                }
                _setCacheLimits(e, i) {
                    t.setCacheLimits(e, i)
                }
                get version() {
                    return t.version
                }
            }
            ,
            NavigationControl: class {
                constructor(e) {
                    this.options = t.extend({}, oo, e),
                    this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                    this._container.addEventListener("contextmenu", (t=>t.preventDefault())),
                    this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this),
                    this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: t
                        })
                    }
                    )),
                    o("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                    this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: t
                        })
                    }
                    )),
                    o("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                    this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this),
                    this._compass = this._createButton("mapboxgl-ctrl-compass", (t=>{
                        const e = this._map;
                        e && (this.options.visualizePitch ? e.resetNorthPitch({}, {
                            originalEvent: t
                        }) : e.resetNorth({}, {
                            originalEvent: t
                        }))
                    }
                    )),
                    this._compassIcon = o("span", "mapboxgl-ctrl-icon", this._compass),
                    this._compassIcon.setAttribute("aria-hidden", "true"))
                }
                _updateZoomButtons() {
                    const t = this._map;
                    if (!t)
                        return;
                    const e = t.getZoom()
                      , i = e === t.getMaxZoom()
                      , r = e === t.getMinZoom();
                    this._zoomInButton.disabled = i,
                    this._zoomOutButton.disabled = r,
                    this._zoomInButton.setAttribute("aria-disabled", i.toString()),
                    this._zoomOutButton.setAttribute("aria-disabled", r.toString())
                }
                _rotateCompassArrow() {
                    const t = this._map;
                    if (!t)
                        return;
                    const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(t.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${t.transform.pitch}deg) rotateZ(${t.transform.angle * (180 / Math.PI)}deg)` : `rotate(${t.transform.angle * (180 / Math.PI)}deg)`;
                    t._requestDomTask((()=>{
                        this._compassIcon && (this._compassIcon.style.transform = e)
                    }
                    ))
                }
                onAdd(t) {
                    return this._map = t,
                    this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                    this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                    t.on("zoom", this._updateZoomButtons),
                    this._updateZoomButtons()),
                    this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                    this.options.visualizePitch && t.on("pitch", this._rotateCompassArrow),
                    t.on("rotate", this._rotateCompassArrow),
                    this._rotateCompassArrow(),
                    this._handler = new so(t,this._compass,this.options.visualizePitch)),
                    this._container
                }
                onRemove() {
                    const t = this._map;
                    t && (this._container.remove(),
                    this.options.showZoom && t.off("zoom", this._updateZoomButtons),
                    this.options.showCompass && (this.options.visualizePitch && t.off("pitch", this._rotateCompassArrow),
                    t.off("rotate", this._rotateCompassArrow),
                    this._handler && this._handler.off(),
                    this._handler = void 0),
                    this._map = void 0)
                }
                _createButton(t, e) {
                    const i = o("button", t, this._container);
                    return i.type = "button",
                    i.addEventListener("click", e),
                    i
                }
                _setButtonTitle(t, e) {
                    if (!this._map)
                        return;
                    const i = this._map._getUIString(`NavigationControl.${e}`);
                    t.setAttribute("aria-label", i),
                    t.firstElementChild && t.firstElementChild.setAttribute("title", i)
                }
            }
            ,
            GeolocateControl: class extends t.Evented {
                constructor(e) {
                    super(),
                    this.options = t.extend({
                        geolocation: t.window.navigator.geolocation
                    }, ao, e),
                    t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this),
                    this._updateMarkerRotationThrottled = qr(this._updateMarkerRotation, 20),
                    this._numberOfWatches = 0
                }
                onAdd(t) {
                    return this._map = t,
                    this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                    this._checkGeolocationSupport(this._setupUI),
                    this._container
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID),
                    this._geolocationWatchID = void 0),
                    this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                    this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                    this._container.remove(),
                    this._map.off("zoom", this._onZoom),
                    this._map = void 0,
                    this._numberOfWatches = 0,
                    this._noTimeout = !1
                }
                _checkGeolocationSupport(e) {
                    const i = (t=!!this.options.geolocation)=>{
                        this._supportsGeolocation = t,
                        e(t)
                    }
                    ;
                    void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({
                        name: "geolocation"
                    }).then((t=>i("denied" !== t.state))).catch((()=>i())) : i()
                }
                _isOutOfMapMaxBounds(t) {
                    const e = this._map.getMaxBounds()
                      , i = t.coords;
                    return !!e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
                }
                _setErrorState() {
                    switch (this._watchState) {
                    case "WAITING_ACTIVE":
                        this._watchState = "ACTIVE_ERROR",
                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                        break;
                    case "ACTIVE_LOCK":
                        this._watchState = "ACTIVE_ERROR",
                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),
                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                        break;
                    case "BACKGROUND":
                        this._watchState = "BACKGROUND_ERROR",
                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),
                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                    }
                }
                _onSuccess(e) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(e))
                            return this._setErrorState(),
                            this.fire(new t.Event("outofmaxbounds",e)),
                            this._updateMarker(),
                            void this._finish();
                        if (this.options.trackUserLocation)
                            switch (this._lastKnownPosition = e,
                            this._watchState) {
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                            }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e),
                        this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e),
                        this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),
                        this.fire(new t.Event("geolocate",e)),
                        this._finish()
                    }
                }
                _updateCamera(e) {
                    const i = new t.LngLat(e.coords.longitude,e.coords.latitude)
                      , r = e.coords.accuracy
                      , n = this._map.getBearing()
                      , o = t.extend({
                        bearing: n
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(r), o, {
                        geolocateSource: !0
                    })
                }
                _updateMarker(e) {
                    if (e) {
                        const i = new t.LngLat(e.coords.longitude,e.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                        this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                        this._accuracy = e.coords.accuracy,
                        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                    } else
                        this._userLocationDotMarker.remove(),
                        this._accuracyCircleMarker.remove()
                }
                _updateCircleRadius() {
                    const e = this._map.transform
                      , i = t.mercatorZfromAltitude(1, e._center.lat) * e.worldSize
                      , r = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${r}px`,
                    this._circleElement.style.height = `${r}px`
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading),
                    this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"),
                    this._userLocationDotMarker.setRotation(0))
                }
                _onError(e) {
                    if (this._map) {
                        if (this.options.trackUserLocation)
                            if (1 === e.code) {
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                this._geolocateButton.disabled = !0;
                                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", t),
                                this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t),
                                void 0 !== this._geolocationWatchID && this._clearWatch()
                            } else {
                                if (3 === e.code && this._noTimeout)
                                    return;
                                this._setErrorState()
                            }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),
                        this.fire(new t.Event("error",e)),
                        this._finish()
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId),
                    this._timeoutId = void 0
                }
                _setupUI(e) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (t=>t.preventDefault())),
                        this._geolocateButton = o("button", "mapboxgl-ctrl-geolocate", this._container),
                        o("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                        this._geolocateButton.type = "button",
                        !1 === e) {
                            t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0,
                            this._geolocateButton.setAttribute("aria-label", e),
                            this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e)
                        } else {
                            const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", t),
                            this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this._watchState = "OFF"),
                        this.options.showUserLocation && (this._dotElement = o("div", "mapboxgl-user-location"),
                        this._dotElement.appendChild(o("div", "mapboxgl-user-location-dot")),
                        this._dotElement.appendChild(o("div", "mapboxgl-user-location-heading")),
                        this._userLocationDotMarker = new Kn({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }),
                        this._circleElement = o("div", "mapboxgl-user-location-accuracy-circle"),
                        this._accuracyCircleMarker = new Kn({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }),
                        this.options.trackUserLocation && (this._watchState = "OFF"),
                        this._map.on("zoom", this._onZoom)),
                        this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                        this._setup = !0,
                        this.options.trackUserLocation && this._map.on("movestart", (e=>{
                            e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e.originalEvent && "resize" === e.originalEvent.type || (this._watchState = "BACKGROUND",
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                            this.fire(new t.Event("trackuserlocationend")))
                        }
                        ))
                    }
                }
                _onDeviceOrientation(t) {
                    this._userLocationDotMarker && (t.webkitCompassHeading ? this._heading = t.webkitCompassHeading : !0 === t.absolute && (this._heading = -1 * t.alpha),
                    this._updateMarkerRotationThrottled())
                }
                trigger() {
                    if (!this._setup)
                        return t.warnOnce("Geolocate control triggered before added to a map"),
                        !1;
                    if (this.options.trackUserLocation) {
                        switch (this._watchState) {
                        case "OFF":
                            this._watchState = "WAITING_ACTIVE",
                            this.fire(new t.Event("trackuserlocationstart"));
                            break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                            this._numberOfWatches--,
                            this._noTimeout = !1,
                            this._watchState = "OFF",
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                            this.fire(new t.Event("trackuserlocationend"));
                            break;
                        case "BACKGROUND":
                            this._watchState = "ACTIVE_LOCK",
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                            this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                            this.fire(new t.Event("trackuserlocationstart"))
                        }
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                            break;
                        case "ACTIVE_LOCK":
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                            break;
                        case "ACTIVE_ERROR":
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "BACKGROUND":
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                            break;
                        case "BACKGROUND_ERROR":
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                            this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let t;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.setAttribute("aria-pressed", "true"),
                            this._numberOfWatches++,
                            this._numberOfWatches > 1 ? (t = {
                                maximumAge: 6e5,
                                timeout: 0
                            },
                            this._noTimeout = !0) : (t = this.options.positionOptions,
                            this._noTimeout = !1),
                            this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, t),
                            this.options.showUserHeading && this._addDeviceOrientationListener()
                        }
                    } else
                        this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                        this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0
                }
                _addDeviceOrientationListener() {
                    const e = ()=>{
                        t.window.addEventListener("ondeviceorientationabsolute"in t.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation)
                    }
                    ;
                    void 0 !== t.window.DeviceMotionEvent && "function" == typeof t.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t=>{
                        "granted" === t && e()
                    }
                    )).catch(console.error) : e()
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID),
                    t.window.removeEventListener("deviceorientation", this._onDeviceOrientation),
                    t.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation),
                    this._geolocationWatchID = void 0,
                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                    this._geolocateButton.setAttribute("aria-pressed", "false"),
                    this.options.showUserLocation && this._updateMarker(null)
                }
            }
            ,
            AttributionControl: qn,
            ScaleControl: class {
                constructor(e) {
                    this.options = t.extend({}, lo, e),
                    function() {
                        try {
                            return new Intl.NumberFormat("en",{
                                style: "unit",
                                unitDisplay: "narrow",
                                unit: "meter"
                            }),
                            !0
                        } catch (t) {
                            return !1
                        }
                    }() || (this._setScale = co.bind(this)),
                    t.bindAll(["_update", "_setScale", "setUnit"], this)
                }
                getDefaultPosition() {
                    return "bottom-left"
                }
                _update() {
                    const t = this.options.maxWidth || 100
                      , e = this._map
                      , i = e._containerHeight / 2
                      , r = e._containerWidth / 2 - t / 2
                      , n = e.unproject([r, i])
                      , o = e.unproject([r + t, i])
                      , s = n.distanceTo(o);
                    if ("imperial" === this.options.unit) {
                        const e = 3.2808 * s;
                        e > 5280 ? this._setScale(t, e / 5280, "mile") : this._setScale(t, e, "foot")
                    } else
                        "nautical" === this.options.unit ? this._setScale(t, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(t, s / 1e3, "kilometer") : this._setScale(t, s, "meter")
                }
                _setScale(t, e, i) {
                    const r = uo(e)
                      , n = r / e;
                    this._map._requestDomTask((()=>{
                        this._container.style.width = t * n + "px",
                        this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language,{
                            style: "unit",
                            unitDisplay: "narrow",
                            unit: i
                        }).format(r) : `${r}&nbsp;nm`
                    }
                    ))
                }
                onAdd(t) {
                    return this._map = t,
                    this._language = t.getLanguage(),
                    this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()),
                    this._container.dir = "auto",
                    this._map.on("move", this._update),
                    this._update(),
                    this._container
                }
                onRemove() {
                    this._container.remove(),
                    this._map.off("move", this._update),
                    this._map = void 0
                }
                _setLanguage(t) {
                    this._language = t,
                    this._update()
                }
                setUnit(t) {
                    this.options.unit = t,
                    this._update()
                }
            }
            ,
            FullscreenControl: class {
                constructor(e) {
                    this._fullscreen = !1,
                    e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control 'container' must be a DOM element.")),
                    t.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                    "onfullscreenchange"in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange"in t.window.document && (this._fullscreenchange = "webkitfullscreenchange")
                }
                onAdd(e) {
                    return this._map = e,
                    this._container || (this._container = this._map.getContainer()),
                    this._controlContainer = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                    this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none",
                    t.warnOnce("This device does not support fullscreen mode.")),
                    this._controlContainer
                }
                onRemove() {
                    this._controlContainer.remove(),
                    this._map = null,
                    t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon)
                }
                _checkFullscreenSupport() {
                    return !(!t.window.document.fullscreenEnabled && !t.window.document.webkitFullscreenEnabled)
                }
                _setupUI() {
                    const e = this._fullscreenButton = o("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    o("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"),
                    e.type = "button",
                    this._updateTitle(),
                    this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                    t.window.document.addEventListener(this._fullscreenchange, this._changeIcon)
                }
                _updateTitle() {
                    const t = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", t),
                    this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", t)
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                }
                _isFullscreen() {
                    return this._fullscreen
                }
                _changeIcon() {
                    (t.window.document.fullscreenElement || t.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen,
                    this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),
                    this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),
                    this._updateTitle())
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                }
            }
            ,
            Popup: class extends t.Evented {
                constructor(e) {
                    super(),
                    this.options = t.extend(Object.create(Qn), e),
                    t.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this),
                    this._classList = new Set(e && e.className ? e.className.trim().split(/\s+/) : [])
                }
                addTo(e) {
                    return this._map && this.remove(),
                    this._map = e,
                    this.options.closeOnClick && e.on("preclick", this._onClose),
                    this.options.closeOnMove && e.on("move", this._onClose),
                    e.on("remove", this.remove),
                    this._update(),
                    e._addPopup(this),
                    this._focusFirstElement(),
                    this._trackPointer ? (e.on("mousemove", this._onMouseEvent),
                    e.on("mouseup", this._onMouseEvent),
                    e._canvasContainer.classList.add("mapboxgl-track-pointer")) : e.on("move", this._update),
                    this.fire(new t.Event("open")),
                    this
                }
                isOpen() {
                    return !!this._map
                }
                remove() {
                    this._content && this._content.remove(),
                    this._container && (this._container.remove(),
                    this._container = void 0);
                    const e = this._map;
                    return e && (e.off("move", this._update),
                    e.off("move", this._onClose),
                    e.off("preclick", this._onClose),
                    e.off("click", this._onClose),
                    e.off("remove", this.remove),
                    e.off("mousemove", this._onMouseEvent),
                    e.off("mouseup", this._onMouseEvent),
                    e.off("drag", this._onMouseEvent),
                    e._canvasContainer && e._canvasContainer.classList.remove("mapboxgl-track-pointer"),
                    e._removePopup(this),
                    this._map = void 0),
                    this.fire(new t.Event("close")),
                    this
                }
                getLngLat() {
                    return this._lngLat
                }
                setLngLat(e) {
                    this._lngLat = t.LngLat.convert(e),
                    this._pos = null,
                    this._trackPointer = !1,
                    this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update),
                    i.off("mousemove", this._onMouseEvent),
                    i._canvasContainer.classList.remove("mapboxgl-track-pointer")),
                    this
                }
                trackPointer() {
                    this._trackPointer = !0,
                    this._pos = null,
                    this._update();
                    const t = this._map;
                    return t && (t.off("move", this._update),
                    t.on("mousemove", this._onMouseEvent),
                    t.on("drag", this._onMouseEvent),
                    t._canvasContainer.classList.add("mapboxgl-track-pointer")),
                    this
                }
                getElement() {
                    return this._container
                }
                setText(e) {
                    return this.setDOMContent(t.window.document.createTextNode(e))
                }
                setHTML(e) {
                    const i = t.window.document.createDocumentFragment()
                      , r = t.window.document.createElement("body");
                    let n;
                    for (r.innerHTML = e; n = r.firstChild,
                    n; )
                        i.appendChild(n);
                    return this.setDOMContent(i)
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth
                }
                setMaxWidth(t) {
                    return this.options.maxWidth = t,
                    this._update(),
                    this
                }
                setDOMContent(t) {
                    let e = this._content;
                    if (e)
                        for (; e.hasChildNodes(); )
                            e.firstChild && e.removeChild(e.firstChild);
                    else
                        e = this._content = o("div", "mapboxgl-popup-content", this._container || void 0);
                    if (e.appendChild(t),
                    this.options.closeButton) {
                        const t = this._closeButton = o("button", "mapboxgl-popup-close-button", e);
                        t.type = "button",
                        t.setAttribute("aria-label", "Close popup"),
                        t.setAttribute("aria-hidden", "true"),
                        t.innerHTML = "&#215;",
                        t.addEventListener("click", this._onClose)
                    }
                    return this._update(),
                    this._focusFirstElement(),
                    this
                }
                addClassName(t) {
                    return this._classList.add(t),
                    this._updateClassList(),
                    this
                }
                removeClassName(t) {
                    return this._classList.delete(t),
                    this._updateClassList(),
                    this
                }
                setOffset(t) {
                    return this.options.offset = t,
                    this._update(),
                    this
                }
                toggleClassName(t) {
                    let e;
                    return this._classList.delete(t) ? e = !1 : (this._classList.add(t),
                    e = !0),
                    this._updateClassList(),
                    e
                }
                _onMouseEvent(t) {
                    this._update(t.point)
                }
                _getAnchor(t) {
                    if (this.options.anchor)
                        return this.options.anchor;
                    const e = this._map
                      , i = this._container
                      , r = this._pos;
                    if (!e || !i || !r)
                        return "bottom";
                    const n = i.offsetWidth
                      , o = i.offsetHeight
                      , s = r.x < n / 2
                      , a = r.x > e.transform.width - n / 2;
                    if (r.y + t < o)
                        return s ? "top-left" : a ? "top-right" : "top";
                    if (r.y > e.transform.height - o) {
                        if (s)
                            return "bottom-left";
                        if (a)
                            return "bottom-right"
                    }
                    return s ? "left" : a ? "right" : "bottom"
                }
                _updateClassList() {
                    const t = this._container;
                    if (!t)
                        return;
                    const e = [...this._classList];
                    e.push("mapboxgl-popup"),
                    this._anchor && e.push(`mapboxgl-popup-anchor-${this._anchor}`),
                    this._trackPointer && e.push("mapboxgl-popup-track-pointer"),
                    t.className = e.join(" ")
                }
                _update(e) {
                    const i = this._map
                      , r = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !r)
                        return;
                    let n = this._container;
                    if (n || (n = this._container = o("div", "mapboxgl-popup", i.getContainer()),
                    this._tip = o("div", "mapboxgl-popup-tip", n),
                    n.appendChild(r)),
                    this.options.maxWidth && n.style.maxWidth !== this.options.maxWidth && (n.style.maxWidth = this.options.maxWidth),
                    i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Wn(this._lngLat, this._pos, i.transform)),
                    !this._trackPointer || e) {
                        const t = this._pos = this._trackPointer && e ? e : i.project(this._lngLat)
                          , r = eo(this.options.offset)
                          , n = this._anchor = this._getAnchor(r.y)
                          , o = eo(this.options.offset, n)
                          , s = t.add(o).round();
                        i._requestDomTask((()=>{
                            this._container && n && (this._container.style.transform = `${Hn[n]} translate(${s.x}px,${s.y}px)`)
                        }
                        ))
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const e = t.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(e)
                    }
                    this._updateClassList()
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                        return;
                    const t = this._container.querySelector(to);
                    t && t.focus()
                }
                _onClose() {
                    this.remove()
                }
                _setOpacity(t) {
                    this._container && (this._container.style.opacity = `${t}`),
                    this._content && (this._content.style.pointerEvents = t ? "auto" : "none")
                }
            }
            ,
            Marker: Kn,
            Style: Ke,
            LngLat: t.LngLat,
            LngLatBounds: t.LngLatBounds,
            Point: t.pointGeometry,
            MercatorCoordinate: t.MercatorCoordinate,
            FreeCameraOptions: Fr,
            Evented: t.Evented,
            config: t.config,
            prewarm: function() {
                Gt().acquire(Ft)
            },
            clearPrewarmedResources: function() {
                const t = Nt;
                t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Ft),
                Nt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
            },
            get accessToken() {
                return t.config.ACCESS_TOKEN
            },
            set accessToken(e) {
                t.config.ACCESS_TOKEN = e
            },
            get baseApiUrl() {
                return t.config.API_URL
            },
            set baseApiUrl(e) {
                t.config.API_URL = e
            },
            get workerCount() {
                return Ut.workerCount
            },
            set workerCount(t) {
                Ut.workerCount = t
            },
            get maxParallelImageRequests() {
                return t.config.MAX_PARALLEL_IMAGE_REQUESTS
            },
            set maxParallelImageRequests(e) {
                t.config.MAX_PARALLEL_IMAGE_REQUESTS = e
            },
            clearStorage(e) {
                t.clearTileCache(e)
            },
            workerUrl: "",
            workerClass: null,
            setNow: t.exported.setNow,
            restoreNow: t.exported.restoreNow
        };
        return ho
    }
    )),
    i
}
));
var o, s = {};
s = JSON.parse('{"AL":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[19.2635,39.6448,21.0573,42.6611]","mapbox_id":"dXJuOm1ieGJuZDpBaEFHOnY0","adm1":{"description":"county","z_min":"2"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"7"}},"AT":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[9.5307,46.3723,17.1608,49.0205]","mapbox_id":"dXJuOm1ieGJuZDpEaEFNOnY0","adm1":{"description":"state","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district, city","z_min":"2"},"adm3":{"description":"municipality, district","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"6"},"adm4":{"description":"cadastral community","z_min":"7"}},"AU":{"sta1":{"description":"state and territory","z_min":"0"},"bbox":"[112.9211,-54.778,159.1092,-9.1422]","mapbox_id":"dXJuOm1ieGJuZDpEUkFOOnY0","adm1":{"description":"state, territory, external territory","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"local government area, unincorporated area, territory","z_min":"1"},"sta3":{"description":"statistical areas level 3","z_min":"1"},"sta2":{"description":"statistical areas level 4","z_min":"0"},"sta4":{"description":"statistical areas level 2","z_min":"2"},"sta5":{"description":"statistical areas level 1","z_min":"5"},"pos4":{"description":"4-digit postcode area","z_min":"2"}},"AW":{"sta1":{"description":"region","z_min":"5"},"bbox":"[-70.0637,12.4118,-69.8657,12.6234]","mapbox_id":"dXJuOm1ieGJuZDpEQkFPOnY0","adm1":{"description":"constituent country","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"}},"AX":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[19.2633,59.7333,21.3303,60.6657]","mapbox_id":"dXJuOm1ieGJuZDpBKzhRRHc6djQ","adm1":{"description":"region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"sub-regional unit","z_min":"2"},"adm3":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"AZ":{"sta1":{"description":"economic region","z_min":"1"},"bbox":"[44.7647,38.3922,50.6248,41.9123]","mapbox_id":"dXJuOm1ieGJuZDpEeEFROnY0","adm1":{"description":"district, city","z_min":"2"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"}},"BA":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[15.7287,42.5555,19.6237,45.2765]","mapbox_id":"dXJuOm1ieGJuZDpIQkFSOnY0","adm1":{"description":"region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"canton, region, district","z_min":"2"},"adm3":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"BE":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[2.5454,49.497,6.4081,51.5051]","mapbox_id":"dXJuOm1ieGJuZDpGUkFVOnY0","adm1":{"description":"region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"province, region","z_min":"1"},"adm3":{"description":"district, region","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"5"},"adm4":{"description":"municipality","z_min":"5"}},"BG":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[22.3572,41.2353,28.6119,44.2155]","mapbox_id":"dXJuOm1ieGJuZDpJeEFXOnY0","adm1":{"description":"province, city","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"0"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"BR":{"sta1":{"description":"State","z_min":"0"},"bbox":"[-73.9832,-33.7512,-28.8478,5.2695]","mapbox_id":"dXJuOm1ieGJuZDpIeEFmOnY0","adm1":{"description":"state, federal district","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"municipality, federal district","z_min":"3"},"sta3":{"description":"Immediate region","z_min":"2"},"sta2":{"description":"Intermediate region","z_min":"1"},"pos4":{"description":"5-2-digit postcode area","z_min":"4"}},"CA":{"sta1":{"description":"province","z_min":"0"},"bbox":"[-141.0019,41.6814,-52.6194,83.1355]","mapbox_id":"dXJuOm1ieGJuZDpLUkFtOnY0","adm1":{"description":"province","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"Senate","z_min":"0"},"loc4":{"description":"neighborhoods","z_min":"6"},"pos3":{"description":"3-digit postcode area","z_min":"2"},"sta3":{"description":"municipality, reserve, town","z_min":"3"},"sta2":{"description":"census division, regional county municipality, county","z_min":"1"},"leg2":{"description":"federal electoral districts","z_min":"1"},"leg3":{"description":"electoral divisions","z_min":"2"},"pos4":{"description":"6-digit postcode area","z_min":"9"}},"CC":{"sta1":{"description":"territory","z_min":"0"},"bbox":"[96.8169,-12.2087,96.9295,-11.8146]","mapbox_id":"dXJuOm1ieGJuZDpOQkFuOnY0","adm1":{"description":"territory","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"sta3":{"description":"statistical areas level 3","z_min":"1"},"sta2":{"description":"statistical areas level 4","z_min":"0"},"sta4":{"description":"statistical areas level 2","z_min":"2"},"sta5":{"description":"statistical areas level 1","z_min":"5"}},"CH":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[5.9559,45.818,10.4922,47.8085]","mapbox_id":"dXJuOm1ieGJuZDoyeEFyOnY0","adm1":{"description":"canton","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district, canton","z_min":"2"},"adm3":{"description":"municipality","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"CV":{"sta1":{"description":"island","z_min":"0"},"bbox":"[-25.3616,14.8021,-22.6572,17.2053]","mapbox_id":"dXJuOm1ieGJuZDpLaEEwOnY0","adm1":{"description":"county","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"parish","z_min":"1"}},"CX":{"sta1":{"description":"territory","z_min":"0"},"bbox":"[105.5333,-10.5705,105.7126,-10.4124]","mapbox_id":"dXJuOm1ieGJuZDpNeEEyOnY0","adm1":{"description":"territory","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"sta3":{"description":"statistical areas level 3","z_min":"1"},"sta2":{"description":"statistical areas level 4","z_min":"0"},"sta4":{"description":"statistical areas level 2","z_min":"2"},"sta5":{"description":"statistical areas level 1","z_min":"5"}},"CY":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[32.2692,34.6323,34.6066,35.7109]","mapbox_id":"dXJuOm1ieGJuZDovaEEzOnY0","adm1":{"description":"district","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"community","z_min":"5"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"CZ":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[12.0906,48.5518,18.8593,51.0557]","mapbox_id":"dXJuOm1ieGJuZDpQUkE0OnY0","adm1":{"description":"region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"},"adm3":{"description":"municipality","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"loc1":{"description":"orp","z_min":"0"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"DE":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[5.8663,47.2701,15.0418,55.0568]","mapbox_id":"dXJuOm1ieGJuZDpWUkE1OnY0","adm1":{"description":"federal state","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"1"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"postal directing area","z_min":"3"},"adm2":{"description":"rural district, urban district, district","z_min":"2"},"adm3":{"description":"municipality, unincorporated area","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"DK":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[8.0725,54.5591,15.1974,57.7522]","mapbox_id":"dXJuOm1ieGJuZDpQeEE3OnY0","adm1":{"description":"region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality, island","z_min":"1"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"sta4":{"description":"LAU 1","z_min":"2"},"sta5":{"description":"LAU 2","z_min":"3"},"pos4":{"description":"4-digit postcode area","z_min":"5"}},"DO":{"sta1":{"description":"macro region","z_min":"2"},"bbox":"[-72.0075,17.4706,-68.323,19.932]","mapbox_id":"dXJuOm1ieGJuZDpRaEE5OnY0","adm1":{"description":"province, federal district","z_min":"2"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality, municipio","z_min":"3"},"sta2":{"description":"region","z_min":"3"}},"EE":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[21.7643,57.5093,28.21,59.822]","mapbox_id":"dXJuOm1ieGJuZDpTQkJBOnY0","adm1":{"description":"county","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"6"}},"ES":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-18.1612,27.6377,4.3278,43.7924]","mapbox_id":"dXJuOm1ieGJuZDoxQkJFOnY0","adm1":{"description":"autonomous community, autonomous city","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"municipality","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"FI":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.5486,59.6761,31.5867,70.0923]","mapbox_id":"dXJuOm1ieGJuZDpUUkJHOnY0","adm1":{"description":"region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"sub-regional unit","z_min":"2"},"adm3":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"FR":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-5.143,41.3333,9.5603,51.0891]","mapbox_id":"dXJuOm1ieGJuZDpUaEJMOnY0","adm1":{"description":"region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"department","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"leg4":{"description":"canton","z_min":"0"},"pos4":{"description":"5-digit postcode area","z_min":"5"},"adm4":{"description":"commune","z_min":"6"}},"GB":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-8.6501,49.8668,1.763,60.8608]","mapbox_id":"dXJuOm1ieGJuZDo3aEJOOnY0","adm1":{"description":"country","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"postcode area","z_min":"2"},"pos2":{"description":"postcode district","z_min":"4"},"pos3":{"description":"postcode sector","z_min":"5"},"adm2":{"description":"unitary authority, council area, county","z_min":"1"},"adm3":{"description":"non-metropolitan district, unitary authority, metropolitan district","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"postcode unit","z_min":"8"}},"GR":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[19.3728,34.8006,29.6457,41.7503]","mapbox_id":"dXJuOm1ieGJuZDpXUkJaOnY0","adm1":{"description":"decentralized administration, autonomous state","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"periphery, autonomous state","z_min":"0"},"adm3":{"description":"peripheral unit, autonomous state","z_min":"1"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"sta4":{"description":"LAU1 1","z_min":"3"},"sta5":{"description":"LAU 2","z_min":"3"},"pos4":{"description":"5-digit postcode area","z_min":"3"},"adm4":{"description":"municipality, autonomous state","z_min":"2"}},"HM":{"sta1":{"description":"territory","z_min":"0"},"bbox":"[72.5826,-53.1949,73.8764,-52.9021]","mapbox_id":"dXJuOm1ieGJuZDpaUkJnOnY0","adm1":{"description":"territory","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"sta3":{"description":"statistical areas level 3","z_min":"1"},"sta2":{"description":"statistical areas level 4","z_min":"0"},"sta4":{"description":"statistical areas level 2","z_min":"2"},"sta5":{"description":"statistical areas level 1","z_min":"5"}},"HU":{"sta1":{"description":"region","z_min":"0"},"bbox":"[16.1139,45.7371,22.8968,48.5852]","mapbox_id":"dXJuOm1ieGJuZDpaeEJrOnY0","adm1":{"description":"county","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"},"adm3":{"description":"village, city, large village","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"IE":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-10.663,51.4199,-5.9942,55.4351]","mapbox_id":"dXJuOm1ieGJuZDpiUkJtOnY0","adm1":{"description":"county","z_min":"2"},"adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"municipal district, borough district, city council","z_min":"4"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"leg4":{"description":"Local Electoral Areas","z_min":"2"},"sta4":{"description":"LAU 1","z_min":"2"},"sta5":{"description":"LAU 2","z_min":"3"}},"IM":{"sta1":{"description":"sheading","z_min":"3"},"bbox":"[-4.8307,54.0431,-4.3079,54.4181]","mapbox_id":"dXJuOm1ieGJuZDpiaEJvOnY0","adm1":{"description":"crown dependency","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"postcode area","z_min":"2"},"pos2":{"description":"postcode district","z_min":"4"},"pos3":{"description":"postcode sector","z_min":"5"},"adm2":{"description":"parish, town, district","z_min":"1"}},"IS":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-24.5327,63.2958,-13.4946,66.5664]","mapbox_id":"dXJuOm1ieGJuZDphQkJ0OnY0","adm1":{"description":"municipality","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"sta4":{"description":"region","z_min":"0"},"pos4":{"description":"3-digit postcode area","z_min":"2"}},"IT":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[6.6268,35.4929,18.5204,47.0921]","mapbox_id":"dXJuOm1ieGJuZDpjQkJ1OnY0","adm1":{"description":"region, autonomous region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"province, metropolitan city, free consortium","z_min":"1"},"adm3":{"description":"municipality","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"JP":{"sta1":{"description":"metropolitan area, major metropolitan area, disputed area","z_min":"2"},"bbox":"[122.9338,24.0457,145.8175,45.523]","mapbox_id":"dXJuOm1ieGJuZDpjeEJ5OnY0","adm1":{"description":"prefecture","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"2"},"pos2":{"description":"3-digit postcode area","z_min":"3"},"pos3":{"description":"5-digit postcode area","z_min":"5"},"adm2":{"description":"city, town, village","z_min":"3"},"adm3":{"description":"ward","z_min":"5"},"sta3":{"description":"statistical area, disputed area","z_min":"7"},"sta2":{"description":"city, town, village","z_min":"3"},"pos4":{"description":"7-digit postcode area, disputed area","z_min":"7"}},"KE":{"sta1":{"description":"province","z_min":"0"},"bbox":"[33.9216,-4.6913,41.9109,5.0334]","mapbox_id":"dXJuOm1ieGJuZDpkeEJ6OnY0","adm1":{"description":"county","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"1"},"pos2":{"description":"3-digit postcode area","z_min":"2"},"adm2":{"description":"sub-county","z_min":"2"},"adm3":{"description":"ward","z_min":"4"},"sta2":{"description":"district","z_min":"1"}},"LI":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[9.4717,47.0484,9.6357,47.2706]","mapbox_id":"dXJuOm1ieGJuZDpnaENCOnY0","adm1":{"description":"municipality","z_min":"5"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"LT":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.954,53.8968,26.8355,56.4504]","mapbox_id":"dXJuOm1ieGJuZDpneENGOnY0","adm1":{"description":"county","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"1"},"adm3":{"description":"eldership, city","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"6"}},"LU":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[5.7357,49.4479,6.531,50.1828]","mapbox_id":"dXJuOm1ieGJuZDpoQkNHOnY0","adm1":{"description":"canton","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"commune","z_min":"4"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"LV":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.9706,55.6747,28.2415,58.0856]","mapbox_id":"dXJuOm1ieGJuZDpmUkNIOnY0","adm1":{"description":"county","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"county district","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"ME":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[18.4335,41.8468,20.3529,43.5582]","mapbox_id":"dXJuOm1ieGJuZDpsaENNOnY0","adm1":{"description":"municipality","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"MK":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.4533,40.8539,23.034,42.3736]","mapbox_id":"dXJuOm1ieGJuZDpoUkNROnY0","adm1":{"description":"municipality","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"MT":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[14.1834,35.8062,14.5765,36.0824]","mapbox_id":"dXJuOm1ieGJuZDppeENaOnY0","adm1":{"description":"region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"sta4":{"description":"LAU 1","z_min":"2"}},"MV":{"sta1":{"description":"former province","z_min":"0"},"bbox":"[72.6392,-0.7037,73.7596,7.1064]","mapbox_id":"dXJuOm1ieGJuZDppUkNiOnY0","adm1":{"description":"atoll","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"}},"NF":{"sta1":{"description":"territory","z_min":"0"},"bbox":"[167.9138,-29.1366,167.998,-28.9942]","mapbox_id":"dXJuOm1ieGJuZDpwUkNqOnY0","adm1":{"description":"territory","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"sta3":{"description":"statistical areas level 3","z_min":"1"},"sta2":{"description":"statistical areas level 4","z_min":"0"},"sta4":{"description":"statistical areas level 2","z_min":"2"},"sta5":{"description":"statistical areas level 1","z_min":"5"}},"NL":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[3.3584,50.7504,7.2275,53.555]","mapbox_id":"dXJuOm1ieGJuZDpuaENtOnY0","adm1":{"description":"province","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"2"},"pos2":{"description":"4-digit postcode area","z_min":"6"},"pos3":{"description":"5-digit postcode area","z_min":"7"},"adm2":{"description":"municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"6-digit postcode area","z_min":"9"}},"NO":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[4.4999,57.9594,31.1683,71.1855]","mapbox_id":"dXJuOm1ieGJuZDpxQkNuOnY0","adm1":{"description":"county","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"sta4":{"description":"LAU 1","z_min":"2"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"NP":{"sta1":{"description":"region","z_min":"0"},"bbox":"[80.0585,26.3474,88.2018,30.4474]","mapbox_id":"dXJuOm1ieGJuZDpuUkNvOnY0","loc2":{"description":"village, town, city","z_min":"2"},"adm1":{"description":"province","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"1"},"pos3":{"description":"3-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"},"sta2":{"description":"zone","z_min":"1"}},"NZ":{"sta1":{"description":"urban rural","z_min":"0"},"bbox":"[165.87,-52.6088,183.8456,-34.1292]","mapbox_id":"dXJuOm1ieGJuZDpvQkNyOnY0","adm1":{"description":"region, special island authority","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"regional council","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"territorial authority","z_min":"1"},"adm3":{"description":"ward","z_min":"2"},"sta3":{"description":"statistical area","z_min":"3"},"sta2":{"description":"statistical area","z_min":"1"},"sta4":{"description":"meshblock","z_min":"4"},"leg2":{"description":"constituency","z_min":"1"},"leg3":{"description":"community board","z_min":"2"},"pos4":{"description":"4-digit postcode area","z_min":"3"}},"PL":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[14.1229,49.002,24.1459,54.8358]","mapbox_id":"dXJuOm1ieGJuZDpzeEN6OnY0","adm1":{"description":"voivodeship","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"powiat, city powiat, capital city","z_min":"2"},"adm3":{"description":"rural municipality, urban-rural municipality, urban municipality","z_min":"4"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"7"},"adm4":{"description":"rural municipality, city, rural area","z_min":"5"}},"PT":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-31.269,30.0288,-6.1892,42.1543]","mapbox_id":"dXJuOm1ieGJuZDp0QkM0OnY0","adm1":{"description":", autonomous region","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"3"},"adm2":{"description":"local council","z_min":"3"},"adm3":{"description":"parish","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"7-digit postcode area","z_min":"9"}},"QA":{"sta1":{"description":"zone","z_min":"1"},"bbox":"[50.7501,24.4711,51.6622,26.1833]","mapbox_id":"dXJuOm1ieGJuZDp0aEM3OnY0","adm1":{"description":"municipality","z_min":"2"},"adm0":{"description":"country/territory","z_min":"0"}},"RO":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.2618,43.6194,29.7153,48.2656]","mapbox_id":"dXJuOm1ieGJuZDp1QkM5OnY0","adm1":{"description":"county, city","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"commune, town, city","z_min":"4"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-6-digit postcode area","z_min":"6"}},"RS":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[18.839,42.2315,23.0064,46.1901]","mapbox_id":"dXJuOm1ieGJuZDp4eEMrOnY0","adm1":{"description":"district, city","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality, city","z_min":"2"},"adm3":{"description":"city municipality","z_min":"3"},"sta3":{"description":"NUTS 3","z_min":"3"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"6"}},"RU":{"sta1":{"description":"federal district","z_min":"0"},"bbox":"[19.6385,41.1854,190.3416,81.8574]","mapbox_id":"dXJuOm1ieGJuZDp1UkMvOnY0","adm1":{"description":"oblast, republic, krai","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"district, urban district, city","z_min":"2"},"adm3":{"description":"city district","z_min":"3"},"pos4":{"description":"6-2-digit postcode area","z_min":"3"}},"SE":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[10.9577,55.3367,24.1761,69.06]","mapbox_id":"dXJuOm1ieGJuZDoyaERGOnY0","adm1":{"description":"county","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"SG":{"sta1":{"description":"region","z_min":"4"},"bbox":"[103.6057,1.1587,104.0885,1.4709]","mapbox_id":"dXJuOm1ieGJuZDp5aERHOnY0","adm1":{"description":"community development council","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"constituency","z_min":"1"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"sta3":{"description":"subzone","z_min":"6"},"sta2":{"description":"planning area","z_min":"5"},"pos4":{"description":"6-digit postcode area","z_min":"8"}},"SI":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[13.3755,45.4214,16.5974,46.8767]","mapbox_id":"dXJuOm1ieGJuZDp6UkRJOnY0","adm1":{"description":"municipality","z_min":"3"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"rural settlement, urban settlement","z_min":"5"},"sta3":{"description":"NUTS 3","z_min":"1"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"7"}},"SJ":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[-9.0864,70.8278,37.0668,80.8212]","mapbox_id":"dXJuOm1ieGJuZDoyQkRKOnY0","adm1":{"description":"region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"settlement, island, area","z_min":"2"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"SK":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[16.8332,47.7312,22.5657,49.6138]","mapbox_id":"dXJuOm1ieGJuZDp6QkRLOnY0","adm1":{"description":"region","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"},"adm3":{"description":"municipality, borough, military district","z_min":"6"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"ST":{"sta1":{"description":"province","z_min":"0"},"bbox":"[6.46,-0.0138,7.4625,1.701]","mapbox_id":"dXJuOm1ieGJuZDp4QkRSOnY0","adm1":{"description":"district","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"sta2":{"description":"region","z_min":"4"}},"TN":{"sta1":{"description":"regions","z_min":"2"},"bbox":"[7.5227,30.2303,11.6112,37.5597]","mapbox_id":"dXJuOm1ieGJuZDo1aERmOnY0","adm1":{"description":"governorate","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"delegation","z_min":"2"}},"TR":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[25.6652,35.8122,44.8181,42.1049]","mapbox_id":"dXJuOm1ieGJuZDo1eERoOnY0","adm1":{"description":"province","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"district, central district","z_min":"2"},"adm3":{"description":"neighborhood, district","z_min":"5"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"US":{"sta1":{"description":"core statistical area","z_min":"1"},"bbox":"[-187.5552,18.9107,-66.9496,71.3885]","mapbox_id":"dXJuOm1ieGJuZDo4aERwOnY0","loc3":{"description":"cdp;hamlet","z_min":"5"},"loc2":{"description":"postal place","z_min":"4"},"adm1":{"description":"state, federal district","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"loc4":{"description":"neighborhoods","z_min":"6"},"pos2":{"description":"2-digit postcode area","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"0"},"adm2":{"description":"county, parish, city","z_min":"2"},"adm3":{"description":"township, town, charter township","z_min":"3"},"sta3":{"description":"county subdivision","z_min":"4"},"sta2":{"description":"micropolitan statistical area, metropolitan statistical area","z_min":"2"},"loc1":{"description":"state, federal district","z_min":"0"},"leg4":{"description":"state house district","z_min":"4"},"sta4":{"description":"tract","z_min":"5"},"sta5":{"description":"block group","z_min":"6"},"leg2":{"description":"congressional district","z_min":"2"},"leg3":{"description":"state senate district","z_min":"3"},"pos4":{"description":"5-digit postcode area","z_min":"3"},"adm4":{"description":"city, town, village","z_min":"5"}},"VG":{"sta1":{"description":"district","z_min":"1"},"bbox":"[-64.8501,18.3064,-64.2706,18.7497]","mapbox_id":"dXJuOm1ieGJuZDpJUkR2OnY0","adm1":{"description":"territory","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos4":{"description":"4-digit postcode area","z_min":"2"}},"WS":{"sta1":{"description":"itumalo","z_min":"3"},"bbox":"[-172.8041,-14.0772,-171.3977,-13.4398]","mapbox_id":"dXJuOm1ieGJuZDp3aEQwOnY0","adm1":{"description":"itumalo","z_min":"3"},"adm0":{"description":"country/territory","z_min":"0"},"sta2":{"description":"faipule","z_min":"3"}},"HR":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[13.4898,42.3922,19.4474,46.555]","mapbox_id":"dXJuOm1ieGJuZDpPaEJpOnY0","adm1":{"description":"county, city","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"4"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"XK":{"sta1":{"description":"NUTS 1","z_min":"0"},"bbox":"[20.0143,41.8576,21.7899,43.2677]","mapbox_id":"dXJuOm1ieGJuZDplUkQxOnY0","adm1":{"description":"district","z_min":"0"},"adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"1"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"1"},"sta3":{"description":"NUTS 3","z_min":"2"},"sta2":{"description":"NUTS 2","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"AE":{"loc2":{"description":"settlement, city","z_min":"1"},"bbox":"[51.498,22.6315,56.3816,26.0694]","mapbox_id":"dXJuOm1ieGJuZDo3UkFDOnY0","adm1":{"description":"emirate","z_min":"1"},"adm0":{"description":"country/territory","z_min":"0"},"loc4":{"description":"neighborhood","z_min":"3"},"adm2":{"description":"municipality, sector, area","z_min":"2"}},"AD":{"adm1":{"description":"parish","z_min":"5"},"bbox":"[1.4136,42.4287,1.7867,42.6559]","mapbox_id":"dXJuOm1ieGJuZDpCUkFCOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"AF":{"adm1":{"description":"province","z_min":"0"},"bbox":"[60.5176,29.3772,74.8899,38.4907]","mapbox_id":"dXJuOm1ieGJuZDpBUkFEOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"district","z_min":"2"}},"AG":{"adm1":{"description":"parish","z_min":"5"},"bbox":"[-62.3482,16.9323,-61.657,17.7294]","mapbox_id":"dXJuOm1ieGJuZDpDUkFFOnY0","adm0":{"description":"country/territory","z_min":"0"}},"AI":{"adm1":{"description":"territory","z_min":"1"},"bbox":"[-63.4296,18.1499,-62.9244,18.5953]","mapbox_id":"dXJuOm1ieGJuZDpCeEFGOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"3"}},"AM":{"adm1":{"description":"province","z_min":"2"},"bbox":"[43.4474,38.8402,46.6342,41.3011]","mapbox_id":"dXJuOm1ieGJuZDpDeEFIOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"}},"AO":{"adm1":{"description":"province","z_min":"0"},"bbox":"[11.6693,-18.0395,24.0837,-4.3607]","mapbox_id":"dXJuOm1ieGJuZDpCaEFJOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"municipality","z_min":"1"}},"AR":{"adm1":{"description":"province, autonomous city","z_min":"0"},"bbox":"[-73.5653,-55.0572,-53.6374,-21.7815]","mapbox_id":"dXJuOm1ieGJuZDpDaEFLOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"department, partido, comuna","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"AS":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[-171.09,-14.5698,-168.1303,-11.0479]","mapbox_id":"dXJuOm1ieGJuZDpCQkFMOnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"district","z_min":"3"},"adm3":{"description":"county","z_min":"3"},"sta4":{"description":"tract","z_min":"5"},"sta5":{"description":"block group","z_min":"6"},"leg2":{"description":"congressional district","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"BB":{"adm1":{"description":"parish","z_min":"5"},"bbox":"[-59.6526,13.0447,-59.4203,13.3348]","mapbox_id":"dXJuOm1ieGJuZDpFeEFTOnY0","adm0":{"description":"country/territory","z_min":"0"}},"BD":{"adm1":{"description":"division","z_min":"1"},"bbox":"[88.0086,20.5751,92.6801,26.6339]","mapbox_id":"dXJuOm1ieGJuZDpFaEFUOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"},"adm3":{"description":"subdistrict, metropolitan subdistrict","z_min":"3"},"adm4":{"description":"union","z_min":"4"}},"BF":{"adm1":{"description":"region","z_min":"1"},"bbox":"[-5.5119,9.4088,2.4048,15.0855]","mapbox_id":"dXJuOm1ieGJuZDpKQkFWOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"province","z_min":"2"}},"BH":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[50.3152,25.5717,50.8245,26.4229]","mapbox_id":"dXJuOm1ieGJuZDpFUkFYOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"area","z_min":"6"},"adm3":{"description":"block","z_min":"7"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"BI":{"adm1":{"description":"province","z_min":"1"},"bbox":"[29.0007,-4.47,30.8502,-2.31]","mapbox_id":"dXJuOm1ieGJuZDpKUkFZOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"4"}},"BJ":{"adm1":{"description":"department","z_min":"0"},"bbox":"[0.7798,6.2347,3.8534,12.4092]","mapbox_id":"dXJuOm1ieGJuZDpGeEFaOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"municipality","z_min":"1"}},"BL":{"adm1":{"description":"municipality","z_min":"1"},"bbox":"[-62.9104,17.8782,-62.7891,17.9609]","mapbox_id":"dXJuOm1ieGJuZDp1eEFhOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos4":{"description":"5-digit postcode area","z_min":"2"}},"BM":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[-64.8875,32.2472,-64.647,32.391]","mapbox_id":"dXJuOm1ieGJuZDpHQkFiOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"parish","z_min":"2"},"pos4":{"description":"4-digit postcode area","z_min":"2"}},"BN":{"adm1":{"description":"district","z_min":"0"},"bbox":"[114.0759,4.0026,115.3647,5.0459]","mapbox_id":"dXJuOm1ieGJuZDpJaEFjOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"subdivision","z_min":"3"}},"BO":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-69.6444,-22.9004,-57.4533,-9.6648]","mapbox_id":"dXJuOm1ieGJuZDpHaEFkOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"municipality","z_min":"2"}},"BQ":{"adm1":{"description":"island","z_min":"1"},"bbox":"[-68.4207,12.0247,-62.9459,17.6501]","mapbox_id":"dXJuOm1ieGJuZDpHeEFlOnY0","adm0":{"description":"country/territory","z_min":"0"}},"BS":{"adm1":{"description":"district","z_min":"0"},"bbox":"[-79.3055,20.912,-72.7118,27.2629]","mapbox_id":"dXJuOm1ieGJuZDpFQkFnOnY0","adm0":{"description":"country/territory","z_min":"0"}},"BT":{"adm1":{"description":"district","z_min":"0"},"bbox":"[88.7455,26.702,92.1252,28.247]","mapbox_id":"dXJuOm1ieGJuZDpHUkFoOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"block","z_min":"3"}},"BV":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[3.2845,-54.4549,3.4333,-54.3864]","mapbox_id":"dXJuOm1ieGJuZDpIaEFpOnY0","adm0":{"description":"country/territory","z_min":"0"}},"BW":{"adm1":{"description":"district, town, city","z_min":"0"},"bbox":"[19.9974,-26.9074,29.3714,-17.7782]","mapbox_id":"dXJuOm1ieGJuZDpIUkFqOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"subdistrict","z_min":"1"}},"BY":{"adm1":{"description":"region, city","z_min":"0"},"bbox":"[23.1783,51.2622,32.7769,56.1722]","mapbox_id":"dXJuOm1ieGJuZDpGQkFrOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"district","z_min":"1"},"pos4":{"description":"6-digit postcode area","z_min":"5"}},"BZ":{"adm1":{"description":"district","z_min":"0"},"bbox":"[-89.225,15.8859,-87.486,18.4958]","mapbox_id":"dXJuOm1ieGJuZDpGaEFsOnY0","adm0":{"description":"country/territory","z_min":"0"}},"CD":{"adm1":{"description":"province","z_min":"0"},"bbox":"[12.2003,-13.4548,31.3064,5.3922]","mapbox_id":"dXJuOm1ieGJuZDpQaEFvOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"territory","z_min":"1"}},"CF":{"adm1":{"description":"prefecture","z_min":"0"},"bbox":"[14.4152,2.2227,27.4616,11.017]","mapbox_id":"dXJuOm1ieGJuZDpMQkFwOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"sub-prefecture","z_min":"1"}},"CG":{"adm1":{"description":"department","z_min":"0"},"bbox":"[11.1466,-5.0375,18.644,3.7122]","mapbox_id":"dXJuOm1ieGJuZDpOeEFxOnY0","adm0":{"description":"country/territory","z_min":"0"}},"CI":{"adm1":{"description":"district","z_min":"0"},"bbox":"[-8.6029,4.3609,-2.4947,10.7397]","mapbox_id":"dXJuOm1ieGJuZDpjUkFzOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"region, autonomous district","z_min":"1"},"adm3":{"description":"department","z_min":"2"}},"CK":{"adm1":{"description":"country","z_min":"3"},"bbox":"[-165.8794,-21.9591,-157.3206,-8.9147]","mapbox_id":"dXJuOm1ieGJuZDpPQkF0OnY0","adm0":{"description":"country/territory","z_min":"0"}},"CL":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-109.4498,-55.982,-66.4148,-17.4986]","mapbox_id":"dXJuOm1ieGJuZDpMaEF1OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"1"},"pos2":{"description":"3-digit postcode area","z_min":"2"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"municipality","z_min":"2"}},"CM":{"adm1":{"description":"region","z_min":"0"},"bbox":"[8.4987,1.6514,16.1912,13.0809]","mapbox_id":"dXJuOm1ieGJuZDpKeEF2OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"}},"CN":{"adm1":{"description":"province, special administrative region","z_min":"0"},"bbox":"[73.4993,7.3643,134.7755,53.561]","mapbox_id":"dXJuOm1ieGJuZDpMeEF3OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"1"},"pos2":{"description":"3-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"prefecture, sub-prefecture, province","z_min":"1"},"adm3":{"description":"county, district, special administrative region","z_min":"2"},"pos4":{"description":"6-4 digit postcode area","z_min":"3"}},"CO":{"adm1":{"description":"department, capital district","z_min":"0"},"bbox":"[-81.7356,-4.2273,-66.8465,13.3947]","mapbox_id":"dXJuOm1ieGJuZDpOUkF4OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"3"},"adm2":{"description":"municipality, non municipal area, capital district","z_min":"2"},"pos4":{"description":"6-digit postcode area","z_min":"3"}},"CR":{"adm1":{"description":"province","z_min":"0"},"bbox":"[-87.102,5.4991,-82.5514,11.2197]","mapbox_id":"dXJuOm1ieGJuZDpPUkF5OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"canton","z_min":"4"},"adm3":{"description":"district","z_min":"5"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"CU":{"adm1":{"description":"province","z_min":"1"},"bbox":"[-84.9521,19.8262,-74.1314,23.2767]","mapbox_id":"dXJuOm1ieGJuZDpPeEF6OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"municipality","z_min":"3"}},"CW":{"adm1":{"description":"island","z_min":"1"},"bbox":"[-69.1623,11.978,-68.6395,12.3924]","mapbox_id":"dXJuOm1ieGJuZDpQQkExOnY0","adm0":{"description":"country/territory","z_min":"0"}},"DJ":{"adm1":{"description":"region, city","z_min":"0"},"bbox":"[41.7719,10.9157,43.4537,12.7067]","mapbox_id":"dXJuOm1ieGJuZDpRQkE2OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district, city","z_min":"2"}},"DM":{"adm1":{"description":"parish","z_min":"4"},"bbox":"[-61.4801,15.2076,-61.2401,15.6402]","mapbox_id":"dXJuOm1ieGJuZDpRUkE4OnY0","adm0":{"description":"country/territory","z_min":"0"}},"DZ":{"adm1":{"description":"province","z_min":"0"},"bbox":"[-8.668,18.9562,11.9942,37.0897]","mapbox_id":"dXJuOm1ieGJuZDpBeEErOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"commune","z_min":"2"}},"EC":{"adm1":{"description":"province","z_min":"0"},"bbox":"[-92.0081,-5.0161,-75.1944,1.6817]","mapbox_id":"dXJuOm1ieGJuZDpReEEvOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"canton","z_min":"2"}},"EG":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[24.6929,21.9993,36.8944,31.6717]","mapbox_id":"dXJuOm1ieGJuZDpSQkJCOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"region","z_min":"2"}},"ER":{"adm1":{"description":"region","z_min":"0"},"bbox":"[36.4282,12.3629,43.1588,17.9992]","mapbox_id":"dXJuOm1ieGJuZDpSeEJEOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"subregion","z_min":"1"}},"ET":{"adm1":{"description":"region, city","z_min":"0"},"bbox":"[32.9997,3.3961,47.9878,14.8942]","mapbox_id":"dXJuOm1ieGJuZDpTUkJGOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"zone","z_min":"1"},"adm3":{"description":"district","z_min":"2"}},"FJ":{"adm1":{"description":"division, dependency","z_min":"3"},"bbox":"[176.8997,-21.0425,181.7714,-12.4617]","mapbox_id":"dXJuOm1ieGJuZDpUQkJIOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"province, dependency","z_min":"3"}},"FM":{"adm1":{"description":"state","z_min":"3"},"bbox":"[137.4253,1.0253,163.0356,10.0906]","mapbox_id":"dXJuOm1ieGJuZDpraEJKOnY0","adm0":{"description":"country/territory","z_min":"0"}},"FO":{"adm1":{"description":"territory","z_min":"2"},"bbox":"[-7.6919,61.3903,-6.2536,62.3941]","mapbox_id":"dXJuOm1ieGJuZDpTeEJLOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"4"},"adm2":{"description":"shire","z_min":"3"},"adm3":{"description":"municipality","z_min":"4"},"pos4":{"description":"3-digit postcode area","z_min":"5"}},"GA":{"adm1":{"description":"province","z_min":"0"},"bbox":"[8.6989,-3.956,14.5281,2.318]","mapbox_id":"dXJuOm1ieGJuZDpVaEJNOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"}},"GD":{"adm1":{"description":"parish, dependency","z_min":"5"},"bbox":"[-61.8024,11.9849,-61.3783,12.5402]","mapbox_id":"dXJuOm1ieGJuZDpXeEJPOnY0","adm0":{"description":"country/territory","z_min":"0"}},"GE":{"adm1":{"description":"region, autonomous republic","z_min":"0"},"bbox":"[40.0066,41.0552,46.7361,43.5866]","mapbox_id":"dXJuOm1ieGJuZDpWQkJQOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality, district, city","z_min":"2"}},"GF":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-54.6024,2.1111,-51.6291,5.7482]","mapbox_id":"dXJuOm1ieGJuZDpUeEJROnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"2"},"adm4":{"description":"commune","z_min":"4"}},"GG":{"adm1":{"description":"crown dependency","z_min":"0"},"bbox":"[-2.6751,49.4002,-2.1586,49.7328]","mapbox_id":"dXJuOm1ieGJuZDpYeEJSOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"postcode area","z_min":"2"},"pos2":{"description":"postcode district","z_min":"4"},"pos3":{"description":"postcode sector","z_min":"5"},"adm2":{"description":"parish, island","z_min":"1"}},"GH":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-3.2551,4.7392,1.2001,11.1683]","mapbox_id":"dXJuOm1ieGJuZDpWaEJTOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode","z_min":"0"},"adm2":{"description":"district, municipal district, metropolitan district","z_min":"1"}},"GI":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[-5.3661,36.1089,-5.3386,36.155]","mapbox_id":"dXJuOm1ieGJuZDpWeEJUOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"postcode area","z_min":"2"},"pos2":{"description":"postcode district","z_min":"4"},"pos3":{"description":"postcode sector","z_min":"5"},"pos4":{"description":"postcode unit","z_min":"8"}},"GL":{"adm1":{"description":"autonomous territory","z_min":"0"},"bbox":"[-73.2481,59.7756,-11.4833,83.6607]","mapbox_id":"dXJuOm1ieGJuZDpXaEJVOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"0"},"adm2":{"description":"municipality","z_min":"0"},"pos4":{"description":"4-digit postcode area","z_min":"1"}},"GM":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-16.8137,13.0432,-13.7917,13.8266]","mapbox_id":"dXJuOm1ieGJuZDpVeEJWOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"GN":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-15.0761,7.1905,-7.6374,12.6756]","mapbox_id":"dXJuOm1ieGJuZDpZQkJXOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"prefecture","z_min":"1"},"adm3":{"description":"municipality","z_min":"2"}},"GP":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-61.8096,15.8321,-61.002,16.5144]","mapbox_id":"dXJuOm1ieGJuZDpYQkJYOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"department","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"2"},"adm4":{"description":"commune","z_min":"6"}},"GQ":{"adm1":{"description":"region","z_min":"0"},"bbox":"[5.6169,-1.4681,11.3654,3.7883]","mapbox_id":"dXJuOm1ieGJuZDpSaEJZOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"province","z_min":"1"}},"GT":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-92.2296,13.7402,-88.2333,17.8166]","mapbox_id":"dXJuOm1ieGJuZDpYaEJiOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"3"}},"GU":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[144.6181,13.2338,144.9569,13.6544]","mapbox_id":"dXJuOm1ieGJuZDpYUkJjOnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"village","z_min":"6"},"sta4":{"description":"tract","z_min":"5"},"sta5":{"description":"block group","z_min":"6"},"leg2":{"description":"congressional district","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"6"}},"GW":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-16.7153,10.8643,-13.6342,12.6855]","mapbox_id":"dXJuOm1ieGJuZDpZUkJkOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"sector","z_min":"1"}},"GY":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-61.3918,1.1693,-56.4851,8.5349]","mapbox_id":"dXJuOm1ieGJuZDpZaEJlOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"neighbourhood democratic council","z_min":"1"}},"HN":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-89.3564,12.9831,-83.1488,16.5168]","mapbox_id":"dXJuOm1ieGJuZDpaaEJoOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode areas","z_min":"1"},"adm2":{"description":"municipality","z_min":"3"},"adm3":{"description":"settlement","z_min":"5"}},"HT":{"adm1":{"description":"department","z_min":"2"},"bbox":"[-74.4808,18.0219,-71.6218,20.0893]","mapbox_id":"dXJuOm1ieGJuZDpaQkJqOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"arrondissement","z_min":"3"},"adm3":{"description":"township","z_min":"4"},"adm4":{"description":"section","z_min":"5"}},"ID":{"adm1":{"description":"province, special capital region, special region","z_min":"0"},"bbox":"[95.0105,-11.0097,141.0222,6.0769]","mapbox_id":"dXJuOm1ieGJuZDphaEJsOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"regency, city","z_min":"1"},"adm3":{"description":"district","z_min":"4"},"pos4":{"description":"5-digit postcode area","z_min":"2"},"adm4":{"description":"village","z_min":"6"}},"IL":{"adm1":{"description":"district","z_min":"0"},"bbox":"[34.2676,29.4956,35.8962,33.3328]","mapbox_id":"dXJuOm1ieGJuZDpieEJuOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"subdistrict","z_min":"1"},"adm3":{"description":"natural region","z_min":"2"}},"IN":{"adm1":{"description":"state, union territory","z_min":"0"},"bbox":"[68.1745,6.756,97.3954,35.6733]","mapbox_id":"dXJuOm1ieGJuZDphUkJwOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"1"},"pos2":{"description":"3-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"3"},"adm2":{"description":"district","z_min":"1"},"adm3":{"description":"tehsil, mandal, block","z_min":"3"},"pos4":{"description":"6-digit postcode area","z_min":"4"}},"IO":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[71.2374,-7.4446,72.4957,-5.236]","mapbox_id":"dXJuOm1ieGJuZDpJQkJxOnY0","adm0":{"description":"country/territory","z_min":"0"}},"IQ":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[38.7937,29.0612,48.6147,37.3807]","mapbox_id":"dXJuOm1ieGJuZDpiQkJyOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"IR":{"adm1":{"description":"province","z_min":"0"},"bbox":"[44.0326,25.0591,63.3333,39.7822]","mapbox_id":"dXJuOm1ieGJuZDpheEJzOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"1"},"adm2":{"description":"county","z_min":"1"}},"JE":{"adm1":{"description":"crown dependency","z_min":"0"},"bbox":"[-2.2545,49.1631,-2.017,49.2623]","mapbox_id":"dXJuOm1ieGJuZDpkQkJ2OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"postcode area","z_min":"2"},"pos2":{"description":"postcode district","z_min":"4"},"pos3":{"description":"postcode sector","z_min":"5"},"adm2":{"description":"parish","z_min":"1"}},"JM":{"adm1":{"description":"parish","z_min":"2"},"bbox":"[-78.3688,17.7058,-76.1829,18.525]","mapbox_id":"dXJuOm1ieGJuZDpjaEJ3OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"2"},"pos2":{"description":"3-digit postcode area","z_min":"3"}},"JO":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[34.9581,29.185,39.3012,33.3747]","mapbox_id":"dXJuOm1ieGJuZDpkUkJ4OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"KG":{"adm1":{"description":"province","z_min":"0"},"bbox":"[69.2516,39.181,80.2282,43.2662]","mapbox_id":"dXJuOm1ieGJuZDpleEIwOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"KH":{"adm1":{"description":"province, autonomous municipality","z_min":"0"},"bbox":"[102.3337,10.3531,107.6277,14.6902]","mapbox_id":"dXJuOm1ieGJuZDpKaEIxOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"4"},"adm2":{"description":"district, municipality, section","z_min":"2"},"adm3":{"description":"commune","z_min":"4"},"pos4":{"description":"6-digit postcode area","z_min":"6"}},"KM":{"adm1":{"description":"province","z_min":"0"},"bbox":"[43.2291,-12.4221,44.5405,-11.3649]","mapbox_id":"dXJuOm1ieGJuZDpOaEIzOnY0","adm0":{"description":"country/territory","z_min":"0"}},"KN":{"adm1":{"description":"island","z_min":"0"},"bbox":"[-62.8643,17.0941,-62.5395,17.4178]","mapbox_id":"dXJuOm1ieGJuZDp2UkI0OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"parish","z_min":"5"}},"KP":{"adm1":{"description":"province","z_min":"0"},"bbox":"[124.1813,37.6769,130.699,43.0092]","mapbox_id":"dXJuOm1ieGJuZDpwaEI1OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"county, city, district","z_min":"2"}},"KR":{"adm1":{"description":"province, metropolitan city, special city","z_min":"0"},"bbox":"[124.6098,33.1128,131.8728,38.6172]","mapbox_id":"dXJuOm1ieGJuZDowaEI2OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"3"},"pos3":{"description":"3-digit postcode area","z_min":"4"},"adm2":{"description":"county, city, district","z_min":"2"},"adm3":{"description":"non-autonomous district","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"6"},"adm4":{"description":"neighborhood, township, town","z_min":"6"}},"KW":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[46.553,28.5244,48.7781,30.1037]","mapbox_id":"dXJuOm1ieGJuZDplaEI3OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"},"pos4":{"description":"2-digit postcode area","z_min":"2"}},"KY":{"adm1":{"description":"territory","z_min":"1"},"bbox":"[-81.4202,19.263,-79.723,19.7569]","mapbox_id":"dXJuOm1ieGJuZDpLeEI4OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"}},"KZ":{"adm1":{"description":"region, city","z_min":"0"},"bbox":"[46.4937,40.5687,87.3154,55.442]","mapbox_id":"dXJuOm1ieGJuZDpkaEI5OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"0"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district, city","z_min":"1"}},"LA":{"adm1":{"description":"province","z_min":"0"},"bbox":"[100.0839,13.9097,107.6351,22.509]","mapbox_id":"dXJuOm1ieGJuZDpmQkIrOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"}},"LB":{"adm1":{"description":"governorate","z_min":"1"},"bbox":"[35.1036,33.055,36.6237,34.6921]","mapbox_id":"dXJuOm1ieGJuZDpmaEIvOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"3"}},"LC":{"adm1":{"description":"district","z_min":"5"},"bbox":"[-61.0798,13.7076,-60.8732,14.1104]","mapbox_id":"dXJuOm1ieGJuZDp2aENBOnY0","adm0":{"description":"country/territory","z_min":"0"}},"LK":{"adm1":{"description":"province","z_min":"0"},"bbox":"[79.6505,5.9216,81.8789,9.8358]","mapbox_id":"dXJuOm1ieGJuZDoxUkNDOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"LR":{"adm1":{"description":"county","z_min":"1"},"bbox":"[-11.4917,4.3535,-7.3672,8.551]","mapbox_id":"dXJuOm1ieGJuZDpnQkNEOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"2"}},"LS":{"adm1":{"description":"district","z_min":"0"},"bbox":"[27.0112,-30.6756,29.4557,-28.5708]","mapbox_id":"dXJuOm1ieGJuZDpmeENFOnY0","adm0":{"description":"country/territory","z_min":"0"}},"LY":{"adm1":{"description":"district","z_min":"0"},"bbox":"[9.3923,19.5087,25.1471,33.1669]","mapbox_id":"dXJuOm1ieGJuZDpnUkNJOnY0","adm0":{"description":"country/territory","z_min":"0"}},"MA":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-13.1671,27.6705,-1.0108,35.9222]","mapbox_id":"dXJuOm1ieGJuZDptQkNKOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"commune","z_min":"3"}},"MC":{"adm1":{"description":"commune","z_min":"3"},"bbox":"[7.4091,43.7248,7.44,43.7519]","mapbox_id":"dXJuOm1ieGJuZDpsQkNLOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"quartier","z_min":"6"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"MD":{"adm1":{"description":"district","z_min":"1"},"bbox":"[26.6164,45.4664,30.1637,48.492]","mapbox_id":"dXJuOm1ieGJuZDpreENMOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"4"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"MF":{"adm1":{"description":"collectivity","z_min":"3"},"bbox":"[-63.1533,18.0447,-62.9706,18.1252]","mapbox_id":"dXJuOm1ieGJuZDp2eENOOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos4":{"description":"5-digit postcode area","z_min":"2"}},"MG":{"adm1":{"description":"region","z_min":"0"},"bbox":"[43.1885,-25.6062,50.4861,-11.9488]","mapbox_id":"dXJuOm1ieGJuZDpoaENPOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"1"},"adm2":{"description":"district","z_min":"2"}},"MH":{"adm1":{"description":"municipality","z_min":"3"},"bbox":"[160.7953,4.5725,172.1725,14.7232]","mapbox_id":"dXJuOm1ieGJuZDpqQkNQOnY0","adm0":{"description":"country/territory","z_min":"0"}},"ML":{"adm1":{"description":"region, city","z_min":"0"},"bbox":"[-12.2403,10.1521,4.2493,24.9999]","mapbox_id":"dXJuOm1ieGJuZDppaENSOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"cercle, district","z_min":"1"}},"MM":{"adm1":{"description":"state, region, union territory","z_min":"0"},"bbox":"[92.172,9.5979,101.1703,28.5478]","mapbox_id":"dXJuOm1ieGJuZDptaENTOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"},"adm3":{"description":"township","z_min":"2"}},"MN":{"adm1":{"description":"province","z_min":"0"},"bbox":"[87.7345,41.5818,119.9315,52.1484]","mapbox_id":"dXJuOm1ieGJuZDpsUkNUOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"0"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"MP":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[144.8863,14.1104,146.0648,20.5538]","mapbox_id":"dXJuOm1ieGJuZDpweENWOnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"0"},"adm2":{"description":"municipality","z_min":"3"},"sta3":{"description":"tract","z_min":"4"},"sta4":{"description":"block group","z_min":"6"},"leg2":{"description":"congressional district","z_min":"2"},"pos4":{"description":"5-digit postcode areas","z_min":"3"}},"MQ":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-61.2293,14.3887,-60.8095,14.8788]","mapbox_id":"dXJuOm1ieGJuZDpqUkNXOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"region","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"3"},"adm4":{"description":"commune","z_min":"6"}},"MR":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-17.0698,14.7202,-4.83,27.3129]","mapbox_id":"dXJuOm1ieGJuZDpqaENYOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"}},"MS":{"adm1":{"description":"territory","z_min":"1"},"bbox":"[-62.242,16.6744,-62.1442,16.824]","mapbox_id":"dXJuOm1ieGJuZDpseENZOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"parish","z_min":"2"},"pos4":{"description":"4-digit postcode area","z_min":"2"}},"MU":{"adm1":{"description":"district","z_min":"0"},"bbox":"[56.5853,-20.5255,63.5033,-10.3372]","mapbox_id":"dXJuOm1ieGJuZDpqeENhOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"0"}},"MW":{"adm1":{"description":"region","z_min":"0"},"bbox":"[32.6748,-17.1259,35.9173,-9.3622]","mapbox_id":"dXJuOm1ieGJuZDpoeENjOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"MX":{"adm1":{"description":"state, federal district","z_min":"0"},"bbox":"[-118.3651,14.53,-86.7104,32.7187]","mapbox_id":"dXJuOm1ieGJuZDprUkNkOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"2"},"pos4":{"description":"5-2-digit postcode area","z_min":"4"}},"MY":{"adm1":{"description":"state, federal territory","z_min":"0"},"bbox":"[99.6407,0.8539,119.2697,7.3806]","mapbox_id":"dXJuOm1ieGJuZDppQkNlOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"division","z_min":"1"},"adm3":{"description":"district","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"4"}},"MZ":{"adm1":{"description":"province","z_min":"0"},"bbox":"[30.2167,-26.8681,40.8393,-10.4709]","mapbox_id":"dXJuOm1ieGJuZDptUkNmOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"NA":{"adm1":{"description":"region","z_min":"0"},"bbox":"[11.7366,-28.9695,25.2562,-16.9635]","mapbox_id":"dXJuOm1ieGJuZDpteENnOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"0"}},"NC":{"adm1":{"description":"collectivity","z_min":"3"},"bbox":"[158.2487,-22.848,172.09,-18.0264]","mapbox_id":"dXJuOm1ieGJuZDpueENoOnY0","adm0":{"description":"country/territory","z_min":"0"}},"NE":{"adm1":{"description":"region","z_min":"0"},"bbox":"[0.1672,11.6954,15.9979,23.518]","mapbox_id":"dXJuOm1ieGJuZDpvaENpOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"}},"NG":{"adm1":{"description":"state, federal territory","z_min":"0"},"bbox":"[2.6732,4.2707,14.678,13.8934]","mapbox_id":"dXJuOm1ieGJuZDpveENrOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"local government area","z_min":"2"}},"NI":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-87.6906,10.7094,-82.7346,15.0294]","mapbox_id":"dXJuOm1ieGJuZDpvUkNsOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode areas","z_min":"1"},"pos3":{"description":"2-digit postcode areas","z_min":"1"},"adm2":{"description":"municipality","z_min":"3"},"pos4":{"description":"3-5-digit postcode areas","z_min":"3"}},"NR":{"adm1":{"description":"district","z_min":"3"},"bbox":"[166.9095,-0.5543,166.9593,-0.5021]","mapbox_id":"dXJuOm1ieGJuZDpuQkNwOnY0","adm0":{"description":"country/territory","z_min":"0"}},"NU":{"adm1":{"description":"country","z_min":"3"},"bbox":"[-169.9508,-19.1561,-169.7737,-18.9523]","mapbox_id":"dXJuOm1ieGJuZDpwQkNxOnY0","adm0":{"description":"country/territory","z_min":"0"}},"OM":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[52,16.6501,59.8398,26.4049]","mapbox_id":"dXJuOm1ieGJuZDpxUkNzOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"PA":{"adm1":{"description":"province, indigenous region","z_min":"0"},"bbox":"[-83.0516,7.2038,-77.1394,9.6457]","mapbox_id":"dXJuOm1ieGJuZDpyUkN0OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode areas","z_min":"1"},"adm2":{"description":"district, indigenous region","z_min":"2"}},"PE":{"adm1":{"description":"province","z_min":"0"},"bbox":"[-81.3282,-18.3517,-68.6521,-0.0389]","mapbox_id":"dXJuOm1ieGJuZDpzQkN1OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"districts","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"PF":{"adm1":{"description":"collectivity","z_min":"0"},"bbox":"[-154.7272,-27.9005,-134.4511,-7.895]","mapbox_id":"dXJuOm1ieGJuZDpVQkN2OnY0","adm0":{"description":"country/territory","z_min":"0"}},"PG":{"adm1":{"description":"province","z_min":"0"},"bbox":"[140.842,-11.6554,155.9831,-1.3148]","mapbox_id":"dXJuOm1ieGJuZDpyaEN3OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"PH":{"adm1":{"description":"region","z_min":"0"},"bbox":"[114.2779,4.5873,126.6049,21.1219]","mapbox_id":"dXJuOm1ieGJuZDovUkN4OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"province, region","z_min":"1"},"adm3":{"description":"municipality, city, lake","z_min":"3"},"pos4":{"description":"4-digit postcode area","z_min":"5"},"adm4":{"description":"barangay","z_min":"7"}},"PK":{"adm1":{"description":"autonomous territory, province, federal territory","z_min":"0"},"bbox":"[60.873,23.7046,77.1204,37.0914]","mapbox_id":"dXJuOm1ieGJuZDpxaEN5OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"division","z_min":"1"},"adm3":{"description":"district","z_min":"2"}},"PM":{"adm1":{"description":"collectivity","z_min":"3"},"bbox":"[-56.406,46.7489,-56.1266,47.145]","mapbox_id":"dXJuOm1ieGJuZDp3QkMwOnY0","adm0":{"description":"country/territory","z_min":"0"}},"PN":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[-130.7562,-25.0798,-124.772,-23.9077]","mapbox_id":"dXJuOm1ieGJuZDpzaEMxOnY0","adm0":{"description":"country/territory","z_min":"0"}},"PR":{"adm1":{"description":"territory","z_min":"2"},"bbox":"[-67.9514,17.8814,-65.2211,18.516]","mapbox_id":"dXJuOm1ieGJuZDp0UkMyOnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"1"},"adm2":{"description":"municipality","z_min":"4"},"adm3":{"description":"submunicipality","z_min":"6"},"leg4":{"description":"state house district","z_min":"4"},"leg2":{"description":"congressional district","z_min":"2"},"leg3":{"description":"state senate district","z_min":"3"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"PS":{"adm1":{"description":"district","z_min":"0"},"bbox":"[34.2186,31.2203,35.5741,32.5521]","mapbox_id":"dXJuOm1ieGJuZDpyQkMzOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"governorate","z_min":"2"}},"PW":{"adm1":{"description":"state","z_min":"3"},"bbox":"[131.1199,2.9714,134.7214,8.0942]","mapbox_id":"dXJuOm1ieGJuZDpxeEM1OnY0","adm0":{"description":"country/territory","z_min":"0"}},"PY":{"adm1":{"description":"department, capital district","z_min":"0"},"bbox":"[-62.6415,-27.5759,-54.2608,-19.2928]","mapbox_id":"dXJuOm1ieGJuZDpyeEM2OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"},"pos4":{"description":"6-digit postcode area","z_min":"2"}},"RE":{"adm1":{"description":"region","z_min":"0"},"bbox":"[55.2165,-21.3896,55.8366,-20.8718]","mapbox_id":"dXJuOm1ieGJuZDp0eEM4OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"department","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"2"},"adm4":{"description":"commune","z_min":"6"}},"RW":{"adm1":{"description":"province","z_min":"0"},"bbox":"[28.862,-2.8388,30.8991,-1.0479]","mapbox_id":"dXJuOm1ieGJuZDp1aERBOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"},"adm3":{"description":"sector","z_min":"2"}},"SA":{"adm1":{"description":"region","z_min":"0"},"bbox":"[34.4953,16.3795,55.6667,32.1543]","mapbox_id":"dXJuOm1ieGJuZDp4UkRCOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"governorate","z_min":"1"}},"SB":{"adm1":{"description":"province","z_min":"3"},"bbox":"[155.5122,-12.3083,170.1925,-5.0269]","mapbox_id":"dXJuOm1ieGJuZDp6aERDOnY0","adm0":{"description":"country/territory","z_min":"0"}},"SC":{"adm1":{"description":"district","z_min":"0"},"bbox":"[46.2029,-10.2271,56.2947,-3.7129]","mapbox_id":"dXJuOm1ieGJuZDp5QkREOnY0","adm0":{"description":"country/territory","z_min":"0"}},"SD":{"adm1":{"description":"state","z_min":"0"},"bbox":"[21.8143,8.683,38.8492,22.0065]","mapbox_id":"dXJuOm1ieGJuZDoxaERFOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"SH":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[-14.421,-40.3714,-5.6341,-7.8892]","mapbox_id":"dXJuOm1ieGJuZDp2QkRIOnY0","adm0":{"description":"country/territory","z_min":"0"}},"SL":{"adm1":{"description":"province, area","z_min":"0"},"bbox":"[-13.3064,6.9246,-10.2741,10.0001]","mapbox_id":"dXJuOm1ieGJuZDp5UkRMOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"SM":{"adm1":{"description":"castello","z_min":"3"},"bbox":"[12.4033,43.8936,12.5162,43.9921]","mapbox_id":"dXJuOm1ieGJuZDp3eERNOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"5"}},"SN":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-17.5302,12.3068,-11.3463,16.6916]","mapbox_id":"dXJuOm1ieGJuZDp4aEROOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode areas","z_min":"0"},"adm2":{"description":"department","z_min":"1"}},"SO":{"adm1":{"description":"region","z_min":"0"},"bbox":"[40.9924,-1.6627,51.4156,11.9893]","mapbox_id":"dXJuOm1ieGJuZDp6eERPOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"SR":{"adm1":{"description":"district","z_min":"0"},"bbox":"[-58.0547,1.8344,-53.9798,6.0088]","mapbox_id":"dXJuOm1ieGJuZDoxeERQOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"resort","z_min":"1"}},"SS":{"adm1":{"description":"state","z_min":"0"},"bbox":"[24.1507,3.4803,35.9353,12.2322]","mapbox_id":"dXJuOm1ieGJuZDoweERROnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"county","z_min":"0"}},"SV":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-90.1327,13.1524,-87.6905,14.451]","mapbox_id":"dXJuOm1ieGJuZDpSUkRTOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode areas","z_min":"0"},"pos3":{"description":"3-digit postcode areas","z_min":"0"},"adm2":{"description":"municipality","z_min":"3"},"pos4":{"description":"5-digit postcode areas","z_min":"0"}},"SX":{"adm1":{"description":"island","z_min":"1"},"bbox":"[-63.1373,18.0051,-63.0135,18.0626]","mapbox_id":"dXJuOm1ieGJuZDp5eERUOnY0","adm0":{"description":"country/territory","z_min":"0"}},"SY":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[35.7167,32.3111,42.3763,37.3206]","mapbox_id":"dXJuOm1ieGJuZDozQkRVOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"SZ":{"adm1":{"description":"district","z_min":"0"},"bbox":"[30.7908,-27.3175,32.1322,-25.7188]","mapbox_id":"dXJuOm1ieGJuZDoyUkRWOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"constituency","z_min":"3"},"pos4":{"description":"4-digit postcode area","z_min":"3"}},"TC":{"adm1":{"description":"territory","z_min":"1"},"bbox":"[-72.4829,21.1777,-71.0828,21.9625]","mapbox_id":"dXJuOm1ieGJuZDo2UkRXOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"2"},"pos4":{"description":"postcode unit","z_min":"2"}},"TD":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[13.4731,7.4418,24.0016,23.4504]","mapbox_id":"dXJuOm1ieGJuZDpMUkRYOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"prefecture","z_min":"1"}},"TF":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[40.3259,-50.0213,77.5957,-11.5678]","mapbox_id":"dXJuOm1ieGJuZDpVUkRZOnY0","adm0":{"description":"country/territory","z_min":"0"}},"TG":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-0.1438,6.1126,1.8091,11.1373]","mapbox_id":"dXJuOm1ieGJuZDo0aERaOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"prefecture","z_min":"1"}},"TH":{"adm1":{"description":"province, special administrative area","z_min":"1"},"bbox":"[97.3434,5.6129,105.6368,20.4651]","mapbox_id":"dXJuOm1ieGJuZDo0QkRhOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"3"},"adm3":{"description":"tambon, lake","z_min":"4"},"pos4":{"description":"5-digit postcode area","z_min":"3"}},"TJ":{"adm1":{"description":"region, districts under republic administration, autonomous region","z_min":"0"},"bbox":"[67.3372,36.672,75.154,41.0449]","mapbox_id":"dXJuOm1ieGJuZDozaERiOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district","z_min":"1"}},"TK":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[-172.5208,-9.444,-171.1814,-8.532]","mapbox_id":"dXJuOm1ieGJuZDo0eERjOnY0","adm0":{"description":"country/territory","z_min":"0"}},"TL":{"adm1":{"description":"municipality, special administrative region","z_min":"0"},"bbox":"[124.0419,-9.5037,127.3423,-8.1269]","mapbox_id":"dXJuOm1ieGJuZDo0UkRkOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"administrative post","z_min":"1"}},"TM":{"adm1":{"description":"province","z_min":"0"},"bbox":"[52.4456,35.1291,66.7074,42.7983]","mapbox_id":"dXJuOm1ieGJuZDo2QkRlOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district, city","z_min":"1"}},"TO":{"adm1":{"description":"province","z_min":"3"},"bbox":"[-176.2137,-22.3497,-173.7351,-15.5659]","mapbox_id":"dXJuOm1ieGJuZDo1QkRnOnY0","adm0":{"description":"country/territory","z_min":"0"}},"TT":{"adm1":{"description":"region, borough, city","z_min":"1"},"bbox":"[-61.9309,10.0425,-60.4925,11.3588]","mapbox_id":"dXJuOm1ieGJuZDo1UkRpOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"parish","z_min":"1"}},"TV":{"adm1":{"description":"province","z_min":"3"},"bbox":"[176.0588,-10.7916,179.8711,-5.6425]","mapbox_id":"dXJuOm1ieGJuZDo2aERqOnY0","adm0":{"description":"country/territory","z_min":"0"}},"TZ":{"adm1":{"description":"region","z_min":"0"},"bbox":"[29.3908,-11.7613,40.4451,-0.9858]","mapbox_id":"dXJuOm1ieGJuZDozeERsOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"0"},"pos3":{"description":"3-digit postcode area","z_min":"1"},"adm2":{"description":"district","z_min":"1"}},"UA":{"adm1":{"description":"region, city, autonomous republic","z_min":"0"},"bbox":"[22.1371,44.3866,40.2256,52.3794]","mapbox_id":"dXJuOm1ieGJuZDo3QkRtOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"3-digit postcode area","z_min":"3"},"adm2":{"description":"district, city","z_min":"1"},"adm3":{"description":"community, Suffix added to disambiguate name, city","z_min":"2"},"pos4":{"description":"3-5 digit postcode area","z_min":"5"},"adm4":{"description":"urban district","z_min":"3"}},"UG":{"adm1":{"description":"district","z_min":"0"},"bbox":"[29.5722,-1.4873,35.0197,4.2267]","mapbox_id":"dXJuOm1ieGJuZDo2eERuOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"county","z_min":"1"},"adm3":{"description":"sub-county","z_min":"4"}},"UM":{"adm1":{"description":"territory","z_min":"3"},"bbox":"[-193.4023,-0.3805,-75.002,28.2186]","mapbox_id":"dXJuOm1ieGJuZDo4QkRvOnY0","adm0":{"description":"country/territory","z_min":"0"}},"UY":{"adm1":{"description":"department","z_min":"0"},"bbox":"[-58.4891,-34.9735,-53.1014,-30.0853]","mapbox_id":"dXJuOm1ieGJuZDo3eERxOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"1"},"pos4":{"description":"5-digit postcode area","z_min":"2"}},"UZ":{"adm1":{"description":"province, city, autonomous republic","z_min":"0"},"bbox":"[55.9982,37.1723,73.1489,45.5901]","mapbox_id":"dXJuOm1ieGJuZDo4eERyOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"district, city","z_min":"2"}},"VC":{"adm1":{"description":"parish","z_min":"5"},"bbox":"[-61.4609,12.5789,-61.1149,13.3832]","mapbox_id":"dXJuOm1ieGJuZDp3UkR0OnY0","adm0":{"description":"country/territory","z_min":"0"}},"VE":{"adm1":{"description":"state, federal district","z_min":"0"},"bbox":"[-73.3529,0.6469,-59.8065,12.4912]","mapbox_id":"dXJuOm1ieGJuZDo5aER1OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"municipality","z_min":"1"}},"VI":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[-65.0853,17.674,-64.5652,18.413]","mapbox_id":"dXJuOm1ieGJuZDo4UkR3OnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"senate","z_min":"0"},"adm2":{"description":"district","z_min":"1"},"adm3":{"description":"subdistrict","z_min":"1"},"leg2":{"description":"congressional district","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"2"}},"VN":{"adm1":{"description":"province, city","z_min":"1"},"bbox":"[102.1439,7.6024,116.6811,23.3927]","mapbox_id":"dXJuOm1ieGJuZDo5eER4OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"pos3":{"description":"3-digit postcode area","z_min":"4"},"adm2":{"description":"district, city, town","z_min":"3"},"adm3":{"description":"ward, commune","z_min":"4"}},"VU":{"adm1":{"description":"province","z_min":"3"},"bbox":"[166.5414,-20.2532,170.2402,-13.0725]","mapbox_id":"dXJuOm1ieGJuZDo5QkR5OnY0","adm0":{"description":"country/territory","z_min":"0"}},"WF":{"adm1":{"description":"collectivity","z_min":"3"},"bbox":"[-178.1824,-14.3622,-176.1242,-13.1828]","mapbox_id":"dXJuOm1ieGJuZDorQkR6OnY0","adm0":{"description":"country/territory","z_min":"0"}},"XS":{"adm1":{"description":"base area","z_min":"0"},"bbox":"[32.7549,34.5623,33.9166,35.1237]","mapbox_id":"dXJuOm1ieGJuZDoveEQyOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"community","z_min":"5"},"pos4":{"description":"4-digit postcode area","z_min":"6"}},"YE":{"adm1":{"description":"governorate","z_min":"0"},"bbox":"[41.9037,12.1081,54.5343,18.9996]","mapbox_id":"dXJuOm1ieGJuZDoraEQzOnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district","z_min":"1"}},"YT":{"adm1":{"description":"region","z_min":"0"},"bbox":"[45.0181,-13.0058,45.3,-12.636]","mapbox_id":"dXJuOm1ieGJuZDprQkQ0OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"department","z_min":"1"},"adm3":{"description":"arrondissement","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"4"},"adm4":{"description":"commune","z_min":"6"}},"ZA":{"adm1":{"description":"province","z_min":"0"},"bbox":"[16.4519,-34.8342,32.8911,-22.125]","mapbox_id":"dXJuOm1ieGJuZDowQkQ1OnY0","adm0":{"description":"country/territory","z_min":"0"},"pos3":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"district municipality","z_min":"1"},"adm3":{"description":"local municipality","z_min":"2"},"leg5":{"description":"ward","z_min":"2"},"pos4":{"description":"4-digit postcode area","z_min":"4"}},"ZM":{"adm1":{"description":"province","z_min":"0"},"bbox":"[22,-18.0765,33.703,-8.2415]","mapbox_id":"dXJuOm1ieGJuZDoreEQ2OnY0","adm0":{"description":"country/territory","z_min":"0"},"leg1":{"description":"constituency","z_min":"1"},"adm2":{"description":"district","z_min":"0"}},"ZW":{"adm1":{"description":"province","z_min":"0"},"bbox":"[25.2374,-22.422,33.054,-15.6099]","mapbox_id":"dXJuOm1ieGJuZDovQkQ3OnY0","adm0":{"description":"country/territory","z_min":"0"},"adm2":{"description":"district, town, city","z_min":"1"}},"EH":{"adm1":{"description":"region","z_min":"0"},"bbox":"[-17.1033,20.7697,-8.6663,27.6837]","mapbox_id":"dXJuOm1ieGJuZDorUkJDOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"1-digit postcode area","z_min":"1"},"pos2":{"description":"2-digit postcode area","z_min":"2"},"adm2":{"description":"province","z_min":"1"},"adm3":{"description":"commune","z_min":"1"}},"HK":{"adm1":{"description":"special administrative region","z_min":"0"},"bbox":"[113.8351,22.1539,114.4417,22.5619]","mapbox_id":"dXJuOm1ieGJuZDpBL0FRWHc6djQ","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"prefecture","z_min":"1"},"adm3":{"description":"district","z_min":"2"}},"MO":{"adm1":{"description":"special administrative region","z_min":"0"},"bbox":"[113.5287,22.1097,113.5983,22.2171]","mapbox_id":"dXJuOm1ieGJuZDpBL0VRbEE6djQ","adm0":{"description":"country/territory","z_min":"0"},"pos1":{"description":"2-digit postcode area","z_min":"0"},"pos2":{"description":"3-digit postcode area","z_min":"1"},"pos3":{"description":"4-digit postcode area","z_min":"2"},"adm2":{"description":"prefecture","z_min":"1"}},"TW":{"adm1":{"description":"special municipality, province","z_min":"0"},"bbox":"[114.3593,10.3713,122.1091,26.3853]","mapbox_id":"dXJuOm1ieGJuZDozUkRrOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos2":{"description":"1-digit postcode area","z_min":"2"},"pos3":{"description":"2-digit postcode area","z_min":"3"},"adm2":{"description":"county, special municipality, provincial city","z_min":"2"},"adm3":{"description":"township, district, city","z_min":"3"},"pos4":{"description":"3-digit postcode area","z_min":"4"},"adm4":{"description":"village","z_min":"7"}},"FK":{"adm1":{"description":"territory","z_min":"1"},"bbox":"[-61.4563,-52.9191,-57.7147,-50.9967]","mapbox_id":"dXJuOm1ieGJuZDpTaEJJOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos4":{"description":"7-digit postcode area","z_min":"2"}},"GS":{"adm1":{"description":"territory","z_min":"0"},"bbox":"[-42.2024,-59.4855,-26.2675,-53.3417]","mapbox_id":"dXJuOm1ieGJuZDowUkJhOnY0","adm0":{"description":"country/territory","z_min":"0"},"pos4":{"description":"7-digit postcode area","z_min":"2"}},"AQ":{"adm0":{"description":"country/territory","z_min":"0"},"bbox":"[-180,-85.0511,180,-60.5155]","mapbox_id":"dXJuOm1ieGJuZDpDQkFKOnY0"},"KI":{"adm0":{"description":"country/territory","z_min":"0"},"bbox":"[-190.4791,-11.4479,-150.1953,4.6994]","mapbox_id":"dXJuOm1ieGJuZDplQkIyOnY0"},"VA":{"adm0":{"description":"country/territory","z_min":"0"},"bbox":"[12.4457,41.9002,12.4584,41.9074]","mapbox_id":"dXJuOm1ieGJuZDo5UkRzOnY0","pos3":{"description":"2-digit postcode area","z_min":"2"},"pos4":{"description":"5-digit postcode area","z_min":"5"}}}'),
r.register("ihkd7", (function(t, e) {
    var i = function() {
        var t = {}
          , e = Math.PI / 180
          , i = 180 / Math.PI
          , r = 6378137
          , n = 20037508.342789244;
        function o(e) {
            if (e = e || {},
            this.size = e.size || 256,
            !t[this.size]) {
                var i = this.size
                  , r = t[this.size] = {};
                r.Bc = [],
                r.Cc = [],
                r.zc = [],
                r.Ac = [];
                for (var n = 0; n < 30; n++)
                    r.Bc.push(i / 360),
                    r.Cc.push(i / (2 * Math.PI)),
                    r.zc.push(i / 2),
                    r.Ac.push(i),
                    i *= 2
            }
            this.Bc = t[this.size].Bc,
            this.Cc = t[this.size].Cc,
            this.zc = t[this.size].zc,
            this.Ac = t[this.size].Ac
        }
        return o.prototype.px = function(t, i) {
            var r = this.zc[i]
              , n = Math.min(Math.max(Math.sin(e * t[1]), -.9999), .9999)
              , o = Math.round(r + t[0] * this.Bc[i])
              , s = Math.round(r + .5 * Math.log((1 + n) / (1 - n)) * -this.Cc[i]);
            return o > this.Ac[i] && (o = this.Ac[i]),
            s > this.Ac[i] && (s = this.Ac[i]),
            [o, s]
        }
        ,
        o.prototype.ll = function(t, e) {
            var r = (t[1] - this.zc[e]) / -this.Cc[e];
            return [(t[0] - this.zc[e]) / this.Bc[e], i * (2 * Math.atan(Math.exp(r)) - .5 * Math.PI)]
        }
        ,
        o.prototype.bbox = function(t, e, i, r, n) {
            r && (e = Math.pow(2, i) - 1 - e);
            var o = [t * this.size, (+e + 1) * this.size]
              , s = [(+t + 1) * this.size, e * this.size]
              , a = this.ll(o, i).concat(this.ll(s, i));
            return "900913" === n ? this.convert(a, "900913") : a
        }
        ,
        o.prototype.xyz = function(t, e, i, r) {
            "900913" === r && (t = this.convert(t, "WGS84"));
            var n = [t[0], t[1]]
              , o = [t[2], t[3]]
              , s = this.px(n, e)
              , a = this.px(o, e)
              , l = [Math.floor(s[0] / this.size), Math.floor((a[0] - 1) / this.size)]
              , c = [Math.floor(a[1] / this.size), Math.floor((s[1] - 1) / this.size)]
              , u = {
                minX: Math.min.apply(Math, l) < 0 ? 0 : Math.min.apply(Math, l),
                minY: Math.min.apply(Math, c) < 0 ? 0 : Math.min.apply(Math, c),
                maxX: Math.max.apply(Math, l),
                maxY: Math.max.apply(Math, c)
            };
            if (i) {
                var h = {
                    minY: Math.pow(2, e) - 1 - u.maxY,
                    maxY: Math.pow(2, e) - 1 - u.minY
                };
                u.minY = h.minY,
                u.maxY = h.maxY
            }
            return u
        }
        ,
        o.prototype.convert = function(t, e) {
            return "900913" === e ? this.forward(t.slice(0, 2)).concat(this.forward(t.slice(2, 4))) : this.inverse(t.slice(0, 2)).concat(this.inverse(t.slice(2, 4)))
        }
        ,
        o.prototype.forward = function(t) {
            var i = [r * t[0] * e, r * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))];
            return i[0] > n && (i[0] = n),
            i[0] < -n && (i[0] = -n),
            i[1] > n && (i[1] = n),
            i[1] < -n && (i[1] = -n),
            i
        }
        ,
        o.prototype.inverse = function(t) {
            return [t[0] * i / r, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / r))) * i]
        }
        ,
        o
    }();
    void 0 !== e && (t.exports = e = i)
}
));
var a = r("ihkd7")
  , l = {};
function c(t) {
    return l[t = t || 256] || (l[t] = new a({
        size: t
    })),
    l[t]
}
o = function(t, e, i, r, n) {
    i = void 0 === i ? 0 : i,
    r = void 0 === r ? 20 : r;
    var o = c(n)
      , s = r
      , a = o.px([t[0], t[1]], s)
      , l = o.px([t[2], t[3]], s)
      , u = l[0] - a[0]
      , h = a[1] - l[1]
      , d = [u / e[0], h / e[1]]
      , p = [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2]
      , m = Math.floor(Math.min(s - Math.log(d[0]) / Math.log(2), s - Math.log(d[1]) / Math.log(2)))
      , f = Math.max(i, Math.min(r, m));
    return {
        center: p,
        zoom: f
    }
}
;
function u(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
}
var h = {
    value: ()=>{}
};
function d() {
    for (var t, e = 0, i = arguments.length, r = {}; e < i; ++e) {
        if (!(t = arguments[e] + "") || t in r || /[\s.]/.test(t))
            throw new Error("illegal type: " + t);
        r[t] = []
    }
    return new p(r)
}
function p(t) {
    this._ = t
}
function m(t, e) {
    return t.trim().split(/^|\s+/).map((function(t) {
        var i = ""
          , r = t.indexOf(".");
        if (r >= 0 && (i = t.slice(r + 1),
        t = t.slice(0, r)),
        t && !e.hasOwnProperty(t))
            throw new Error("unknown type: " + t);
        return {
            type: t,
            name: i
        }
    }
    ))
}
function f(t, e) {
    for (var i, r = 0, n = t.length; r < n; ++r)
        if ((i = t[r]).name === e)
            return i.value
}
function _(t, e, i) {
    for (var r = 0, n = t.length; r < n; ++r)
        if (t[r].name === e) {
            t[r] = h,
            t = t.slice(0, r).concat(t.slice(r + 1));
            break
        }
    return null != i && t.push({
        name: e,
        value: i
    }),
    t
}
p.prototype = d.prototype = {
    constructor: p,
    on: function(t, e) {
        var i, r = this._, n = m(t + "", r), o = -1, s = n.length;
        if (!(arguments.length < 2)) {
            if (null != e && "function" != typeof e)
                throw new Error("invalid callback: " + e);
            for (; ++o < s; )
                if (i = (t = n[o]).type)
                    r[i] = _(r[i], t.name, e);
                else if (null == e)
                    for (i in r)
                        r[i] = _(r[i], t.name, null);
            return this
        }
        for (; ++o < s; )
            if ((i = (t = n[o]).type) && (i = f(r[i], t.name)))
                return i
    },
    copy: function() {
        var t = {}
          , e = this._;
        for (var i in e)
            t[i] = e[i].slice();
        return new p(t)
    },
    call: function(t, e) {
        if ((i = arguments.length - 2) > 0)
            for (var i, r, n = new Array(i), o = 0; o < i; ++o)
                n[o] = arguments[o + 2];
        if (!this._.hasOwnProperty(t))
            throw new Error("unknown type: " + t);
        for (o = 0,
        i = (r = this._[t]).length; o < i; ++o)
            r[o].value.apply(e, n)
    },
    apply: function(t, e, i) {
        if (!this._.hasOwnProperty(t))
            throw new Error("unknown type: " + t);
        for (var r = this._[t], n = 0, o = r.length; n < o; ++n)
            r[n].value.apply(e, i)
    }
};
var g = d;
function y(t) {
    return function() {
        return this.matches(t)
    }
}
function x(t) {
    return function(e) {
        return e.matches(t)
    }
}
var v = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};
function b(t) {
    var e = t += ""
      , i = e.indexOf(":");
    return i >= 0 && "xmlns" !== (e = t.slice(0, i)) && (t = t.slice(i + 1)),
    v.hasOwnProperty(e) ? {
        space: v[e],
        local: t
    } : t
}
function w() {}
function z(t) {
    return null == t ? w : function() {
        return this.querySelector(t)
    }
}
function T(t) {
    return "object" == typeof t && "length"in t ? t : Array.from(t)
}
function E() {
    return []
}
function S(t) {
    return null == t ? E : function() {
        return this.querySelectorAll(t)
    }
}
var M = Array.prototype.find;
function A() {
    return this.firstElementChild
}
var I = Array.prototype.filter;
function C() {
    return this.children
}
function D(t) {
    return new Array(t.length)
}
function k(t, e) {
    this.ownerDocument = t.ownerDocument,
    this.namespaceURI = t.namespaceURI,
    this._next = null,
    this._parent = t,
    this.__data__ = e
}
function P(t) {
    return function() {
        return t
    }
}
function L(t, e, i, r, n, o) {
    for (var s, a = 0, l = e.length, c = o.length; a < c; ++a)
        (s = e[a]) ? (s.__data__ = o[a],
        r[a] = s) : i[a] = new k(t,o[a]);
    for (; a < l; ++a)
        (s = e[a]) && (n[a] = s)
}
function O(t, e, i, r, n, o, s) {
    var a, l, c, u = new Map, h = e.length, d = o.length, p = new Array(h);
    for (a = 0; a < h; ++a)
        (l = e[a]) && (p[a] = c = s.call(l, l.__data__, a, e) + "",
        u.has(c) ? n[a] = l : u.set(c, l));
    for (a = 0; a < d; ++a)
        c = s.call(t, o[a], a, o) + "",
        (l = u.get(c)) ? (r[a] = l,
        l.__data__ = o[a],
        u.delete(c)) : i[a] = new k(t,o[a]);
    for (a = 0; a < h; ++a)
        (l = e[a]) && u.get(p[a]) === l && (n[a] = l)
}
function R(t) {
    return t.__data__
}
function B(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
}
function F(t) {
    return function() {
        this.removeAttribute(t)
    }
}
function U(t) {
    return function() {
        this.removeAttributeNS(t.space, t.local)
    }
}
function N(t, e) {
    return function() {
        this.setAttribute(t, e)
    }
}
function G(t, e) {
    return function() {
        this.setAttributeNS(t.space, t.local, e)
    }
}
function j(t, e) {
    return function() {
        var i = e.apply(this, arguments);
        null == i ? this.removeAttribute(t) : this.setAttribute(t, i)
    }
}
function V(t, e) {
    return function() {
        var i = e.apply(this, arguments);
        null == i ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, i)
    }
}
function Z(t) {
    return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView
}
function J(t) {
    return function() {
        this.style.removeProperty(t)
    }
}
function X(t, e, i) {
    return function() {
        this.style.setProperty(t, e, i)
    }
}
function q(t, e, i) {
    return function() {
        var r = e.apply(this, arguments);
        null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, i)
    }
}
function $(t, e) {
    return t.style.getPropertyValue(e) || Z(t).getComputedStyle(t, null).getPropertyValue(e)
}
function Y(t) {
    return function() {
        delete this[t]
    }
}
function W(t, e) {
    return function() {
        this[t] = e
    }
}
function H(t, e) {
    return function() {
        var i = e.apply(this, arguments);
        null == i ? delete this[t] : this[t] = i
    }
}
function K(t) {
    return t.trim().split(/^|\s+/)
}
function Q(t) {
    return t.classList || new tt(t)
}
function tt(t) {
    this._node = t,
    this._names = K(t.getAttribute("class") || "")
}
function et(t, e) {
    for (var i = Q(t), r = -1, n = e.length; ++r < n; )
        i.add(e[r])
}
function it(t, e) {
    for (var i = Q(t), r = -1, n = e.length; ++r < n; )
        i.remove(e[r])
}
function rt(t) {
    return function() {
        et(this, t)
    }
}
function nt(t) {
    return function() {
        it(this, t)
    }
}
function ot(t, e) {
    return function() {
        (e.apply(this, arguments) ? et : it)(this, t)
    }
}
function st() {
    this.textContent = ""
}
function at(t) {
    return function() {
        this.textContent = t
    }
}
function lt(t) {
    return function() {
        var e = t.apply(this, arguments);
        this.textContent = null == e ? "" : e
    }
}
function ct() {
    this.innerHTML = ""
}
function ut(t) {
    return function() {
        this.innerHTML = t
    }
}
function ht(t) {
    return function() {
        var e = t.apply(this, arguments);
        this.innerHTML = null == e ? "" : e
    }
}
function dt() {
    this.nextSibling && this.parentNode.appendChild(this)
}
function pt() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
}
function mt(t) {
    return function() {
        var e = this.ownerDocument
          , i = this.namespaceURI;
        return "http://www.w3.org/1999/xhtml" === i && "http://www.w3.org/1999/xhtml" === e.documentElement.namespaceURI ? e.createElement(t) : e.createElementNS(i, t)
    }
}
function ft(t) {
    return function() {
        return this.ownerDocument.createElementNS(t.space, t.local)
    }
}
function _t(t) {
    var e = b(t);
    return (e.local ? ft : mt)(e)
}
function gt() {
    return null
}
function yt() {
    var t = this.parentNode;
    t && t.removeChild(this)
}
function xt() {
    var t = this.cloneNode(!1)
      , e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t
}
function vt() {
    var t = this.cloneNode(!0)
      , e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t
}
function bt(t) {
    return t.trim().split(/^|\s+/).map((function(t) {
        var e = ""
          , i = t.indexOf(".");
        return i >= 0 && (e = t.slice(i + 1),
        t = t.slice(0, i)),
        {
            type: t,
            name: e
        }
    }
    ))
}
function wt(t) {
    return function() {
        var e = this.__on;
        if (e) {
            for (var i, r = 0, n = -1, o = e.length; r < o; ++r)
                i = e[r],
                t.type && i.type !== t.type || i.name !== t.name ? e[++n] = i : this.removeEventListener(i.type, i.listener, i.options);
            ++n ? e.length = n : delete this.__on
        }
    }
}
function zt(t, e, i) {
    return function() {
        var r, n = this.__on, o = function(t) {
            return function(e) {
                t.call(this, e, this.__data__)
            }
        }(e);
        if (n)
            for (var s = 0, a = n.length; s < a; ++s)
                if ((r = n[s]).type === t.type && r.name === t.name)
                    return this.removeEventListener(r.type, r.listener, r.options),
                    this.addEventListener(r.type, r.listener = o, r.options = i),
                    void (r.value = e);
        this.addEventListener(t.type, o, i),
        r = {
            type: t.type,
            name: t.name,
            value: e,
            listener: o,
            options: i
        },
        n ? n.push(r) : this.__on = [r]
    }
}
function Tt(t, e, i) {
    var r = Z(t)
      , n = r.CustomEvent;
    "function" == typeof n ? n = new n(e,i) : (n = r.document.createEvent("Event"),
    i ? (n.initEvent(e, i.bubbles, i.cancelable),
    n.detail = i.detail) : n.initEvent(e, !1, !1)),
    t.dispatchEvent(n)
}
function Et(t, e) {
    return function() {
        return Tt(this, t, e)
    }
}
function St(t, e) {
    return function() {
        return Tt(this, t, e.apply(this, arguments))
    }
}
k.prototype = {
    constructor: k,
    appendChild: function(t) {
        return this._parent.insertBefore(t, this._next)
    },
    insertBefore: function(t, e) {
        return this._parent.insertBefore(t, e)
    },
    querySelector: function(t) {
        return this._parent.querySelector(t)
    },
    querySelectorAll: function(t) {
        return this._parent.querySelectorAll(t)
    }
},
tt.prototype = {
    add: function(t) {
        this._names.indexOf(t) < 0 && (this._names.push(t),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    remove: function(t) {
        var e = this._names.indexOf(t);
        e >= 0 && (this._names.splice(e, 1),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    contains: function(t) {
        return this._names.indexOf(t) >= 0
    }
};
var Mt = [null];
function At(t, e) {
    this._groups = t,
    this._parents = e
}
function It() {
    return new At([[document.documentElement]],Mt)
}
At.prototype = It.prototype = {
    constructor: At,
    select: function(t) {
        "function" != typeof t && (t = z(t));
        for (var e = this._groups, i = e.length, r = new Array(i), n = 0; n < i; ++n)
            for (var o, s, a = e[n], l = a.length, c = r[n] = new Array(l), u = 0; u < l; ++u)
                (o = a[u]) && (s = t.call(o, o.__data__, u, a)) && ("__data__"in o && (s.__data__ = o.__data__),
                c[u] = s);
        return new At(r,this._parents)
    },
    selectAll: function(t) {
        t = "function" == typeof t ? function(t) {
            return function() {
                var e = t.apply(this, arguments);
                return null == e ? [] : T(e)
            }
        }(t) : S(t);
        for (var e = this._groups, i = e.length, r = [], n = [], o = 0; o < i; ++o)
            for (var s, a = e[o], l = a.length, c = 0; c < l; ++c)
                (s = a[c]) && (r.push(t.call(s, s.__data__, c, a)),
                n.push(s));
        return new At(r,n)
    },
    selectChild: function(t) {
        return this.select(null == t ? A : function(t) {
            return function() {
                return M.call(this.children, t)
            }
        }("function" == typeof t ? t : x(t)))
    },
    selectChildren: function(t) {
        return this.selectAll(null == t ? C : function(t) {
            return function() {
                return I.call(this.children, t)
            }
        }("function" == typeof t ? t : x(t)))
    },
    filter: function(t) {
        "function" != typeof t && (t = y(t));
        for (var e = this._groups, i = e.length, r = new Array(i), n = 0; n < i; ++n)
            for (var o, s = e[n], a = s.length, l = r[n] = [], c = 0; c < a; ++c)
                (o = s[c]) && t.call(o, o.__data__, c, s) && l.push(o);
        return new At(r,this._parents)
    },
    data: function(t, e) {
        if (!arguments.length)
            return Array.from(this, R);
        var i = e ? O : L
          , r = this._parents
          , n = this._groups;
        "function" != typeof t && (t = P(t));
        for (var o = n.length, s = new Array(o), a = new Array(o), l = new Array(o), c = 0; c < o; ++c) {
            var u = r[c]
              , h = n[c]
              , d = h.length
              , p = T(t.call(u, u && u.__data__, c, r))
              , m = p.length
              , f = a[c] = new Array(m)
              , _ = s[c] = new Array(m)
              , g = l[c] = new Array(d);
            i(u, h, f, _, g, p, e);
            for (var y, x, v = 0, b = 0; v < m; ++v)
                if (y = f[v]) {
                    for (v >= b && (b = v + 1); !(x = _[b]) && ++b < m; )
                        ;
                    y._next = x || null
                }
        }
        return (s = new At(s,r))._enter = a,
        s._exit = l,
        s
    },
    enter: function() {
        return new At(this._enter || this._groups.map(D),this._parents)
    },
    exit: function() {
        return new At(this._exit || this._groups.map(D),this._parents)
    },
    join: function(t, e, i) {
        var r = this.enter()
          , n = this
          , o = this.exit();
        return r = "function" == typeof t ? t(r) : r.append(t + ""),
        null != e && (n = e(n)),
        null == i ? o.remove() : i(o),
        r && n ? r.merge(n).order() : n
    },
    merge: function(t) {
        if (!(t instanceof At))
            throw new Error("invalid merge");
        for (var e = this._groups, i = t._groups, r = e.length, n = i.length, o = Math.min(r, n), s = new Array(r), a = 0; a < o; ++a)
            for (var l, c = e[a], u = i[a], h = c.length, d = s[a] = new Array(h), p = 0; p < h; ++p)
                (l = c[p] || u[p]) && (d[p] = l);
        for (; a < r; ++a)
            s[a] = e[a];
        return new At(s,this._parents)
    },
    selection: function() {
        return this
    },
    order: function() {
        for (var t = this._groups, e = -1, i = t.length; ++e < i; )
            for (var r, n = t[e], o = n.length - 1, s = n[o]; --o >= 0; )
                (r = n[o]) && (s && 4 ^ r.compareDocumentPosition(s) && s.parentNode.insertBefore(r, s),
                s = r);
        return this
    },
    sort: function(t) {
        function e(e, i) {
            return e && i ? t(e.__data__, i.__data__) : !e - !i
        }
        t || (t = B);
        for (var i = this._groups, r = i.length, n = new Array(r), o = 0; o < r; ++o) {
            for (var s, a = i[o], l = a.length, c = n[o] = new Array(l), u = 0; u < l; ++u)
                (s = a[u]) && (c[u] = s);
            c.sort(e)
        }
        return new At(n,this._parents).order()
    },
    call: function() {
        var t = arguments[0];
        return arguments[0] = this,
        t.apply(null, arguments),
        this
    },
    nodes: function() {
        return Array.from(this)
    },
    node: function() {
        for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
            for (var r = t[e], n = 0, o = r.length; n < o; ++n) {
                var s = r[n];
                if (s)
                    return s
            }
        return null
    },
    size: function() {
        let t = 0;
        for (const e of this)
            ++t;
        return t
    },
    empty: function() {
        return !this.node()
    },
    each: function(t) {
        for (var e = this._groups, i = 0, r = e.length; i < r; ++i)
            for (var n, o = e[i], s = 0, a = o.length; s < a; ++s)
                (n = o[s]) && t.call(n, n.__data__, s, o);
        return this
    },
    attr: function(t, e) {
        var i = b(t);
        if (arguments.length < 2) {
            var r = this.node();
            return i.local ? r.getAttributeNS(i.space, i.local) : r.getAttribute(i)
        }
        return this.each((null == e ? i.local ? U : F : "function" == typeof e ? i.local ? V : j : i.local ? G : N)(i, e))
    },
    style: function(t, e, i) {
        return arguments.length > 1 ? this.each((null == e ? J : "function" == typeof e ? q : X)(t, e, null == i ? "" : i)) : $(this.node(), t)
    },
    property: function(t, e) {
        return arguments.length > 1 ? this.each((null == e ? Y : "function" == typeof e ? H : W)(t, e)) : this.node()[t]
    },
    classed: function(t, e) {
        var i = K(t + "");
        if (arguments.length < 2) {
            for (var r = Q(this.node()), n = -1, o = i.length; ++n < o; )
                if (!r.contains(i[n]))
                    return !1;
            return !0
        }
        return this.each(("function" == typeof e ? ot : e ? rt : nt)(i, e))
    },
    text: function(t) {
        return arguments.length ? this.each(null == t ? st : ("function" == typeof t ? lt : at)(t)) : this.node().textContent
    },
    html: function(t) {
        return arguments.length ? this.each(null == t ? ct : ("function" == typeof t ? ht : ut)(t)) : this.node().innerHTML
    },
    raise: function() {
        return this.each(dt)
    },
    lower: function() {
        return this.each(pt)
    },
    append: function(t) {
        var e = "function" == typeof t ? t : _t(t);
        return this.select((function() {
            return this.appendChild(e.apply(this, arguments))
        }
        ))
    },
    insert: function(t, e) {
        var i = "function" == typeof t ? t : _t(t)
          , r = null == e ? gt : "function" == typeof e ? e : z(e);
        return this.select((function() {
            return this.insertBefore(i.apply(this, arguments), r.apply(this, arguments) || null)
        }
        ))
    },
    remove: function() {
        return this.each(yt)
    },
    clone: function(t) {
        return this.select(t ? vt : xt)
    },
    datum: function(t) {
        return arguments.length ? this.property("__data__", t) : this.node().__data__
    },
    on: function(t, e, i) {
        var r, n, o = bt(t + ""), s = o.length;
        if (!(arguments.length < 2)) {
            for (a = e ? zt : wt,
            r = 0; r < s; ++r)
                this.each(a(o[r], e, i));
            return this
        }
        var a = this.node().__on;
        if (a)
            for (var l, c = 0, u = a.length; c < u; ++c)
                for (r = 0,
                l = a[c]; r < s; ++r)
                    if ((n = o[r]).type === l.type && n.name === l.name)
                        return l.value
    },
    dispatch: function(t, e) {
        return this.each(("function" == typeof e ? St : Et)(t, e))
    },
    [Symbol.iterator]: function*() {
        for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
            for (var r, n = t[e], o = 0, s = n.length; o < s; ++o)
                (r = n[o]) && (yield r)
    }
};
var Ct = It;
function Dt(t) {
    return "string" == typeof t ? new At([[document.querySelector(t)]],[document.documentElement]) : new At([[t]],Mt)
}
function kt(t, e, i) {
    t.prototype = e.prototype = i,
    i.constructor = t
}
function Pt(t, e) {
    var i = Object.create(t.prototype);
    for (var r in e)
        i[r] = e[r];
    return i
}
function Lt() {}
var Ot = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*"
  , Rt = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*"
  , Bt = /^#([0-9a-f]{3,8})$/
  , Ft = new RegExp("^rgb\\(" + ["\\s*([+-]?\\d+)\\s*", "\\s*([+-]?\\d+)\\s*", "\\s*([+-]?\\d+)\\s*"] + "\\)$")
  , Ut = new RegExp("^rgb\\(" + [Rt, Rt, Rt] + "\\)$")
  , Nt = new RegExp("^rgba\\(" + ["\\s*([+-]?\\d+)\\s*", "\\s*([+-]?\\d+)\\s*", "\\s*([+-]?\\d+)\\s*", Ot] + "\\)$")
  , Gt = new RegExp("^rgba\\(" + [Rt, Rt, Rt, Ot] + "\\)$")
  , jt = new RegExp("^hsl\\(" + [Ot, Rt, Rt] + "\\)$")
  , Vt = new RegExp("^hsla\\(" + [Ot, Rt, Rt, Ot] + "\\)$")
  , Zt = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
function Jt() {
    return this.rgb().formatHex()
}
function Xt() {
    return this.rgb().formatRgb()
}
function qt(t) {
    var e, i;
    return t = (t + "").trim().toLowerCase(),
    (e = Bt.exec(t)) ? (i = e[1].length,
    e = parseInt(e[1], 16),
    6 === i ? $t(e) : 3 === i ? new Kt(e >> 8 & 15 | e >> 4 & 240,e >> 4 & 15 | 240 & e,(15 & e) << 4 | 15 & e,1) : 8 === i ? Yt(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (255 & e) / 255) : 4 === i ? Yt(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, ((15 & e) << 4 | 15 & e) / 255) : null) : (e = Ft.exec(t)) ? new Kt(e[1],e[2],e[3],1) : (e = Ut.exec(t)) ? new Kt(255 * e[1] / 100,255 * e[2] / 100,255 * e[3] / 100,1) : (e = Nt.exec(t)) ? Yt(e[1], e[2], e[3], e[4]) : (e = Gt.exec(t)) ? Yt(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, e[4]) : (e = jt.exec(t)) ? ie(e[1], e[2] / 100, e[3] / 100, 1) : (e = Vt.exec(t)) ? ie(e[1], e[2] / 100, e[3] / 100, e[4]) : Zt.hasOwnProperty(t) ? $t(Zt[t]) : "transparent" === t ? new Kt(NaN,NaN,NaN,0) : null
}
function $t(t) {
    return new Kt(t >> 16 & 255,t >> 8 & 255,255 & t,1)
}
function Yt(t, e, i, r) {
    return r <= 0 && (t = e = i = NaN),
    new Kt(t,e,i,r)
}
function Wt(t) {
    return t instanceof Lt || (t = qt(t)),
    t ? new Kt((t = t.rgb()).r,t.g,t.b,t.opacity) : new Kt
}
function Ht(t, e, i, r) {
    return 1 === arguments.length ? Wt(t) : new Kt(t,e,i,null == r ? 1 : r)
}
function Kt(t, e, i, r) {
    this.r = +t,
    this.g = +e,
    this.b = +i,
    this.opacity = +r
}
function Qt() {
    return "#" + ee(this.r) + ee(this.g) + ee(this.b)
}
function te() {
    var t = this.opacity;
    return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")")
}
function ee(t) {
    return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? "0" : "") + t.toString(16)
}
function ie(t, e, i, r) {
    return r <= 0 ? t = e = i = NaN : i <= 0 || i >= 1 ? t = e = NaN : e <= 0 && (t = NaN),
    new ne(t,e,i,r)
}
function re(t) {
    if (t instanceof ne)
        return new ne(t.h,t.s,t.l,t.opacity);
    if (t instanceof Lt || (t = qt(t)),
    !t)
        return new ne;
    if (t instanceof ne)
        return t;
    var e = (t = t.rgb()).r / 255
      , i = t.g / 255
      , r = t.b / 255
      , n = Math.min(e, i, r)
      , o = Math.max(e, i, r)
      , s = NaN
      , a = o - n
      , l = (o + n) / 2;
    return a ? (s = e === o ? (i - r) / a + 6 * (i < r) : i === o ? (r - e) / a + 2 : (e - i) / a + 4,
    a /= l < .5 ? o + n : 2 - o - n,
    s *= 60) : a = l > 0 && l < 1 ? 0 : s,
    new ne(s,a,l,t.opacity)
}
function ne(t, e, i, r) {
    this.h = +t,
    this.s = +e,
    this.l = +i,
    this.opacity = +r
}
function oe(t, e, i) {
    return 255 * (t < 60 ? e + (i - e) * t / 60 : t < 180 ? i : t < 240 ? e + (i - e) * (240 - t) / 60 : e)
}
function se(t, e, i, r, n) {
    var o = t * t
      , s = o * t;
    return ((1 - 3 * t + 3 * o - s) * e + (4 - 6 * o + 3 * s) * i + (1 + 3 * t + 3 * o - 3 * s) * r + s * n) / 6
}
kt(Lt, qt, {
    copy: function(t) {
        return Object.assign(new this.constructor, this, t)
    },
    displayable: function() {
        return this.rgb().displayable()
    },
    hex: Jt,
    formatHex: Jt,
    formatHsl: function() {
        return re(this).formatHsl()
    },
    formatRgb: Xt,
    toString: Xt
}),
kt(Kt, Ht, Pt(Lt, {
    brighter: function(t) {
        return t = null == t ? 1.4285714285714286 : Math.pow(1.4285714285714286, t),
        new Kt(this.r * t,this.g * t,this.b * t,this.opacity)
    },
    darker: function(t) {
        return t = null == t ? .7 : Math.pow(.7, t),
        new Kt(this.r * t,this.g * t,this.b * t,this.opacity)
    },
    rgb: function() {
        return this
    },
    displayable: function() {
        return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
    },
    hex: Qt,
    formatHex: Qt,
    formatRgb: te,
    toString: te
})),
kt(ne, (function(t, e, i, r) {
    return 1 === arguments.length ? re(t) : new ne(t,e,i,null == r ? 1 : r)
}
), Pt(Lt, {
    brighter: function(t) {
        return t = null == t ? 1.4285714285714286 : Math.pow(1.4285714285714286, t),
        new ne(this.h,this.s,this.l * t,this.opacity)
    },
    darker: function(t) {
        return t = null == t ? .7 : Math.pow(.7, t),
        new ne(this.h,this.s,this.l * t,this.opacity)
    },
    rgb: function() {
        var t = this.h % 360 + 360 * (this.h < 0)
          , e = isNaN(t) || isNaN(this.s) ? 0 : this.s
          , i = this.l
          , r = i + (i < .5 ? i : 1 - i) * e
          , n = 2 * i - r;
        return new Kt(oe(t >= 240 ? t - 240 : t + 120, n, r),oe(t, n, r),oe(t < 120 ? t + 240 : t - 120, n, r),this.opacity)
    },
    displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
    },
    formatHsl: function() {
        var t = this.opacity;
        return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "hsl(" : "hsla(") + (this.h || 0) + ", " + 100 * (this.s || 0) + "%, " + 100 * (this.l || 0) + "%" + (1 === t ? ")" : ", " + t + ")")
    }
}));
var ae = t=>()=>t;
function le(t, e) {
    return function(i) {
        return t + i * e
    }
}
function ce(t) {
    return 1 == (t = +t) ? ue : function(e, i) {
        return i - e ? function(t, e, i) {
            return t = Math.pow(t, i),
            e = Math.pow(e, i) - t,
            i = 1 / i,
            function(r) {
                return Math.pow(t + r * e, i)
            }
        }(e, i, t) : ae(isNaN(e) ? i : e)
    }
}
function ue(t, e) {
    var i = e - t;
    return i ? le(t, i) : ae(isNaN(t) ? e : t)
}
var he = function t(e) {
    var i = ce(e);
    function r(t, e) {
        var r = i((t = Ht(t)).r, (e = Ht(e)).r)
          , n = i(t.g, e.g)
          , o = i(t.b, e.b)
          , s = ue(t.opacity, e.opacity);
        return function(e) {
            return t.r = r(e),
            t.g = n(e),
            t.b = o(e),
            t.opacity = s(e),
            t + ""
        }
    }
    return r.gamma = t,
    r
}(1);
function de(t) {
    return function(e) {
        var i, r, n = e.length, o = new Array(n), s = new Array(n), a = new Array(n);
        for (i = 0; i < n; ++i)
            r = Ht(e[i]),
            o[i] = r.r || 0,
            s[i] = r.g || 0,
            a[i] = r.b || 0;
        return o = t(o),
        s = t(s),
        a = t(a),
        r.opacity = 1,
        function(t) {
            return r.r = o(t),
            r.g = s(t),
            r.b = a(t),
            r + ""
        }
    }
}
de((function(t) {
    var e = t.length - 1;
    return function(i) {
        var r = i <= 0 ? i = 0 : i >= 1 ? (i = 1,
        e - 1) : Math.floor(i * e)
          , n = t[r]
          , o = t[r + 1]
          , s = r > 0 ? t[r - 1] : 2 * n - o
          , a = r < e - 1 ? t[r + 2] : 2 * o - n;
        return se((i - r / e) * e, s, n, o, a)
    }
}
)),
de((function(t) {
    var e = t.length;
    return function(i) {
        var r = Math.floor(((i %= 1) < 0 ? ++i : i) * e)
          , n = t[(r + e - 1) % e]
          , o = t[r % e]
          , s = t[(r + 1) % e]
          , a = t[(r + 2) % e];
        return se((i - r / e) * e, n, o, s, a)
    }
}
));
function pe(t, e) {
    return t = +t,
    e = +e,
    function(i) {
        return t * (1 - i) + e * i
    }
}
var me = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g
  , fe = new RegExp(me.source,"g");
function _e(t, e) {
    var i, r, n, o = me.lastIndex = fe.lastIndex = 0, s = -1, a = [], l = [];
    for (t += "",
    e += ""; (i = me.exec(t)) && (r = fe.exec(e)); )
        (n = r.index) > o && (n = e.slice(o, n),
        a[s] ? a[s] += n : a[++s] = n),
        (i = i[0]) === (r = r[0]) ? a[s] ? a[s] += r : a[++s] = r : (a[++s] = null,
        l.push({
            i: s,
            x: pe(i, r)
        })),
        o = fe.lastIndex;
    return o < e.length && (n = e.slice(o),
    a[s] ? a[s] += n : a[++s] = n),
    a.length < 2 ? l[0] ? function(t) {
        return function(e) {
            return t(e) + ""
        }
    }(l[0].x) : function(t) {
        return function() {
            return t
        }
    }(e) : (e = l.length,
    function(t) {
        for (var i, r = 0; r < e; ++r)
            a[(i = l[r]).i] = i.x(t);
        return a.join("")
    }
    )
}
var ge, ye = 180 / Math.PI, xe = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
};
function ve(t, e, i, r, n, o) {
    var s, a, l;
    return (s = Math.sqrt(t * t + e * e)) && (t /= s,
    e /= s),
    (l = t * i + e * r) && (i -= t * l,
    r -= e * l),
    (a = Math.sqrt(i * i + r * r)) && (i /= a,
    r /= a,
    l /= a),
    t * r < e * i && (t = -t,
    e = -e,
    l = -l,
    s = -s),
    {
        translateX: n,
        translateY: o,
        rotate: Math.atan2(e, t) * ye,
        skewX: Math.atan(l) * ye,
        scaleX: s,
        scaleY: a
    }
}
function be(t, e, i, r) {
    function n(t) {
        return t.length ? t.pop() + " " : ""
    }
    return function(o, s) {
        var a = []
          , l = [];
        return o = t(o),
        s = t(s),
        function(t, r, n, o, s, a) {
            if (t !== n || r !== o) {
                var l = s.push("translate(", null, e, null, i);
                a.push({
                    i: l - 4,
                    x: pe(t, n)
                }, {
                    i: l - 2,
                    x: pe(r, o)
                })
            } else
                (n || o) && s.push("translate(" + n + e + o + i)
        }(o.translateX, o.translateY, s.translateX, s.translateY, a, l),
        function(t, e, i, o) {
            t !== e ? (t - e > 180 ? e += 360 : e - t > 180 && (t += 360),
            o.push({
                i: i.push(n(i) + "rotate(", null, r) - 2,
                x: pe(t, e)
            })) : e && i.push(n(i) + "rotate(" + e + r)
        }(o.rotate, s.rotate, a, l),
        function(t, e, i, o) {
            t !== e ? o.push({
                i: i.push(n(i) + "skewX(", null, r) - 2,
                x: pe(t, e)
            }) : e && i.push(n(i) + "skewX(" + e + r)
        }(o.skewX, s.skewX, a, l),
        function(t, e, i, r, o, s) {
            if (t !== i || e !== r) {
                var a = o.push(n(o) + "scale(", null, ",", null, ")");
                s.push({
                    i: a - 4,
                    x: pe(t, i)
                }, {
                    i: a - 2,
                    x: pe(e, r)
                })
            } else
                1 === i && 1 === r || o.push(n(o) + "scale(" + i + "," + r + ")")
        }(o.scaleX, o.scaleY, s.scaleX, s.scaleY, a, l),
        o = s = null,
        function(t) {
            for (var e, i = -1, r = l.length; ++i < r; )
                a[(e = l[i]).i] = e.x(t);
            return a.join("")
        }
    }
}
var we = be((function(t) {
    const e = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(t + "");
    return e.isIdentity ? xe : ve(e.a, e.b, e.c, e.d, e.e, e.f)
}
), "px, ", "px)", "deg)")
  , ze = be((function(t) {
    return null == t ? xe : (ge || (ge = document.createElementNS("http://www.w3.org/2000/svg", "g")),
    ge.setAttribute("transform", t),
    (t = ge.transform.baseVal.consolidate()) ? ve((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : xe)
}
), ", ", ")", ")");
function Te(t) {
    return ((t = Math.exp(t)) + 1 / t) / 2
}
(function t(e, i, r) {
    function n(t, n) {
        var o, s, a = t[0], l = t[1], c = t[2], u = n[0], h = n[1], d = n[2], p = u - a, m = h - l, f = p * p + m * m;
        if (f < 1e-12)
            s = Math.log(d / c) / e,
            o = function(t) {
                return [a + t * p, l + t * m, c * Math.exp(e * t * s)]
            }
            ;
        else {
            var _ = Math.sqrt(f)
              , g = (d * d - c * c + r * f) / (2 * c * i * _)
              , y = (d * d - c * c - r * f) / (2 * d * i * _)
              , x = Math.log(Math.sqrt(g * g + 1) - g)
              , v = Math.log(Math.sqrt(y * y + 1) - y);
            s = (v - x) / e,
            o = function(t) {
                var r, n = t * s, o = Te(x), u = c / (i * _) * (o * (r = e * n + x,
                ((r = Math.exp(2 * r)) - 1) / (r + 1)) - function(t) {
                    return ((t = Math.exp(t)) - 1 / t) / 2
                }(x));
                return [a + u * p, l + u * m, c * o / Te(e * n + x)]
            }
        }
        return o.duration = 1e3 * s * e / Math.SQRT2,
        o
    }
    return n.rho = function(e) {
        var i = Math.max(.001, +e)
          , r = i * i;
        return t(i, r, r * r)
    }
    ,
    n
}
)(Math.SQRT2, 2, 4);
var Ee, Se, Me = 0, Ae = 0, Ie = 0, Ce = 0, De = 0, ke = 0, Pe = "object" == typeof performance && performance.now ? performance : Date, Le = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
    setTimeout(t, 17)
}
;
function Oe() {
    return De || (Le(Re),
    De = Pe.now() + ke)
}
function Re() {
    De = 0
}
function Be() {
    this._call = this._time = this._next = null
}
function Fe(t, e, i) {
    var r = new Be;
    return r.restart(t, e, i),
    r
}
function Ue() {
    De = (Ce = Pe.now()) + ke,
    Me = Ae = 0;
    try {
        !function() {
            Oe(),
            ++Me;
            for (var t, e = Ee; e; )
                (t = De - e._time) >= 0 && e._call.call(null, t),
                e = e._next;
            --Me
        }()
    } finally {
        Me = 0,
        function() {
            var t, e, i = Ee, r = 1 / 0;
            for (; i; )
                i._call ? (r > i._time && (r = i._time),
                t = i,
                i = i._next) : (e = i._next,
                i._next = null,
                i = t ? t._next = e : Ee = e);
            Se = t,
            Ge(r)
        }(),
        De = 0
    }
}
function Ne() {
    var t = Pe.now()
      , e = t - Ce;
    e > 1e3 && (ke -= e,
    Ce = t)
}
function Ge(t) {
    Me || (Ae && (Ae = clearTimeout(Ae)),
    t - De > 24 ? (t < 1 / 0 && (Ae = setTimeout(Ue, t - Pe.now() - ke)),
    Ie && (Ie = clearInterval(Ie))) : (Ie || (Ce = Pe.now(),
    Ie = setInterval(Ne, 1e3)),
    Me = 1,
    Le(Ue)))
}
function je(t, e, i) {
    var r = new Be;
    return e = null == e ? 0 : +e,
    r.restart((i=>{
        r.stop(),
        t(i + e)
    }
    ), e, i),
    r
}
Be.prototype = Fe.prototype = {
    constructor: Be,
    restart: function(t, e, i) {
        if ("function" != typeof t)
            throw new TypeError("callback is not a function");
        i = (null == i ? Oe() : +i) + (null == e ? 0 : +e),
        this._next || Se === this || (Se ? Se._next = this : Ee = this,
        Se = this),
        this._call = t,
        this._time = i,
        Ge()
    },
    stop: function() {
        this._call && (this._call = null,
        this._time = 1 / 0,
        Ge())
    }
};
var Ve = g("start", "end", "cancel", "interrupt")
  , Ze = [];
function Je(t, e, i, r, n, o) {
    var s = t.__transition;
    if (s) {
        if (i in s)
            return
    } else
        t.__transition = {};
    !function(t, e, i) {
        var r, n = t.__transition;
        function o(t) {
            i.state = 1,
            i.timer.restart(s, i.delay, i.time),
            i.delay <= t && s(t - i.delay)
        }
        function s(o) {
            var c, u, h, d;
            if (1 !== i.state)
                return l();
            for (c in n)
                if ((d = n[c]).name === i.name) {
                    if (3 === d.state)
                        return je(s);
                    4 === d.state ? (d.state = 6,
                    d.timer.stop(),
                    d.on.call("interrupt", t, t.__data__, d.index, d.group),
                    delete n[c]) : +c < e && (d.state = 6,
                    d.timer.stop(),
                    d.on.call("cancel", t, t.__data__, d.index, d.group),
                    delete n[c])
                }
            if (je((function() {
                3 === i.state && (i.state = 4,
                i.timer.restart(a, i.delay, i.time),
                a(o))
            }
            )),
            i.state = 2,
            i.on.call("start", t, t.__data__, i.index, i.group),
            2 === i.state) {
                for (i.state = 3,
                r = new Array(h = i.tween.length),
                c = 0,
                u = -1; c < h; ++c)
                    (d = i.tween[c].value.call(t, t.__data__, i.index, i.group)) && (r[++u] = d);
                r.length = u + 1
            }
        }
        function a(e) {
            for (var n = e < i.duration ? i.ease.call(null, e / i.duration) : (i.timer.restart(l),
            i.state = 5,
            1), o = -1, s = r.length; ++o < s; )
                r[o].call(t, n);
            5 === i.state && (i.on.call("end", t, t.__data__, i.index, i.group),
            l())
        }
        function l() {
            for (var r in i.state = 6,
            i.timer.stop(),
            delete n[e],
            n)
                return;
            delete t.__transition
        }
        n[e] = i,
        i.timer = Fe(o, 0, i.time)
    }(t, i, {
        name: e,
        index: r,
        group: n,
        on: Ve,
        tween: Ze,
        time: o.time,
        delay: o.delay,
        duration: o.duration,
        ease: o.ease,
        timer: null,
        state: 0
    })
}
function Xe(t, e) {
    var i = $e(t, e);
    if (i.state > 0)
        throw new Error("too late; already scheduled");
    return i
}
function qe(t, e) {
    var i = $e(t, e);
    if (i.state > 3)
        throw new Error("too late; already running");
    return i
}
function $e(t, e) {
    var i = t.__transition;
    if (!i || !(i = i[e]))
        throw new Error("transition not found");
    return i
}
function Ye(t, e) {
    var i, r, n, o = t.__transition, s = !0;
    if (o) {
        for (n in e = null == e ? null : e + "",
        o)
            (i = o[n]).name === e ? (r = i.state > 2 && i.state < 5,
            i.state = 6,
            i.timer.stop(),
            i.on.call(r ? "interrupt" : "cancel", t, t.__data__, i.index, i.group),
            delete o[n]) : s = !1;
        s && delete t.__transition
    }
}
function We(t, e) {
    var i, r;
    return function() {
        var n = qe(this, t)
          , o = n.tween;
        if (o !== i)
            for (var s = 0, a = (r = i = o).length; s < a; ++s)
                if (r[s].name === e) {
                    (r = r.slice()).splice(s, 1);
                    break
                }
        n.tween = r
    }
}
function He(t, e, i) {
    var r, n;
    if ("function" != typeof i)
        throw new Error;
    return function() {
        var o = qe(this, t)
          , s = o.tween;
        if (s !== r) {
            n = (r = s).slice();
            for (var a = {
                name: e,
                value: i
            }, l = 0, c = n.length; l < c; ++l)
                if (n[l].name === e) {
                    n[l] = a;
                    break
                }
            l === c && n.push(a)
        }
        o.tween = n
    }
}
function Ke(t, e, i) {
    var r = t._id;
    return t.each((function() {
        var t = qe(this, r);
        (t.value || (t.value = {}))[e] = i.apply(this, arguments)
    }
    )),
    function(t) {
        return $e(t, r).value[e]
    }
}
function Qe(t, e) {
    var i;
    return ("number" == typeof e ? pe : e instanceof qt ? he : (i = qt(e)) ? (e = i,
    he) : _e)(t, e)
}
function ti(t) {
    return function() {
        this.removeAttribute(t)
    }
}
function ei(t) {
    return function() {
        this.removeAttributeNS(t.space, t.local)
    }
}
function ii(t, e, i) {
    var r, n, o = i + "";
    return function() {
        var s = this.getAttribute(t);
        return s === o ? null : s === r ? n : n = e(r = s, i)
    }
}
function ri(t, e, i) {
    var r, n, o = i + "";
    return function() {
        var s = this.getAttributeNS(t.space, t.local);
        return s === o ? null : s === r ? n : n = e(r = s, i)
    }
}
function ni(t, e, i) {
    var r, n, o;
    return function() {
        var s, a, l = i(this);
        if (null != l)
            return (s = this.getAttribute(t)) === (a = l + "") ? null : s === r && a === n ? o : (n = a,
            o = e(r = s, l));
        this.removeAttribute(t)
    }
}
function oi(t, e, i) {
    var r, n, o;
    return function() {
        var s, a, l = i(this);
        if (null != l)
            return (s = this.getAttributeNS(t.space, t.local)) === (a = l + "") ? null : s === r && a === n ? o : (n = a,
            o = e(r = s, l));
        this.removeAttributeNS(t.space, t.local)
    }
}
function si(t, e) {
    return function(i) {
        this.setAttribute(t, e.call(this, i))
    }
}
function ai(t, e) {
    return function(i) {
        this.setAttributeNS(t.space, t.local, e.call(this, i))
    }
}
function li(t, e) {
    var i, r;
    function n() {
        var n = e.apply(this, arguments);
        return n !== r && (i = (r = n) && ai(t, n)),
        i
    }
    return n._value = e,
    n
}
function ci(t, e) {
    var i, r;
    function n() {
        var n = e.apply(this, arguments);
        return n !== r && (i = (r = n) && si(t, n)),
        i
    }
    return n._value = e,
    n
}
function ui(t, e) {
    return function() {
        Xe(this, t).delay = +e.apply(this, arguments)
    }
}
function hi(t, e) {
    return e = +e,
    function() {
        Xe(this, t).delay = e
    }
}
function di(t, e) {
    return function() {
        qe(this, t).duration = +e.apply(this, arguments)
    }
}
function pi(t, e) {
    return e = +e,
    function() {
        qe(this, t).duration = e
    }
}
function mi(t, e) {
    if ("function" != typeof e)
        throw new Error;
    return function() {
        qe(this, t).ease = e
    }
}
function fi(t, e, i) {
    var r, n, o = function(t) {
        return (t + "").trim().split(/^|\s+/).every((function(t) {
            var e = t.indexOf(".");
            return e >= 0 && (t = t.slice(0, e)),
            !t || "start" === t
        }
        ))
    }(e) ? Xe : qe;
    return function() {
        var s = o(this, t)
          , a = s.on;
        a !== r && (n = (r = a).copy()).on(e, i),
        s.on = n
    }
}
var _i = Ct.prototype.constructor;
function gi(t) {
    return function() {
        this.style.removeProperty(t)
    }
}
function yi(t, e, i) {
    return function(r) {
        this.style.setProperty(t, e.call(this, r), i)
    }
}
function xi(t, e, i) {
    var r, n;
    function o() {
        var o = e.apply(this, arguments);
        return o !== n && (r = (n = o) && yi(t, o, i)),
        r
    }
    return o._value = e,
    o
}
function vi(t) {
    return function(e) {
        this.textContent = t.call(this, e)
    }
}
function bi(t) {
    var e, i;
    function r() {
        var r = t.apply(this, arguments);
        return r !== i && (e = (i = r) && vi(r)),
        e
    }
    return r._value = t,
    r
}
var wi = 0;
function zi(t, e, i, r) {
    this._groups = t,
    this._parents = e,
    this._name = i,
    this._id = r
}
function Ti() {
    return ++wi
}
var Ei = Ct.prototype;
zi.prototype = function(t) {
    return Ct().transition(t)
}
.prototype = {
    constructor: zi,
    select: function(t) {
        var e = this._name
          , i = this._id;
        "function" != typeof t && (t = z(t));
        for (var r = this._groups, n = r.length, o = new Array(n), s = 0; s < n; ++s)
            for (var a, l, c = r[s], u = c.length, h = o[s] = new Array(u), d = 0; d < u; ++d)
                (a = c[d]) && (l = t.call(a, a.__data__, d, c)) && ("__data__"in a && (l.__data__ = a.__data__),
                h[d] = l,
                Je(h[d], e, i, d, h, $e(a, i)));
        return new zi(o,this._parents,e,i)
    },
    selectAll: function(t) {
        var e = this._name
          , i = this._id;
        "function" != typeof t && (t = S(t));
        for (var r = this._groups, n = r.length, o = [], s = [], a = 0; a < n; ++a)
            for (var l, c = r[a], u = c.length, h = 0; h < u; ++h)
                if (l = c[h]) {
                    for (var d, p = t.call(l, l.__data__, h, c), m = $e(l, i), f = 0, _ = p.length; f < _; ++f)
                        (d = p[f]) && Je(d, e, i, f, p, m);
                    o.push(p),
                    s.push(l)
                }
        return new zi(o,s,e,i)
    },
    filter: function(t) {
        "function" != typeof t && (t = y(t));
        for (var e = this._groups, i = e.length, r = new Array(i), n = 0; n < i; ++n)
            for (var o, s = e[n], a = s.length, l = r[n] = [], c = 0; c < a; ++c)
                (o = s[c]) && t.call(o, o.__data__, c, s) && l.push(o);
        return new zi(r,this._parents,this._name,this._id)
    },
    merge: function(t) {
        if (t._id !== this._id)
            throw new Error;
        for (var e = this._groups, i = t._groups, r = e.length, n = i.length, o = Math.min(r, n), s = new Array(r), a = 0; a < o; ++a)
            for (var l, c = e[a], u = i[a], h = c.length, d = s[a] = new Array(h), p = 0; p < h; ++p)
                (l = c[p] || u[p]) && (d[p] = l);
        for (; a < r; ++a)
            s[a] = e[a];
        return new zi(s,this._parents,this._name,this._id)
    },
    selection: function() {
        return new _i(this._groups,this._parents)
    },
    transition: function() {
        for (var t = this._name, e = this._id, i = Ti(), r = this._groups, n = r.length, o = 0; o < n; ++o)
            for (var s, a = r[o], l = a.length, c = 0; c < l; ++c)
                if (s = a[c]) {
                    var u = $e(s, e);
                    Je(s, t, i, c, a, {
                        time: u.time + u.delay + u.duration,
                        delay: 0,
                        duration: u.duration,
                        ease: u.ease
                    })
                }
        return new zi(r,this._parents,t,i)
    },
    call: Ei.call,
    nodes: Ei.nodes,
    node: Ei.node,
    size: Ei.size,
    empty: Ei.empty,
    each: Ei.each,
    on: function(t, e) {
        var i = this._id;
        return arguments.length < 2 ? $e(this.node(), i).on.on(t) : this.each(fi(i, t, e))
    },
    attr: function(t, e) {
        var i = b(t)
          , r = "transform" === i ? ze : Qe;
        return this.attrTween(t, "function" == typeof e ? (i.local ? oi : ni)(i, r, Ke(this, "attr." + t, e)) : null == e ? (i.local ? ei : ti)(i) : (i.local ? ri : ii)(i, r, e))
    },
    attrTween: function(t, e) {
        var i = "attr." + t;
        if (arguments.length < 2)
            return (i = this.tween(i)) && i._value;
        if (null == e)
            return this.tween(i, null);
        if ("function" != typeof e)
            throw new Error;
        var r = b(t);
        return this.tween(i, (r.local ? li : ci)(r, e))
    },
    style: function(t, e, i) {
        var r = "transform" == (t += "") ? we : Qe;
        return null == e ? this.styleTween(t, function(t, e) {
            var i, r, n;
            return function() {
                var o = $(this, t)
                  , s = (this.style.removeProperty(t),
                $(this, t));
                return o === s ? null : o === i && s === r ? n : n = e(i = o, r = s)
            }
        }(t, r)).on("end.style." + t, gi(t)) : "function" == typeof e ? this.styleTween(t, function(t, e, i) {
            var r, n, o;
            return function() {
                var s = $(this, t)
                  , a = i(this)
                  , l = a + "";
                return null == a && (this.style.removeProperty(t),
                l = a = $(this, t)),
                s === l ? null : s === r && l === n ? o : (n = l,
                o = e(r = s, a))
            }
        }(t, r, Ke(this, "style." + t, e))).each(function(t, e) {
            var i, r, n, o, s = "style." + e, a = "end." + s;
            return function() {
                var l = qe(this, t)
                  , c = l.on
                  , u = null == l.value[s] ? o || (o = gi(e)) : void 0;
                c === i && n === u || (r = (i = c).copy()).on(a, n = u),
                l.on = r
            }
        }(this._id, t)) : this.styleTween(t, function(t, e, i) {
            var r, n, o = i + "";
            return function() {
                var s = $(this, t);
                return s === o ? null : s === r ? n : n = e(r = s, i)
            }
        }(t, r, e), i).on("end.style." + t, null)
    },
    styleTween: function(t, e, i) {
        var r = "style." + (t += "");
        if (arguments.length < 2)
            return (r = this.tween(r)) && r._value;
        if (null == e)
            return this.tween(r, null);
        if ("function" != typeof e)
            throw new Error;
        return this.tween(r, xi(t, e, null == i ? "" : i))
    },
    text: function(t) {
        return this.tween("text", "function" == typeof t ? function(t) {
            return function() {
                var e = t(this);
                this.textContent = null == e ? "" : e
            }
        }(Ke(this, "text", t)) : function(t) {
            return function() {
                this.textContent = t
            }
        }(null == t ? "" : t + ""))
    },
    textTween: function(t) {
        var e = "text";
        if (arguments.length < 1)
            return (e = this.tween(e)) && e._value;
        if (null == t)
            return this.tween(e, null);
        if ("function" != typeof t)
            throw new Error;
        return this.tween(e, bi(t))
    },
    remove: function() {
        return this.on("end.remove", (t = this._id,
        function() {
            var e = this.parentNode;
            for (var i in this.__transition)
                if (+i !== t)
                    return;
            e && e.removeChild(this)
        }
        ));
        var t
    },
    tween: function(t, e) {
        var i = this._id;
        if (t += "",
        arguments.length < 2) {
            for (var r, n = $e(this.node(), i).tween, o = 0, s = n.length; o < s; ++o)
                if ((r = n[o]).name === t)
                    return r.value;
            return null
        }
        return this.each((null == e ? We : He)(i, t, e))
    },
    delay: function(t) {
        var e = this._id;
        return arguments.length ? this.each(("function" == typeof t ? ui : hi)(e, t)) : $e(this.node(), e).delay
    },
    duration: function(t) {
        var e = this._id;
        return arguments.length ? this.each(("function" == typeof t ? di : pi)(e, t)) : $e(this.node(), e).duration
    },
    ease: function(t) {
        var e = this._id;
        return arguments.length ? this.each(mi(e, t)) : $e(this.node(), e).ease
    },
    easeVarying: function(t) {
        if ("function" != typeof t)
            throw new Error;
        return this.each(function(t, e) {
            return function() {
                var i = e.apply(this, arguments);
                if ("function" != typeof i)
                    throw new Error;
                qe(this, t).ease = i
            }
        }(this._id, t))
    },
    end: function() {
        var t, e, i = this, r = i._id, n = i.size();
        return new Promise((function(o, s) {
            var a = {
                value: s
            }
              , l = {
                value: function() {
                    0 == --n && o()
                }
            };
            i.each((function() {
                var i = qe(this, r)
                  , n = i.on;
                n !== t && ((e = (t = n).copy())._.cancel.push(a),
                e._.interrupt.push(a),
                e._.end.push(l)),
                i.on = e
            }
            )),
            0 === n && o()
        }
        ))
    },
    [Symbol.iterator]: Ei[Symbol.iterator]
};
var Si = {
    time: null,
    delay: 0,
    duration: 250,
    ease: function(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2
    }
};
function Mi(t, e) {
    for (var i; !(i = t.__transition) || !(i = i[e]); )
        if (!(t = t.parentNode))
            throw new Error(`transition ${e} not found`);
    return i
}
Ct.prototype.interrupt = function(t) {
    return this.each((function() {
        Ye(this, t)
    }
    ))
}
,
Ct.prototype.transition = function(t) {
    var e, i;
    t instanceof zi ? (e = t._id,
    t = t._name) : (e = Ti(),
    (i = Si).time = Oe(),
    t = null == t ? null : t + "");
    for (var r = this._groups, n = r.length, o = 0; o < n; ++o)
        for (var s, a = r[o], l = a.length, c = 0; c < l; ++c)
            (s = a[c]) && Je(s, t, e, c, a, i || Mi(s, e));
    return new zi(r,this._parents,t,e)
}
;
const {abs: Ai, max: Ii, min: Ci} = Math;
function Di(t) {
    return [+t[0], +t[1]]
}
function ki(t) {
    return [Di(t[0]), Di(t[1])]
}
["w", "e"].map(Pi),
["n", "s"].map(Pi),
["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(Pi);
function Pi(t) {
    return {
        type: t
    }
}
function Li(t, e, i) {
    this.k = t,
    this.x = e,
    this.y = i
}
Li.prototype = {
    constructor: Li,
    scale: function(t) {
        return 1 === t ? this : new Li(this.k * t,this.x,this.y)
    },
    translate: function(t, e) {
        return 0 === t & 0 === e ? this : new Li(this.k,this.x + this.k * t,this.y + this.k * e)
    },
    apply: function(t) {
        return [t[0] * this.k + this.x, t[1] * this.k + this.y]
    },
    applyX: function(t) {
        return t * this.k + this.x
    },
    applyY: function(t) {
        return t * this.k + this.y
    },
    invert: function(t) {
        return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k]
    },
    invertX: function(t) {
        return (t - this.x) / this.k
    },
    invertY: function(t) {
        return (t - this.y) / this.k
    },
    rescaleX: function(t) {
        return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t))
    },
    rescaleY: function(t) {
        return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t))
    },
    toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
    }
};
new Li(1,0,0);
Li.prototype;
let Oi = {};
const Ri = new URLSearchParams(window.location.search);
null == Ri.get("country") && function() {
    let t = null
      , e = null;
    const i = new XMLHttpRequest;
    i.open("GET", "https://www.cloudflare.com/cdn-cgi/trace"),
    i.onreadystatechange = ()=>{
        i.readyState == XMLHttpRequest.DONE && 200 == i.status && (e = i.responseText.match(/loc=([^\n+]*)/)[1].toUpperCase(),
        t = Qi.boundaries.indexOf(e) > -1 ? e : ["HK", "MO"].indexOf(e) > -1 ? "CN" : "KR",
        console.log("Test:",e),
        Ri.set("country", "KR"),
        cr(e, t))
    }
    ,
    i.send(null)
}(),
n.accessToken = "pk.eyJ1Ijoid2VhdGhlciIsImEiOiJjamxncnYwMmYxYXgxM3BzNWEyNHUzbmhhIn0.UqrZwn6qTa6WJwdHjPVUfA",
n.setRTLTextPlugin("https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js", null, !0);
const Bi = new n.Map({
    container: "map",
    style: "mapbox://styles/mapbox/light-v11",
    center: [-99.9, 41.5],
    zoom: 0,
    hash: !0,
    bearingSnap: 0
});
"true" == Ri.get("embedded") && Bi.scrollZoom.disable();
const Fi = new MapboxGeocoder({
    accessToken: n.accessToken,
    mapboxgl: n
});
Bi.addControl(Fi, "top-right"),
Bi.addControl(new n.NavigationControl({
    visualizePitch: !0
}), "top-right");
const Ui = new function() {
    this.country = Ri.get("country") || "KR",
    this.layer = Ri.get("layer") || "adm2",
    this.worldview = Ri.get("worldview") || "KR"
}
  , Ni = document.getElementById("selectCountry");
let Gi = document.getElementById("selectLevel");
const ji = document.getElementById("selectWorldview")
  , Vi = document.getElementById("loading");
let Zi, Ji, Xi, qi, $i, Yi = Ui.country, Wi = Ui.layer, Hi = Ui.worldview, Ki = "./lib/lookups/" + Yi + "/" + Wi + ".json?v=4.0";
const Qi = {
    basemap: ["CN", "IN", "JP"],
    boundaries: ["CN", "IN", "JP", "AR", "MA", "RU", "TR", "RS"],
    geocoder: ["CN", "IN", "JP", "AR", "MA", "RU", "TR"]
}
  , tr = new n.Popup({
    closeButton: !1,
    closeOnClick: !1,
    offset: {
        top: [0, 10],
        bottom: [0, -10]
    }
});
let er, ir, rr, nr;
function or() {
    let t;
    const e = {
        adm: "Administrative",
        loc: "Locality",
        leg: "Legislative",
        pos: "Postal",
        sta: "Statistical"
    };
    Object.keys(s[Yi]).sort().forEach((i=>{
        if ("bbox" === i || "mapbox_id" === i)
            return;
        if (i.substr(0, 3) !== t) {
            t = i.substr(0, 3);
            const r = document.createElement("option");
            r.text = e[t],
            r.disabled = !0,
            r.value = i,
            Gi.add(r)
        }
        const r = document.createElement("option");
        r.text = i + " : " + s[Yi][i].description,
        r.value = i,
        Gi.add(r)
    }
    )),
    document.getElementById("selectLevel").value = s[Yi].hasOwnProperty(Wi) ? Wi : s[Yi].hasOwnProperty("adm2") ? "adm2" : "adm2"
}
function sr() {
    Ri.set("country", document.getElementById("selectCountry").value),
    Ri.set("layer", document.getElementById("selectLevel").value),
    Ri.set("worldview", document.getElementById("selectWorldview").value),
    window.history.replaceState({}, "", `${location.pathname}?${Ri}${location.hash}`),
    Vi.style.visibility = "visible",
    tr.remove(),
    tr.addTo(Bi);
    const t = document.getElementById("selectLevel").value
      , e = Bi.getStyle();
    if (Bi.off("mousemove", er),
    Bi.off("click", ir),
    tr.remove(),
    t !== Wi && "adm0" !== Wi) {
        e.layers.forEach((t=>{
            t.id.search(Wi) > -1 && Bi.removeLayer(t.id)
        }
        ));
        for (const t in e.sources)
            t.search(Wi) > -1 && Bi.removeSource(t)
    }
    const i = Wi.slice(0, -1);
    if (t.slice(0, -1) !== i)
        for (const t in e.sources)
            t.search(i + "Points") > -1 && Bi.removeSource(i + "Points");
    if (Yi = "KR",
    Wi = t,
    Ki = "./lib/lookups/" + Yi + "/adm2.json",
    "RU" === Yi)
        Bi.setProjection({
            name: "mercator"
        }),
        Bi.setBearing(0);
    else
        Bi.setProjection({
            name: "globe"
        }),
        Bi.setBearing(0);
    var r, n;
    r = lr,
    n = ar,
    fetch(Ki).then((t=>t.json())).then((t=>{
        r(t, Wi),
        n(Wi)
    }
    ))
}
function ar(t) {
    const e = ur(Bi, (t=>t.hasOwnProperty("layout") && t.layout.hasOwnProperty("text-font")))
      , i = e ? e[0].id : null;
    function r(t) {
        return ["to-color", ["concat", "hsla(", ["*", ["+", ["+", ["index-of", ["slice", ["get", "mapbox_id"], 17, 18], "hVY1kTvjzLfDKZAEwisGCqtNmMyFabS8n3g04WUJQ96cB7eOulrXR2PoI5xdHp"], ["index-of", ["slice", ["get", "mapbox_id"], 16, 17], "t6QRGZeAg4Mnmf2vILHFB7zJVE5KbPaiNYTcj1u30Sw8dXWlkysqpChOxU9orD"]], ["index-of", ["slice", ["get", "mapbox_id"], 15, 16], "Uo56bWvJM8D7ABqLQeERu0VmHNiFPSsx3apYhKnjy9CIrGZOTz1lwfX24kcgtd"]], 40], `, 95%, 90%,${t})`]]
    }
    Bi.setPaintProperty("water", "fill-opacity", .7),
    e.forEach((t=>{
        if (Qi.basemap.indexOf(Hi) > -1 && ("place_label" === t["source-layer"] || "place_label" === t["source-layer"])) {
            console.log(Qi.basemap.indexOf(Hi));
            let e = Bi.getFilter(t.id).map((t=>"object" == typeof t && Qi.boundaries.some((e=>JSON.stringify(t).includes(e))) ? JSON.parse(JSON.stringify(t).replace(new RegExp(Qi.boundaries.join("|"),"g"), Hi)) : t));
            Bi.setFilter(t.id, e)
        }
        "country-label" === t.id ? Bi.setPaintProperty(t.id, "text-opacity", ["case", ["==", ["get", "iso_3166_1"], Yi], 1, .7]) : (Bi.setPaintProperty(t.id, "text-opacity", ["case", ["==", ["get", "iso_3166_1"], Yi], .9, .5]),
        Bi.setPaintProperty(t.id, "icon-opacity", ["case", ["==", ["get", "iso_3166_1"], Yi], .7, .1]))
    }
    )),
    Bi.getSource("admLines") || (ur(Bi, (t=>"water" === t["source-layer"])).map((t=>t.id)).forEach((t=>Bi.setPaintProperty(t, "fill-color", "#f0faff"))),
    ur(Bi, (t=>"admin" === t["source-layer"])).map((t=>t.id)).forEach((t=>Bi.removeLayer(t))),
    Bi.addSource("admLines", {
        type: "vector",
        url: "mapbox://mapbox.boundaries-admLines-v4",
        promoteId: "mapbox_id"
    }),
    Bi.addSource("adm0", {
        type: "vector",
        url: "mapbox://mapbox.boundaries-adm0-v4",
        promoteId: "mapbox_id"
    }),
    Bi.addLayer({
        id: "adm0-outline",
        type: "line",
        source: "adm0",
        "source-layer": "boundaries_admin_0",
        layout: {},
        paint: {
            "line-width": 2
        }
    }, i),
    Bi.addLayer({
        id: "adm0",
        type: "fill",
        source: "adm0",
        "source-layer": "boundaries_admin_0",
        layout: {},
        paint: {
            "fill-opacity": 1
        }
    }, "water"),
    Bi.addLayer({
        id: "admLines-0-bg",
        type: "line",
        source: "admLines",
        "source-layer": "boundaries_admin_lines",
        layout: {},
        paint: {
            "line-opacity": ["interpolate", ["linear"], ["zoom"], 3, 0, 4, .5],
            "line-color": "#d6d6d6",
            "line-width": ["interpolate", ["linear"], ["zoom"], 3, 3.5, 10, 8],
            "line-blur": ["interpolate", ["linear"], ["zoom"], 3, 0, 10, 2]
        }
    }, i),
    Bi.addLayer({
        id: "admLines-1-bg",
        type: "line",
        source: "admLines",
        "source-layer": "boundaries_admin_lines",
        layout: {},
        paint: {
            "line-opacity": ["interpolate", ["linear"], ["zoom"], 3, 0, 8, .75],
            "line-color": ["interpolate", ["linear"], ["zoom"], 8, "hsl(185, 0%, 84%)", 16, "hsl(185, 0%, 84%)"],
            "line-width": ["interpolate", ["linear"], ["zoom"], 7, 3.75, 12, 5.5],
            "line-dasharray": [1, 0],
            "line-blur": ["interpolate", ["linear"], ["zoom"], 3, 0, 8, 3]
        }
    }, i),
    Bi.addLayer({
        id: "admLines-0",
        type: "line",
        source: "admLines",
        "source-layer": "boundaries_admin_lines",
        layout: {},
        paint: {
            "line-color": "#ababab",
            "line-width": ["interpolate", ["linear"], ["zoom"], 3, .5, 10, 2],
            "line-dasharray": [10, 0]
        }
    }, i),
    Bi.addLayer({
        id: "admLines-0-disputed",
        type: "line",
        source: "admLines",
        "source-layer": "boundaries_admin_lines",
        layout: {},
        paint: {
            "line-color": "#ababab",
            "line-width": ["interpolate", ["linear"], ["zoom"], 3, .5, 10, 2],
            "line-dasharray": ["step", ["zoom"], ["literal", [3.25, 3.25]], 6, ["literal", [2.5, 2.5]], 7, ["literal", [2, 2.25]], 8, ["literal", [1.75, 2]]]
        }
    }, i),
    Bi.addLayer({
        id: "admLines-1",
        type: "line",
        source: "admLines",
        "source-layer": "boundaries_admin_lines",
        layout: {},
        paint: {
            "line-color": ["interpolate", ["linear"], ["zoom"], 3, "hsl(185, 0%, 83%)", 7, "hsl(185, 3%, 68%)"],
            "line-width": ["interpolate", ["linear"], ["zoom"], 7, .75, 12, 1.5],
            "line-dasharray": ["step", ["zoom"], ["literal", [2, 0]], 7, ["literal", [2, 2, 6, 2]]]
        }
    }, i)),
    Bi.setPaintProperty("adm0", "fill-color", ["case", ["==", ["get", "iso_3166_1"], Yi], "hsla(0,0,100%,0)", ["==", ["feature-state", "hover"], 1], "hsla(0,0,100%,0.2)", "hsla(0,0,90%,0.7)"]),
    Bi.setPaintProperty("adm0-outline", "line-color", ["case", ["==", ["get", "iso_3166_1"], Yi], "hsla(0,0,50%,1)", ["==", ["feature-state", "hover"], 1], "hsla(0,0,50%,1)", "hsla(0,0,80%,0.5)"]),
    Qi.geocoder.indexOf(Hi) > -1 && Fi.setWorldview(Hi.toLowerCase()),
    Bi.setFilter("adm0", ["all", ["!", ["has", "dispute"]], hr(Hi)]),
    Bi.setFilter("adm0-outline", ["all", ["!", ["has", "dispute"]], hr(Hi)]),
    Bi.setFilter("admLines-0-bg", ["all", ["==", ["get", "level"], 0], hr(Hi)]),
    Bi.setFilter("admLines-1-bg", ["all", ["==", ["get", "level"], 1], hr(Hi)]),
    Bi.setFilter("admLines-0", ["all", ["==", ["get", "level"], 0], ["==", ["get", "dispute"], "false"], hr(Hi)]),
    Bi.setFilter("admLines-0-disputed", ["all", ["==", ["get", "level"], 0], ["==", ["get", "dispute"], "true"], hr(Hi)]),
    Bi.setFilter("admLines-1", ["all", ["==", ["get", "level"], 1], hr(Hi)]),
    Bi.getLayer(t + "join") || (Bi.addLayer({
        id: t + "line",
        type: "line",
        source: t + "join",
        "source-layer": Zi,
        paint: {
            "line-opacity": .7,
            "line-color": ["interpolate", ["linear"], ["zoom"], 6, "hsla(0, 0%, 60%,0.1)", 14, "hsla(0, 0%, 20%,0.8)"]
        }
    }, i),
    Bi.addLayer({
        id: t + "join",
        type: "fill",
        source: t + "join",
        "source-layer": Zi,
        paint: {
            "fill-opacity": 1
        }
    }, "water"),
    Bi.addLayer({
        id: t + "Points",
        type: "symbol",
        source: t.slice(0, -1) + "Points",
        "source-layer": Zi.replace("boundaries", "points"),
        layout: {
            "text-field": ["concat", ["get", "name"], "\n", ["get", "name_en"]],
            "text-font": ["Open Sans SemiBold", "Arial Unicode MS Bold"],
            "text-size": 14,
            "icon-image": "dot-11",
            "text-anchor": "bottom",
            "text-offset": [0, -.3]
        },
        paint: {
            "text-halo-color": "hsla(279, 1%, 100%, 0.94)",
            "text-halo-width": 2
        },
        filter: ["==", ["id"], -1]
    })),
    Bi.setFilter(t + "join", rr),
    Bi.setPaintProperty(t + "join", "fill-color", ["case", ["==", ["feature-state", "select"], 1], r(.9), ["==", ["feature-state", "hover"], 1], r(.7), r(.5)]),
    Bi.setPaintProperty(t + "join", "fill-outline-color", ["interpolate", ["linear"], ["zoom"], 6, "hsla(0, 0%, 60%,0.1)", 14, "hsla(0, 0%, 20%,0.8)"]),
    Bi.getLayer(t + "selectionLine") || Bi.addLayer({
        id: t + "selectionLine",
        type: "line",
        source: t + "join",
        "source-layer": Zi,
        layout: {},
        paint: {
            "line-color": ["case", ["==", ["feature-state", "select"], 1], "hsla(30, 90%, 30%,1)", ["==", ["feature-state", "hover"], 1], "hsla(0, 0%, 30%,0.6)", "rgba(0,0,0,0)"],
            "line-width": {
                stops: [[5, 1], [14, 3]]
            }
        }
    }, i),
    Bi.setFilter(t + "selectionLine", rr)
}
function lr(t, e) {
    Zi = t.polyLayerName,
    Oi = {},
    Hi = document.getElementById("selectWorldview").value,
    Bi.getSource(e + "join") || Bi.addSource(e + "join", {
        type: "vector",
        url: "mapbox://" + t.polyTilesetName,
        promoteId: "mapbox_id"
    });
    const i = e.slice(0, -1);
    function r() {
        [Hi, "all"].forEach((e=>{
            if (e in t)
                for (const i in t[e])
                    Oi[i] = t[e][i],v
                    Oi[i].worldview = e
        }
        ));
        const i = Object.keys(Oi).length;
        var r;
        if (document.getElementById("boundaryCount").innerHTML = `<span class="txt-bold">${r = i,
        r.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}</span> ${1 === i ? "Boundary" : "Boundaries"}`,
        i < 5e4) {
            const i = [];
            Object.keys(Oi).forEach((t=>{
                i.push(Object.assign(Oi[t], {
                    id: t
                }))
            }
            )),
            i.sort(((t,e)=>t.hasOwnProperty("name_en") ? u(t.name_en, e.name_en) : u(t.name, e.name))),
            function(i) {
                const r = e.slice(0, -1) + "Points";
                Dt("#table table").remove();
                const n = Dt("#table").append("table").attr("class", "table txt-xs cursor-pointer");
                Dt("#table").on("mouseleave", (i=>{
                    const r = rr;
                    r[3] = ["==", ["id"], 0],
                    Bi.setFilter(e + "Points", r),
                    Bi.removeFeatureState({
                        source: e + "join",
                        sourceLayer: t.polyLayerName
                    })
                }
                ));
                const o = n.selectAll("tr").data(i).enter().append("tr").attr("id", (t=>t.id)).on("mousemove", (i=>{
                    const n = i.currentTarget.id
                      , o = Bi.getZoom()
                      , s = Bi.querySourceFeatures(r, {
                        sourceLayer: t.pointLayerName,
                        filter: ["==", ["get", "mapbox_id"], n]
                    });
                    function a(i, o) {
                        const s = rr;
                        s[3] = ["==", ["get", "mapbox_id"], n],
                        Bi.setFilter(e + "Points", s),
                        Bi.removeFeatureState({
                            source: r,
                            sourceLayer: t.pointLayerName
                        }),
                        Bi.removeFeatureState({
                            source: e + "join",
                            sourceLayer: t.polyLayerName
                        }),
                        Bi.setFeatureState({
                            id: n,
                            source: r,
                            sourceLayer: t.pointLayerName
                        }, {
                            hover: 1
                        }),
                        Bi.setFeatureState({
                            id: n,
                            source: e + "join",
                            sourceLayer: t.polyLayerName
                        }, {
                            hover: 1
                        }),
                        Bi.flyTo({
                            zoom: o,
                            center: i[0].geometry.coordinates,
                            speed: .9
                        })
                    }
                    s.length ? a(s, o) : Bi.fitBounds($i, {
                        duration: .5,
                        padding: 20
                    })
                }
                ));
                o.selectAll("td").data((t=>["name"].map((e=>{
                    let i = "";
                    const r = t.hasOwnProperty("code") ? `<span class="txt-kbd">${t.code}</span> ` : "";
                    return i += t.hasOwnProperty("wikidata_id") ? `<a class="link" target="_blank" href="https://www.wikidata.org/wiki/${t.wikidata_id}">${r}</a>` : r,
                    i += t.hasOwnProperty("name") ? `${t.name} ` : "",
                    i += t.hasOwnProperty("name_en") ? `/ ${t.name_en} ` : "",
                    {
                        column: e,
                        value: i
                    }
                }
                )))).enter().append("td").html((t=>t.value))
            }(i)
        } else
            document.getElementById("table").textContent = ""
    }
    Bi.getSource(i + "Points") || Bi.addSource(i + "Points", {
        type: "vector",
        url: "mapbox://" + t.polyTilesetName.replace(e, i + "Points"),
        promoteId: "mapbox_id"
    }),
    rr = ["all", ["==", ["get", "iso_3166_1"], Yi], hr(Hi)];
    const n = function(t) {
        t.sourceId === e + "join" && (Bi.off("sourcedataloading", n),
        r())
    };
    Bi.isSourceLoaded(e + "join") ? (r(),
    Bi.off("sourcedataloading", n)) : Bi.on("sourcedataloading", n),
    Vi.style.visibility = "hidden",
    function() {
        $i = JSON.parse(s[Yi].bbox),
        qi = parseInt(s[Yi][Wi].z_min);
        try {
            const t = o($i, [window.innerWidth, window.innerHeight], 0, 12, 512);
            t.zoom = Math.max(t.zoom, qi + 1),
            // "US" === Yi && (t.center = [-100, 41],
            // t.zoom = 3.5),
            "CA" === Yi && (t.center = [-97, 63],
            t.zoom = 3.6),
            "GL" === Yi && (t.zoom = 3.5),
            "RU" === Yi && (t.center = [70, 60],
            t.zoom = 2.5),
            "CN" === Yi && (t.zoom = 3),
            "CA" === Yi && "pos4" === document.getElementById("selectLevel").value && (t.center = [-79.38656, 43.64865],
            t.zoom = 13),
            (Ji || Xi && qi > Bi.getZoom() || Bi.getZoom() < 2) && Bi.easeTo({
                center: t.center,
                zoom: t.zoom
            }),
            Xi = !1,
            Ji = !1
        } catch (t) {
            console.log(t)
        }
    }(),
    function(t) {
        let e = "0";
        er = function(i) {
            if (!Bi.getLayer(t))
                return;
            if (i.originalEvent.metaKey)
                return;
            const r = Bi.queryRenderedFeatures(i.point, {
                layers: [t]
            });
            if (!r.length)
                return tr.remove(),
                Bi.setFeatureState({
                    source: Wi + "join",
                    sourceLayer: Zi,
                    id: e
                }, {
                    hover: 0
                }),
                void (e = "0");
            const n = r[0]
              , o = n.id;
            if (e !== o) {
                Bi.setFeatureState({
                    source: Wi + "join",
                    sourceLayer: Zi,
                    id: e
                }, {
                    hover: 0
                }),
                e = o;
                const t = n.id
                  , i = Object.entries(Oi).length ? Oi[t] : null
                  , r = i && i.hasOwnProperty("name") ? i.name : null
                  , s = i && i.hasOwnProperty("name_en") ? i.name_en : null
                  , a = i && i.hasOwnProperty("code") ? i.code : ""
                  , l = i && i.hasOwnProperty("wikidata_id") ? i.wikidata_id : ""
                  , c = document.createElement("div");
                c.setAttribute("class", "flex-parent-inline flex-parent--center-cross flex-parent--column py2 px2");
                const u = document.createElement("div");
                u.setAttribute("class", "txt-h4 py2 px2 txt-bold");
                const h = document.createTextNode(`${r || ""} ${s ? "/ " + s : ""}`);
                u.appendChild(h),
                c.appendChild(u);
                const d = document.createElement("div");
                if (d.setAttribute("class", "txt-h5 py6 px6 mt3 d-none"),
                "" !== a) {
                    const t = document.createTextNode("Code ");
                    d.appendChild(t),
                    c.appendChild(d);
                    const e = document.createElement("span");
                    e.setAttribute("class", "txt-bold txt-kbd py6 px6");
                    const i = document.createTextNode(`${a}`);
                    e.appendChild(i),
                    d.appendChild(e)
                }
                if (l) {
                    const t = document.createElement("a");
                    t.setAttribute("class", "px3"),
                    t.href = "https://www.wikidata.org/wiki/" + l,
                    t.innerHTML = "<img class='mt-neg6' height=30 src='https://upload.wikimedia.org/wikipedia/commons/8/8f/W-circle.svg'>",
                    d.appendChild(t);
                    const e = document.createElement("div");
                    c.appendChild(e),
                    setTimeout(dr, 1e3, l, "en", ((t,i)=>{
                        const r = window.mobileCheck() ? i.content_urls.mobile.page : i.content_urls.desktop.page;
                        e.innerHTML = `<div class='prose txt-s' style='overflow: hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:8;-webkit-box-orient:vertical;'>${i.extract_html}</div><div><span class='txt-xs'>from <a class='link' href='${r}'>Wikipedia</a></div>`
                    }
                    ))
                }
                tr.setDOMContent(c).addTo(Bi)
            }
            Bi.setFeatureState({
                source: Wi + "join",
                sourceLayer: Zi,
                id: e
            }, {
                hover: 1
            }),
            tr.setLngLat(i.lngLat).addTo(Bi)
        }
        ,
        Bi.on("mouseout", Wi + "join", (()=>{
            Bi.setFeatureState({
                source: Wi + "join",
                sourceLayer: Zi,
                id: e
            }, {
                hover: 0
            }),
            tr.remove()
        }
        )),
        Bi.on("mousemove", er)
    }(e + "join"),
    function(t) {
        let e = new Map;
        ir = function(i) {
            const r = Bi.queryRenderedFeatures(i.point, {
                layers: [t]
            });
            let n = 0;
            if (!r.length)
                return e.forEach((t=>{
                    Bi.setFeatureState({
                        source: Wi + "join",
                        sourceLayer: Zi,
                        id: t
                    }, {
                        select: 0
                    })
                }
                )),
                n = 0,
                e = new Map,
                void Bi.setPaintProperty(t, "fill-opacity", 1);
            n = r[0].id,
            e.get(n) ? (e.delete(n),
            Bi.setFeatureState({
                source: Wi + "join",
                sourceLayer: Zi,
                id: n
            }, {
                select: 0
            })) : e.set(n, n),
            e.size > 0 ? (Bi.setPaintProperty(t, "fill-opacity", .9),
            e.forEach((t=>{
                Bi.setFeatureState({
                    source: Wi + "join",
                    sourceLayer: Zi,
                    id: t
                }, {
                    select: 1
                })
            }
            ))) : (Bi.setPaintProperty(t, "fill-opacity", 1),
            Bi.setFeatureState({
                source: Wi + "join",
                sourceLayer: Zi,
                id: n
            }, {
                select: 0
            }))
        }
        ,
        Bi.on("click", t, ir)
    }(e + "join")
}
function cr(t, e) {
    Ji = !0,
    Yi = t,
    document.getElementById("selectCountry").value = Yi,
    document.getElementById("selectCountry").dispatchEvent(new CustomEvent("change")),
    e ? (document.getElementById("selectWorldview").value = e,
    document.getElementById("selectWorldview").dispatchEvent(new CustomEvent("change"))) : sr()
}
function ur(t, e) {
    return t.getStyle().layers.filter((t=>e ? e(t) : t))
}
function hr(t) {
    return ["any", ["==", "all", ["get", "worldview"]], ["in", t, ["get", "worldview"]]]
}
function dr(t, e, i) {
    fetch(`https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&props=sitelinks&ids=${t}&sitefilter=${e}wiki&origin=*`, {
        headers: {
            "Content-Type": "application/json; charset=UTF-8",
            Origin: "https://demos.mapbox.com/boundaries-explorer/"
        }
    }).then((t=>t.json())).then((r=>{
        const n = r;
        if (n.entities[t].sitelinks.hasOwnProperty(e + "wiki") && n.entities[t].sitelinks[e + "wiki"].hasOwnProperty("title")) {
            const r = n.entities[t].sitelinks[e + "wiki"].title;
            fetch(`https://${e}.wikipedia.org/api/rest_v1/page/summary/${r}`, {
                headers: {
                    "Content-Type": "application/json; charset=UTF-8",
                    Origin: "https://demos.mapbox.com/boundaries-explorer/"
                }
            }).then((t=>t.json())).then((t=>{
                i(n, t)
            }
            ))
        }
    }
    ))
}
document.querySelectorAll("#selectCountry option").forEach((t=>{
    t.insertAdjacentHTML("beforeend", ' <span style="float:right">' + (t.value.toUpperCase().replace(/./g, (t=>String.fromCodePoint(127397 + t.charCodeAt()))) + "</span>"))
}
)),
or(),
document.getElementById("selectLevel").value = Wi || "adm2",
document.getElementById("selectCountry").value = Yi,
document.getElementById("selectWorldview").value = Hi,
document.getElementById("selectCountry").addEventListener("change", (t=>{
    Yi = t.target.value,
    Gi.remove();
    const e = document.createElement("select");
    e.setAttribute("class", "select select--stroke select--stroke-darken75"),
    e.setAttribute("id", "selectLevel"),
    document.getElementById("selectLevelContainer").appendChild(e),
    Gi = document.getElementById("selectLevel"),
    Gi.addEventListener("change", (()=>{
        Xi = !0,
        sr()
    }
    )),
    or()
}
)),
Bi.on("style.load", (()=>{
    Bi.setFog({
        range: [0, 2],
        "horizon-blend": .3,
        color: "grey",
        "high-color": "#add8e6",
        "space-color": "black",
        "star-intensity": 0
    }),
    sr(),
    Gi.addEventListener("change", (()=>{
        Xi = !0,
        sr()
    }
    )),
    ji.addEventListener("change", (()=>{
        sr()
    }
    )),
    Ni.addEventListener("change", (()=>{
        Ji = !0,
        sr()
    }
    ));
    const t = ur(Bi, (t=>"country_label" === t["source-layer"] || "country-label" === t.id)).map((t=>t.id));
    t.push("adm0"),
    Bi.on("mousemove", "adm0", (e=>{
        const i = Bi.queryRenderedFeatures(e.point, {
            layers: t
        });
        i.length ? (Bi.getCanvasContainer().style.cursor = "pointer",
        nr && nr !== i[0].properties.iso_3166_1 && Bi.setFeatureState({
            source: "adm0",
            sourceLayer: "boundaries_admin_0",
            id: s[nr].mapbox_id
        }, {
            hover: 0
        }),
        nr = i[0].properties.iso_3166_1,
        Bi.setFeatureState({
            source: "adm0",
            sourceLayer: "boundaries_admin_0",
            id: s[nr].mapbox_id
        }, {
            hover: 1
        })) : (Bi.getCanvasContainer().style.cursor = "",
        Bi.setFeatureState({
            source: "adm0",
            sourceLayer: "boundaries_admin_0",
            id: s[nr].mapbox_id
        }, {
            hover: 0
        }))
    }
    )),
    Bi.on("mouseout", "adm0", (()=>{
        Bi.setFeatureState({
            source: "adm0",
            sourceLayer: "boundaries_admin_0",
            id: s[nr].mapbox_id
        }, {
            hover: 0
        })
    }
    )),
    Bi.on("click", (e=>{
        const i = Bi.queryRenderedFeatures(e.point, {
            layers: t
        });
        i.length && "iso_3166_1"in i[0].properties && i[0].properties.iso_3166_1 !== document.getElementById("selectCountry").value && cr(i[0].properties.iso_3166_1)
    }
    ))
}
)),
window.mobileCheck = function() {
    let t = !1;
    var e;
    return e = navigator.userAgent || navigator.vendor || window.opera,
    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e.substr(0, 4))) && (t = !0),
    t
}
;
//# sourceMappingURL=index.f5d1d6dd.js.map
